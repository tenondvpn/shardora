1、限制挂单中吃单数量，获取一个挂单中吃单者数量  
     从数据库中查询？  先不管
2、挂单列表和订单列表的数据来源？                           
     都从数据库中查询， 智能合约中数据如何映射到数据库中字段  （合约提供一个查询接口，转换最新的数据到数据库） 
3、判断挂单超过3天？                                                 
    根据块中时间戳和块的高度？   如何获取块数据（block.timestamp）
4、锁定币超过3个月？
    根据块中时间戳和块的高度？（block.timestamp）
5、限制用户活跃（active）的挂单数量  或限制用户一段时间内的挂单数量（active和inactive）
    数据库中查询？不需要
6、需要权限校验？  比如：取消订单， 卖家只能操作“确认收款”；只能挂单者赎回未锁定的币
     需要，实现方式： （OnlyOwner） 角色判断
7、昵称数据来源 以及用户会修改昵称，每个吃单或挂单都需要保存挂单或吃单时刻的昵称？
     中心化数据库  （前期地址缩写）
8、支付类型和账号如何存储？  用户也会删改账号
       中心化数据库中？  （合约中string，json串）
9、信用分数据来源
      先写死（数据库字段中返回）
10、用户重复操作“确认收款”（多次调用）
  
11、transfer转币如何操作？ 

12、刷新币的数量，生成订单号等 需要引入可重入锁机制？ 
      不行
13、限制用户提交挂单的频率？
      app端同一个挂单，用户提交一次，多次请求  （后端靠时间间隔限制，前端也稍微限制一下）
14、需要专门定时任务？ 还是所有的移出操作依赖  用户触发
       锁死场景，还是要靠ownerAddress 用户去触发， 中心化服务器（cron）去触发 
15、挂单或吃单等接口的返回值，用结构体？ 还是基本类型
      不需要返回值。 
16、用户账户币数量是有一个mapping专门存储？  //mapping(address=>uint) public tokens;
       不需要。
17、双方取消(交易成功)时，挂单方释放的交易金和保证金， 是直接赎回个人钱包，还是返回合约地址？
     目前处理的返回合约地址。     分场景处理
18、买家挂单，交易成功时，挂单方释放的保证金， 是直接赎回个人钱包，还是返回合约地址？
     直接赎回个人钱包。  
----------------------------------------
19、卖家挂单中价格越高越先出队， 买家挂单中价格越低越先出队， 当优先队列满时：
       卖家挂单中更高价格的无法挂单？   会不会导致价格无法升高（币升值了）
       买家挂单中更低价格的无法挂单？   会不会导致价格无法降低 （币贬值了）
       虽有定时任务定时清理到期的挂单，但是用户不断以不合理的价格创建挂单
20、工具类(优先队列或数组)中数据类型与业务代码中数据类型不一致（uint64和uint256）， 是否需要统一
       订单号： uint64，但在数组中uint256