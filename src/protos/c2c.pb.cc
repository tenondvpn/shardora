// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/c2c.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "protos/c2c.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace zjchain {
namespace c2c {
namespace protobuf {

namespace {

const ::google::protobuf::Descriptor* OrderInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OrderInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* SellInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SellInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* NewOrder_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NewOrder_reflection_ = NULL;
const ::google::protobuf::Descriptor* NewSell_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NewSell_reflection_ = NULL;
const ::google::protobuf::Descriptor* BuyerReport_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BuyerReport_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetSell_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetSell_reflection_ = NULL;
const ::google::protobuf::Descriptor* C2cMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  C2cMessage_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Status_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_protos_2fc2c_2eproto() {
  protobuf_AddDesc_protos_2fc2c_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "protos/c2c.proto");
  GOOGLE_CHECK(file != NULL);
  OrderInfo_descriptor_ = file->message_type(0);
  static const int OrderInfo_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OrderInfo, buyer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OrderInfo, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OrderInfo, amount_),
  };
  OrderInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      OrderInfo_descriptor_,
      OrderInfo::default_instance_,
      OrderInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OrderInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OrderInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(OrderInfo));
  SellInfo_descriptor_ = file->message_type(1);
  static const int SellInfo_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SellInfo, protocol_addr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SellInfo, seller_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SellInfo, pledge_amount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SellInfo, price_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SellInfo, receivable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SellInfo, manager_released_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SellInfo, seller_released_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SellInfo, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SellInfo, order_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SellInfo, reports_),
  };
  SellInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SellInfo_descriptor_,
      SellInfo::default_instance_,
      SellInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SellInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SellInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SellInfo));
  NewOrder_descriptor_ = file->message_type(2);
  static const int NewOrder_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewOrder, seller_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewOrder, amount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewOrder, buyer_),
  };
  NewOrder_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NewOrder_descriptor_,
      NewOrder::default_instance_,
      NewOrder_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewOrder, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewOrder, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NewOrder));
  NewSell_descriptor_ = file->message_type(3);
  static const int NewSell_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewSell, protocol_addr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewSell, seller_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewSell, amount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewSell, price_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewSell, receivable_),
  };
  NewSell_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NewSell_descriptor_,
      NewSell::default_instance_,
      NewSell_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewSell, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewSell, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NewSell));
  BuyerReport_descriptor_ = file->message_type(4);
  static const int BuyerReport_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuyerReport, seller_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuyerReport, reports_info_),
  };
  BuyerReport_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BuyerReport_descriptor_,
      BuyerReport::default_instance_,
      BuyerReport_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuyerReport, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuyerReport, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BuyerReport));
  GetSell_descriptor_ = file->message_type(5);
  static const int GetSell_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetSell, seller_),
  };
  GetSell_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetSell_descriptor_,
      GetSell::default_instance_,
      GetSell_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetSell, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetSell, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetSell));
  C2cMessage_descriptor_ = file->message_type(6);
  static const int C2cMessage_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(C2cMessage, sell_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(C2cMessage, order_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(C2cMessage, report_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(C2cMessage, sells_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(C2cMessage, get_sell_),
  };
  C2cMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      C2cMessage_descriptor_,
      C2cMessage::default_instance_,
      C2cMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(C2cMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(C2cMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(C2cMessage));
  Status_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_protos_2fc2c_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    OrderInfo_descriptor_, &OrderInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SellInfo_descriptor_, &SellInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NewOrder_descriptor_, &NewOrder::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NewSell_descriptor_, &NewSell::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BuyerReport_descriptor_, &BuyerReport::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetSell_descriptor_, &GetSell::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    C2cMessage_descriptor_, &C2cMessage::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_protos_2fc2c_2eproto() {
  delete OrderInfo::default_instance_;
  delete OrderInfo_reflection_;
  delete SellInfo::default_instance_;
  delete SellInfo_reflection_;
  delete NewOrder::default_instance_;
  delete NewOrder_reflection_;
  delete NewSell::default_instance_;
  delete NewSell_reflection_;
  delete BuyerReport::default_instance_;
  delete BuyerReport_reflection_;
  delete GetSell::default_instance_;
  delete GetSell_reflection_;
  delete C2cMessage::default_instance_;
  delete C2cMessage_reflection_;
}

void protobuf_AddDesc_protos_2fc2c_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\020protos/c2c.proto\022\024zjchain.c2c.protobuf"
    "\"X\n\tOrderInfo\022\r\n\005buyer\030\001 \001(\014\022,\n\006status\030\002"
    " \001(\0162\034.zjchain.c2c.protobuf.Status\022\016\n\006am"
    "ount\030\003 \001(\004\"\222\002\n\010SellInfo\022\025\n\rprotocol_addr"
    "\030\001 \001(\014\022\016\n\006seller\030\002 \001(\014\022\025\n\rpledge_amount\030"
    "\003 \001(\004\022\r\n\005price\030\004 \001(\004\022\022\n\nreceivable\030\005 \001(\014"
    "\022\030\n\020manager_released\030\006 \001(\010\022\027\n\017seller_rel"
    "eased\030\007 \001(\010\022,\n\006status\030\010 \001(\0162\034.zjchain.c2"
    "c.protobuf.Status\0223\n\norder_info\030\t \001(\0132\037."
    "zjchain.c2c.protobuf.OrderInfo\022\017\n\007report"
    "s\030\n \003(\014\"9\n\010NewOrder\022\016\n\006seller\030\001 \001(\014\022\016\n\006a"
    "mount\030\002 \001(\004\022\r\n\005buyer\030\003 \001(\014\"c\n\007NewSell\022\025\n"
    "\rprotocol_addr\030\001 \001(\014\022\016\n\006seller\030\002 \001(\014\022\016\n\006"
    "amount\030\003 \001(\004\022\r\n\005price\030\004 \001(\004\022\022\n\nreceivabl"
    "e\030\005 \001(\014\"3\n\013BuyerReport\022\016\n\006seller\030\001 \001(\014\022\024"
    "\n\014reports_info\030\002 \001(\014\"\031\n\007GetSell\022\016\n\006selle"
    "r\030\001 \001(\014\"\373\001\n\nC2cMessage\022+\n\004sell\030\001 \001(\0132\035.z"
    "jchain.c2c.protobuf.NewSell\022-\n\005order\030\002 \001"
    "(\0132\036.zjchain.c2c.protobuf.NewOrder\0221\n\006re"
    "port\030\003 \001(\0132!.zjchain.c2c.protobuf.BuyerR"
    "eport\022-\n\005sells\030\004 \003(\0132\036.zjchain.c2c.proto"
    "buf.SellInfo\022/\n\010get_sell\030\005 \003(\0132\035.zjchain"
    ".c2c.protobuf.GetSell*\215\001\n\006Status\022\014\n\010kDef"
    "ault\020\000\022\016\n\nkConfirmed\020\001\022\r\n\tkReported\020\002\022\020\n"
    "\014kSellWaiting\020\003\022\016\n\nkSellValid\020\004\022\020\n\014kSell"
    "Invalid\020\005\022\021\n\rkSellReleased\020\006\022\017\n\013kSellExi"
    "sts\020\007", 1045);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "protos/c2c.proto", &protobuf_RegisterTypes);
  OrderInfo::default_instance_ = new OrderInfo();
  SellInfo::default_instance_ = new SellInfo();
  NewOrder::default_instance_ = new NewOrder();
  NewSell::default_instance_ = new NewSell();
  BuyerReport::default_instance_ = new BuyerReport();
  GetSell::default_instance_ = new GetSell();
  C2cMessage::default_instance_ = new C2cMessage();
  OrderInfo::default_instance_->InitAsDefaultInstance();
  SellInfo::default_instance_->InitAsDefaultInstance();
  NewOrder::default_instance_->InitAsDefaultInstance();
  NewSell::default_instance_->InitAsDefaultInstance();
  BuyerReport::default_instance_->InitAsDefaultInstance();
  GetSell::default_instance_->InitAsDefaultInstance();
  C2cMessage::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_protos_2fc2c_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_protos_2fc2c_2eproto {
  StaticDescriptorInitializer_protos_2fc2c_2eproto() {
    protobuf_AddDesc_protos_2fc2c_2eproto();
  }
} static_descriptor_initializer_protos_2fc2c_2eproto_;
const ::google::protobuf::EnumDescriptor* Status_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Status_descriptor_;
}
bool Status_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int OrderInfo::kBuyerFieldNumber;
const int OrderInfo::kStatusFieldNumber;
const int OrderInfo::kAmountFieldNumber;
#endif  // !_MSC_VER

OrderInfo::OrderInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void OrderInfo::InitAsDefaultInstance() {
}

OrderInfo::OrderInfo(const OrderInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void OrderInfo::SharedCtor() {
  _cached_size_ = 0;
  buyer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_ = 0;
  amount_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OrderInfo::~OrderInfo() {
  SharedDtor();
}

void OrderInfo::SharedDtor() {
  if (buyer_ != &::google::protobuf::internal::kEmptyString) {
    delete buyer_;
  }
  if (this != default_instance_) {
  }
}

void OrderInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OrderInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OrderInfo_descriptor_;
}

const OrderInfo& OrderInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protos_2fc2c_2eproto();
  return *default_instance_;
}

OrderInfo* OrderInfo::default_instance_ = NULL;

OrderInfo* OrderInfo::New() const {
  return new OrderInfo;
}

void OrderInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_buyer()) {
      if (buyer_ != &::google::protobuf::internal::kEmptyString) {
        buyer_->clear();
      }
    }
    status_ = 0;
    amount_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool OrderInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes buyer = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_buyer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_status;
        break;
      }

      // optional .zjchain.c2c.protobuf.Status status = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::zjchain::c2c::protobuf::Status_IsValid(value)) {
            set_status(static_cast< ::zjchain::c2c::protobuf::Status >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_amount;
        break;
      }

      // optional uint64 amount = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_amount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &amount_)));
          set_has_amount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OrderInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes buyer = 1;
  if (has_buyer()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->buyer(), output);
  }

  // optional .zjchain.c2c.protobuf.Status status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

  // optional uint64 amount = 3;
  if (has_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->amount(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* OrderInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes buyer = 1;
  if (has_buyer()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->buyer(), target);
  }

  // optional .zjchain.c2c.protobuf.Status status = 2;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->status(), target);
  }

  // optional uint64 amount = 3;
  if (has_amount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->amount(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int OrderInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes buyer = 1;
    if (has_buyer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->buyer());
    }

    // optional .zjchain.c2c.protobuf.Status status = 2;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // optional uint64 amount = 3;
    if (has_amount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->amount());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OrderInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const OrderInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const OrderInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OrderInfo::MergeFrom(const OrderInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_buyer()) {
      set_buyer(from.buyer());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_amount()) {
      set_amount(from.amount());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void OrderInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OrderInfo::CopyFrom(const OrderInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrderInfo::IsInitialized() const {

  return true;
}

void OrderInfo::Swap(OrderInfo* other) {
  if (other != this) {
    std::swap(buyer_, other->buyer_);
    std::swap(status_, other->status_);
    std::swap(amount_, other->amount_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata OrderInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OrderInfo_descriptor_;
  metadata.reflection = OrderInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SellInfo::kProtocolAddrFieldNumber;
const int SellInfo::kSellerFieldNumber;
const int SellInfo::kPledgeAmountFieldNumber;
const int SellInfo::kPriceFieldNumber;
const int SellInfo::kReceivableFieldNumber;
const int SellInfo::kManagerReleasedFieldNumber;
const int SellInfo::kSellerReleasedFieldNumber;
const int SellInfo::kStatusFieldNumber;
const int SellInfo::kOrderInfoFieldNumber;
const int SellInfo::kReportsFieldNumber;
#endif  // !_MSC_VER

SellInfo::SellInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SellInfo::InitAsDefaultInstance() {
  order_info_ = const_cast< ::zjchain::c2c::protobuf::OrderInfo*>(&::zjchain::c2c::protobuf::OrderInfo::default_instance());
}

SellInfo::SellInfo(const SellInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SellInfo::SharedCtor() {
  _cached_size_ = 0;
  protocol_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  seller_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  pledge_amount_ = GOOGLE_ULONGLONG(0);
  price_ = GOOGLE_ULONGLONG(0);
  receivable_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  manager_released_ = false;
  seller_released_ = false;
  status_ = 0;
  order_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SellInfo::~SellInfo() {
  SharedDtor();
}

void SellInfo::SharedDtor() {
  if (protocol_addr_ != &::google::protobuf::internal::kEmptyString) {
    delete protocol_addr_;
  }
  if (seller_ != &::google::protobuf::internal::kEmptyString) {
    delete seller_;
  }
  if (receivable_ != &::google::protobuf::internal::kEmptyString) {
    delete receivable_;
  }
  if (this != default_instance_) {
    delete order_info_;
  }
}

void SellInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SellInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SellInfo_descriptor_;
}

const SellInfo& SellInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protos_2fc2c_2eproto();
  return *default_instance_;
}

SellInfo* SellInfo::default_instance_ = NULL;

SellInfo* SellInfo::New() const {
  return new SellInfo;
}

void SellInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_protocol_addr()) {
      if (protocol_addr_ != &::google::protobuf::internal::kEmptyString) {
        protocol_addr_->clear();
      }
    }
    if (has_seller()) {
      if (seller_ != &::google::protobuf::internal::kEmptyString) {
        seller_->clear();
      }
    }
    pledge_amount_ = GOOGLE_ULONGLONG(0);
    price_ = GOOGLE_ULONGLONG(0);
    if (has_receivable()) {
      if (receivable_ != &::google::protobuf::internal::kEmptyString) {
        receivable_->clear();
      }
    }
    manager_released_ = false;
    seller_released_ = false;
    status_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_order_info()) {
      if (order_info_ != NULL) order_info_->::zjchain::c2c::protobuf::OrderInfo::Clear();
    }
  }
  reports_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SellInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes protocol_addr = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_protocol_addr()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_seller;
        break;
      }

      // optional bytes seller = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_seller:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_seller()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_pledge_amount;
        break;
      }

      // optional uint64 pledge_amount = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pledge_amount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pledge_amount_)));
          set_has_pledge_amount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_price;
        break;
      }

      // optional uint64 price = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_price:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &price_)));
          set_has_price();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_receivable;
        break;
      }

      // optional bytes receivable = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_receivable:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_receivable()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_manager_released;
        break;
      }

      // optional bool manager_released = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_manager_released:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &manager_released_)));
          set_has_manager_released();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_seller_released;
        break;
      }

      // optional bool seller_released = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_seller_released:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &seller_released_)));
          set_has_seller_released();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_status;
        break;
      }

      // optional .zjchain.c2c.protobuf.Status status = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::zjchain::c2c::protobuf::Status_IsValid(value)) {
            set_status(static_cast< ::zjchain::c2c::protobuf::Status >(value));
          } else {
            mutable_unknown_fields()->AddVarint(8, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_order_info;
        break;
      }

      // optional .zjchain.c2c.protobuf.OrderInfo order_info = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_order_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_order_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_reports;
        break;
      }

      // repeated bytes reports = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reports:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_reports()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_reports;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SellInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes protocol_addr = 1;
  if (has_protocol_addr()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->protocol_addr(), output);
  }

  // optional bytes seller = 2;
  if (has_seller()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->seller(), output);
  }

  // optional uint64 pledge_amount = 3;
  if (has_pledge_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->pledge_amount(), output);
  }

  // optional uint64 price = 4;
  if (has_price()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->price(), output);
  }

  // optional bytes receivable = 5;
  if (has_receivable()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->receivable(), output);
  }

  // optional bool manager_released = 6;
  if (has_manager_released()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->manager_released(), output);
  }

  // optional bool seller_released = 7;
  if (has_seller_released()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->seller_released(), output);
  }

  // optional .zjchain.c2c.protobuf.Status status = 8;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      8, this->status(), output);
  }

  // optional .zjchain.c2c.protobuf.OrderInfo order_info = 9;
  if (has_order_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->order_info(), output);
  }

  // repeated bytes reports = 10;
  for (int i = 0; i < this->reports_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      10, this->reports(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SellInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes protocol_addr = 1;
  if (has_protocol_addr()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->protocol_addr(), target);
  }

  // optional bytes seller = 2;
  if (has_seller()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->seller(), target);
  }

  // optional uint64 pledge_amount = 3;
  if (has_pledge_amount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->pledge_amount(), target);
  }

  // optional uint64 price = 4;
  if (has_price()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->price(), target);
  }

  // optional bytes receivable = 5;
  if (has_receivable()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->receivable(), target);
  }

  // optional bool manager_released = 6;
  if (has_manager_released()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->manager_released(), target);
  }

  // optional bool seller_released = 7;
  if (has_seller_released()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->seller_released(), target);
  }

  // optional .zjchain.c2c.protobuf.Status status = 8;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      8, this->status(), target);
  }

  // optional .zjchain.c2c.protobuf.OrderInfo order_info = 9;
  if (has_order_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->order_info(), target);
  }

  // repeated bytes reports = 10;
  for (int i = 0; i < this->reports_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(10, this->reports(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SellInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes protocol_addr = 1;
    if (has_protocol_addr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->protocol_addr());
    }

    // optional bytes seller = 2;
    if (has_seller()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->seller());
    }

    // optional uint64 pledge_amount = 3;
    if (has_pledge_amount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->pledge_amount());
    }

    // optional uint64 price = 4;
    if (has_price()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->price());
    }

    // optional bytes receivable = 5;
    if (has_receivable()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->receivable());
    }

    // optional bool manager_released = 6;
    if (has_manager_released()) {
      total_size += 1 + 1;
    }

    // optional bool seller_released = 7;
    if (has_seller_released()) {
      total_size += 1 + 1;
    }

    // optional .zjchain.c2c.protobuf.Status status = 8;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .zjchain.c2c.protobuf.OrderInfo order_info = 9;
    if (has_order_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->order_info());
    }

  }
  // repeated bytes reports = 10;
  total_size += 1 * this->reports_size();
  for (int i = 0; i < this->reports_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->reports(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SellInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SellInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SellInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SellInfo::MergeFrom(const SellInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  reports_.MergeFrom(from.reports_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_protocol_addr()) {
      set_protocol_addr(from.protocol_addr());
    }
    if (from.has_seller()) {
      set_seller(from.seller());
    }
    if (from.has_pledge_amount()) {
      set_pledge_amount(from.pledge_amount());
    }
    if (from.has_price()) {
      set_price(from.price());
    }
    if (from.has_receivable()) {
      set_receivable(from.receivable());
    }
    if (from.has_manager_released()) {
      set_manager_released(from.manager_released());
    }
    if (from.has_seller_released()) {
      set_seller_released(from.seller_released());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_order_info()) {
      mutable_order_info()->::zjchain::c2c::protobuf::OrderInfo::MergeFrom(from.order_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SellInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SellInfo::CopyFrom(const SellInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SellInfo::IsInitialized() const {

  return true;
}

void SellInfo::Swap(SellInfo* other) {
  if (other != this) {
    std::swap(protocol_addr_, other->protocol_addr_);
    std::swap(seller_, other->seller_);
    std::swap(pledge_amount_, other->pledge_amount_);
    std::swap(price_, other->price_);
    std::swap(receivable_, other->receivable_);
    std::swap(manager_released_, other->manager_released_);
    std::swap(seller_released_, other->seller_released_);
    std::swap(status_, other->status_);
    std::swap(order_info_, other->order_info_);
    reports_.Swap(&other->reports_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SellInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SellInfo_descriptor_;
  metadata.reflection = SellInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NewOrder::kSellerFieldNumber;
const int NewOrder::kAmountFieldNumber;
const int NewOrder::kBuyerFieldNumber;
#endif  // !_MSC_VER

NewOrder::NewOrder()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NewOrder::InitAsDefaultInstance() {
}

NewOrder::NewOrder(const NewOrder& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NewOrder::SharedCtor() {
  _cached_size_ = 0;
  seller_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  amount_ = GOOGLE_ULONGLONG(0);
  buyer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NewOrder::~NewOrder() {
  SharedDtor();
}

void NewOrder::SharedDtor() {
  if (seller_ != &::google::protobuf::internal::kEmptyString) {
    delete seller_;
  }
  if (buyer_ != &::google::protobuf::internal::kEmptyString) {
    delete buyer_;
  }
  if (this != default_instance_) {
  }
}

void NewOrder::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NewOrder::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NewOrder_descriptor_;
}

const NewOrder& NewOrder::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protos_2fc2c_2eproto();
  return *default_instance_;
}

NewOrder* NewOrder::default_instance_ = NULL;

NewOrder* NewOrder::New() const {
  return new NewOrder;
}

void NewOrder::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_seller()) {
      if (seller_ != &::google::protobuf::internal::kEmptyString) {
        seller_->clear();
      }
    }
    amount_ = GOOGLE_ULONGLONG(0);
    if (has_buyer()) {
      if (buyer_ != &::google::protobuf::internal::kEmptyString) {
        buyer_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NewOrder::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes seller = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_seller()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_amount;
        break;
      }

      // optional uint64 amount = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_amount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &amount_)));
          set_has_amount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_buyer;
        break;
      }

      // optional bytes buyer = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_buyer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_buyer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NewOrder::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes seller = 1;
  if (has_seller()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->seller(), output);
  }

  // optional uint64 amount = 2;
  if (has_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->amount(), output);
  }

  // optional bytes buyer = 3;
  if (has_buyer()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->buyer(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NewOrder::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes seller = 1;
  if (has_seller()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->seller(), target);
  }

  // optional uint64 amount = 2;
  if (has_amount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->amount(), target);
  }

  // optional bytes buyer = 3;
  if (has_buyer()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->buyer(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NewOrder::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes seller = 1;
    if (has_seller()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->seller());
    }

    // optional uint64 amount = 2;
    if (has_amount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->amount());
    }

    // optional bytes buyer = 3;
    if (has_buyer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->buyer());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NewOrder::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NewOrder* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NewOrder*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NewOrder::MergeFrom(const NewOrder& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seller()) {
      set_seller(from.seller());
    }
    if (from.has_amount()) {
      set_amount(from.amount());
    }
    if (from.has_buyer()) {
      set_buyer(from.buyer());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NewOrder::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NewOrder::CopyFrom(const NewOrder& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewOrder::IsInitialized() const {

  return true;
}

void NewOrder::Swap(NewOrder* other) {
  if (other != this) {
    std::swap(seller_, other->seller_);
    std::swap(amount_, other->amount_);
    std::swap(buyer_, other->buyer_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NewOrder::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NewOrder_descriptor_;
  metadata.reflection = NewOrder_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NewSell::kProtocolAddrFieldNumber;
const int NewSell::kSellerFieldNumber;
const int NewSell::kAmountFieldNumber;
const int NewSell::kPriceFieldNumber;
const int NewSell::kReceivableFieldNumber;
#endif  // !_MSC_VER

NewSell::NewSell()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NewSell::InitAsDefaultInstance() {
}

NewSell::NewSell(const NewSell& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NewSell::SharedCtor() {
  _cached_size_ = 0;
  protocol_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  seller_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  amount_ = GOOGLE_ULONGLONG(0);
  price_ = GOOGLE_ULONGLONG(0);
  receivable_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NewSell::~NewSell() {
  SharedDtor();
}

void NewSell::SharedDtor() {
  if (protocol_addr_ != &::google::protobuf::internal::kEmptyString) {
    delete protocol_addr_;
  }
  if (seller_ != &::google::protobuf::internal::kEmptyString) {
    delete seller_;
  }
  if (receivable_ != &::google::protobuf::internal::kEmptyString) {
    delete receivable_;
  }
  if (this != default_instance_) {
  }
}

void NewSell::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NewSell::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NewSell_descriptor_;
}

const NewSell& NewSell::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protos_2fc2c_2eproto();
  return *default_instance_;
}

NewSell* NewSell::default_instance_ = NULL;

NewSell* NewSell::New() const {
  return new NewSell;
}

void NewSell::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_protocol_addr()) {
      if (protocol_addr_ != &::google::protobuf::internal::kEmptyString) {
        protocol_addr_->clear();
      }
    }
    if (has_seller()) {
      if (seller_ != &::google::protobuf::internal::kEmptyString) {
        seller_->clear();
      }
    }
    amount_ = GOOGLE_ULONGLONG(0);
    price_ = GOOGLE_ULONGLONG(0);
    if (has_receivable()) {
      if (receivable_ != &::google::protobuf::internal::kEmptyString) {
        receivable_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NewSell::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes protocol_addr = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_protocol_addr()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_seller;
        break;
      }

      // optional bytes seller = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_seller:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_seller()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_amount;
        break;
      }

      // optional uint64 amount = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_amount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &amount_)));
          set_has_amount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_price;
        break;
      }

      // optional uint64 price = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_price:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &price_)));
          set_has_price();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_receivable;
        break;
      }

      // optional bytes receivable = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_receivable:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_receivable()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NewSell::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes protocol_addr = 1;
  if (has_protocol_addr()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->protocol_addr(), output);
  }

  // optional bytes seller = 2;
  if (has_seller()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->seller(), output);
  }

  // optional uint64 amount = 3;
  if (has_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->amount(), output);
  }

  // optional uint64 price = 4;
  if (has_price()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->price(), output);
  }

  // optional bytes receivable = 5;
  if (has_receivable()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->receivable(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NewSell::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes protocol_addr = 1;
  if (has_protocol_addr()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->protocol_addr(), target);
  }

  // optional bytes seller = 2;
  if (has_seller()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->seller(), target);
  }

  // optional uint64 amount = 3;
  if (has_amount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->amount(), target);
  }

  // optional uint64 price = 4;
  if (has_price()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->price(), target);
  }

  // optional bytes receivable = 5;
  if (has_receivable()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->receivable(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NewSell::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes protocol_addr = 1;
    if (has_protocol_addr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->protocol_addr());
    }

    // optional bytes seller = 2;
    if (has_seller()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->seller());
    }

    // optional uint64 amount = 3;
    if (has_amount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->amount());
    }

    // optional uint64 price = 4;
    if (has_price()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->price());
    }

    // optional bytes receivable = 5;
    if (has_receivable()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->receivable());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NewSell::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NewSell* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NewSell*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NewSell::MergeFrom(const NewSell& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_protocol_addr()) {
      set_protocol_addr(from.protocol_addr());
    }
    if (from.has_seller()) {
      set_seller(from.seller());
    }
    if (from.has_amount()) {
      set_amount(from.amount());
    }
    if (from.has_price()) {
      set_price(from.price());
    }
    if (from.has_receivable()) {
      set_receivable(from.receivable());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NewSell::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NewSell::CopyFrom(const NewSell& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewSell::IsInitialized() const {

  return true;
}

void NewSell::Swap(NewSell* other) {
  if (other != this) {
    std::swap(protocol_addr_, other->protocol_addr_);
    std::swap(seller_, other->seller_);
    std::swap(amount_, other->amount_);
    std::swap(price_, other->price_);
    std::swap(receivable_, other->receivable_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NewSell::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NewSell_descriptor_;
  metadata.reflection = NewSell_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BuyerReport::kSellerFieldNumber;
const int BuyerReport::kReportsInfoFieldNumber;
#endif  // !_MSC_VER

BuyerReport::BuyerReport()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BuyerReport::InitAsDefaultInstance() {
}

BuyerReport::BuyerReport(const BuyerReport& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BuyerReport::SharedCtor() {
  _cached_size_ = 0;
  seller_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  reports_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BuyerReport::~BuyerReport() {
  SharedDtor();
}

void BuyerReport::SharedDtor() {
  if (seller_ != &::google::protobuf::internal::kEmptyString) {
    delete seller_;
  }
  if (reports_info_ != &::google::protobuf::internal::kEmptyString) {
    delete reports_info_;
  }
  if (this != default_instance_) {
  }
}

void BuyerReport::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BuyerReport::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BuyerReport_descriptor_;
}

const BuyerReport& BuyerReport::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protos_2fc2c_2eproto();
  return *default_instance_;
}

BuyerReport* BuyerReport::default_instance_ = NULL;

BuyerReport* BuyerReport::New() const {
  return new BuyerReport;
}

void BuyerReport::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_seller()) {
      if (seller_ != &::google::protobuf::internal::kEmptyString) {
        seller_->clear();
      }
    }
    if (has_reports_info()) {
      if (reports_info_ != &::google::protobuf::internal::kEmptyString) {
        reports_info_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BuyerReport::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes seller = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_seller()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_reports_info;
        break;
      }

      // optional bytes reports_info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reports_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_reports_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BuyerReport::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes seller = 1;
  if (has_seller()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->seller(), output);
  }

  // optional bytes reports_info = 2;
  if (has_reports_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->reports_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BuyerReport::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes seller = 1;
  if (has_seller()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->seller(), target);
  }

  // optional bytes reports_info = 2;
  if (has_reports_info()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->reports_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BuyerReport::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes seller = 1;
    if (has_seller()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->seller());
    }

    // optional bytes reports_info = 2;
    if (has_reports_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->reports_info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BuyerReport::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BuyerReport* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BuyerReport*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BuyerReport::MergeFrom(const BuyerReport& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seller()) {
      set_seller(from.seller());
    }
    if (from.has_reports_info()) {
      set_reports_info(from.reports_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BuyerReport::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BuyerReport::CopyFrom(const BuyerReport& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuyerReport::IsInitialized() const {

  return true;
}

void BuyerReport::Swap(BuyerReport* other) {
  if (other != this) {
    std::swap(seller_, other->seller_);
    std::swap(reports_info_, other->reports_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BuyerReport::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BuyerReport_descriptor_;
  metadata.reflection = BuyerReport_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GetSell::kSellerFieldNumber;
#endif  // !_MSC_VER

GetSell::GetSell()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetSell::InitAsDefaultInstance() {
}

GetSell::GetSell(const GetSell& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetSell::SharedCtor() {
  _cached_size_ = 0;
  seller_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetSell::~GetSell() {
  SharedDtor();
}

void GetSell::SharedDtor() {
  if (seller_ != &::google::protobuf::internal::kEmptyString) {
    delete seller_;
  }
  if (this != default_instance_) {
  }
}

void GetSell::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetSell::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetSell_descriptor_;
}

const GetSell& GetSell::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protos_2fc2c_2eproto();
  return *default_instance_;
}

GetSell* GetSell::default_instance_ = NULL;

GetSell* GetSell::New() const {
  return new GetSell;
}

void GetSell::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_seller()) {
      if (seller_ != &::google::protobuf::internal::kEmptyString) {
        seller_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetSell::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes seller = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_seller()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetSell::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes seller = 1;
  if (has_seller()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->seller(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetSell::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes seller = 1;
  if (has_seller()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->seller(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetSell::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes seller = 1;
    if (has_seller()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->seller());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetSell::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetSell* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetSell*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetSell::MergeFrom(const GetSell& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seller()) {
      set_seller(from.seller());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetSell::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetSell::CopyFrom(const GetSell& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetSell::IsInitialized() const {

  return true;
}

void GetSell::Swap(GetSell* other) {
  if (other != this) {
    std::swap(seller_, other->seller_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetSell::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetSell_descriptor_;
  metadata.reflection = GetSell_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int C2cMessage::kSellFieldNumber;
const int C2cMessage::kOrderFieldNumber;
const int C2cMessage::kReportFieldNumber;
const int C2cMessage::kSellsFieldNumber;
const int C2cMessage::kGetSellFieldNumber;
#endif  // !_MSC_VER

C2cMessage::C2cMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void C2cMessage::InitAsDefaultInstance() {
  sell_ = const_cast< ::zjchain::c2c::protobuf::NewSell*>(&::zjchain::c2c::protobuf::NewSell::default_instance());
  order_ = const_cast< ::zjchain::c2c::protobuf::NewOrder*>(&::zjchain::c2c::protobuf::NewOrder::default_instance());
  report_ = const_cast< ::zjchain::c2c::protobuf::BuyerReport*>(&::zjchain::c2c::protobuf::BuyerReport::default_instance());
}

C2cMessage::C2cMessage(const C2cMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void C2cMessage::SharedCtor() {
  _cached_size_ = 0;
  sell_ = NULL;
  order_ = NULL;
  report_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

C2cMessage::~C2cMessage() {
  SharedDtor();
}

void C2cMessage::SharedDtor() {
  if (this != default_instance_) {
    delete sell_;
    delete order_;
    delete report_;
  }
}

void C2cMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* C2cMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return C2cMessage_descriptor_;
}

const C2cMessage& C2cMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protos_2fc2c_2eproto();
  return *default_instance_;
}

C2cMessage* C2cMessage::default_instance_ = NULL;

C2cMessage* C2cMessage::New() const {
  return new C2cMessage;
}

void C2cMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_sell()) {
      if (sell_ != NULL) sell_->::zjchain::c2c::protobuf::NewSell::Clear();
    }
    if (has_order()) {
      if (order_ != NULL) order_->::zjchain::c2c::protobuf::NewOrder::Clear();
    }
    if (has_report()) {
      if (report_ != NULL) report_->::zjchain::c2c::protobuf::BuyerReport::Clear();
    }
  }
  sells_.Clear();
  get_sell_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool C2cMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .zjchain.c2c.protobuf.NewSell sell = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sell()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_order;
        break;
      }

      // optional .zjchain.c2c.protobuf.NewOrder order = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_order:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_order()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_report;
        break;
      }

      // optional .zjchain.c2c.protobuf.BuyerReport report = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_report:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_report()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_sells;
        break;
      }

      // repeated .zjchain.c2c.protobuf.SellInfo sells = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sells:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sells()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_sells;
        if (input->ExpectTag(42)) goto parse_get_sell;
        break;
      }

      // repeated .zjchain.c2c.protobuf.GetSell get_sell = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_sell:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_get_sell()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_get_sell;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void C2cMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .zjchain.c2c.protobuf.NewSell sell = 1;
  if (has_sell()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->sell(), output);
  }

  // optional .zjchain.c2c.protobuf.NewOrder order = 2;
  if (has_order()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->order(), output);
  }

  // optional .zjchain.c2c.protobuf.BuyerReport report = 3;
  if (has_report()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->report(), output);
  }

  // repeated .zjchain.c2c.protobuf.SellInfo sells = 4;
  for (int i = 0; i < this->sells_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->sells(i), output);
  }

  // repeated .zjchain.c2c.protobuf.GetSell get_sell = 5;
  for (int i = 0; i < this->get_sell_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->get_sell(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* C2cMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .zjchain.c2c.protobuf.NewSell sell = 1;
  if (has_sell()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->sell(), target);
  }

  // optional .zjchain.c2c.protobuf.NewOrder order = 2;
  if (has_order()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->order(), target);
  }

  // optional .zjchain.c2c.protobuf.BuyerReport report = 3;
  if (has_report()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->report(), target);
  }

  // repeated .zjchain.c2c.protobuf.SellInfo sells = 4;
  for (int i = 0; i < this->sells_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->sells(i), target);
  }

  // repeated .zjchain.c2c.protobuf.GetSell get_sell = 5;
  for (int i = 0; i < this->get_sell_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->get_sell(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int C2cMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .zjchain.c2c.protobuf.NewSell sell = 1;
    if (has_sell()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sell());
    }

    // optional .zjchain.c2c.protobuf.NewOrder order = 2;
    if (has_order()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->order());
    }

    // optional .zjchain.c2c.protobuf.BuyerReport report = 3;
    if (has_report()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->report());
    }

  }
  // repeated .zjchain.c2c.protobuf.SellInfo sells = 4;
  total_size += 1 * this->sells_size();
  for (int i = 0; i < this->sells_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sells(i));
  }

  // repeated .zjchain.c2c.protobuf.GetSell get_sell = 5;
  total_size += 1 * this->get_sell_size();
  for (int i = 0; i < this->get_sell_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->get_sell(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void C2cMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const C2cMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const C2cMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void C2cMessage::MergeFrom(const C2cMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  sells_.MergeFrom(from.sells_);
  get_sell_.MergeFrom(from.get_sell_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sell()) {
      mutable_sell()->::zjchain::c2c::protobuf::NewSell::MergeFrom(from.sell());
    }
    if (from.has_order()) {
      mutable_order()->::zjchain::c2c::protobuf::NewOrder::MergeFrom(from.order());
    }
    if (from.has_report()) {
      mutable_report()->::zjchain::c2c::protobuf::BuyerReport::MergeFrom(from.report());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void C2cMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void C2cMessage::CopyFrom(const C2cMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C2cMessage::IsInitialized() const {

  return true;
}

void C2cMessage::Swap(C2cMessage* other) {
  if (other != this) {
    std::swap(sell_, other->sell_);
    std::swap(order_, other->order_);
    std::swap(report_, other->report_);
    sells_.Swap(&other->sells_);
    get_sell_.Swap(&other->get_sell_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata C2cMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = C2cMessage_descriptor_;
  metadata.reflection = C2cMessage_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace c2c
}  // namespace zjchain

// @@protoc_insertion_point(global_scope)
