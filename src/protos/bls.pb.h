// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/bls.proto

#ifndef PROTOBUF_protos_2fbls_2eproto__INCLUDED
#define PROTOBUF_protos_2fbls_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace zjchain {
namespace bls {
namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_protos_2fbls_2eproto();
void protobuf_AssignDesc_protos_2fbls_2eproto();
void protobuf_ShutdownFile_protos_2fbls_2eproto();

class VerifyVecItem;
class BlsPublicKey;
class VerifyVecBrdReq;
class JoinElectBlsInfo;
class JoinElectInfo;
class LocalPolynomial;
class LocalBlsItem;
class BlsVerifyValue;
class VerifyVecBrdRes;
class SwapSecKeyItem;
class SwapSecKeyReq;
class SwapSecKeyRes;
class AgainstParticipant;
class FinishBroadcast;
class CheckVerfiyReq;
class CheckSwapKeyReq;
class BlsMessage;

// ===================================================================

class VerifyVecItem : public ::google::protobuf::Message {
 public:
  VerifyVecItem();
  virtual ~VerifyVecItem();

  VerifyVecItem(const VerifyVecItem& from);

  inline VerifyVecItem& operator=(const VerifyVecItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VerifyVecItem& default_instance();

  void Swap(VerifyVecItem* other);

  // implements Message ----------------------------------------------

  VerifyVecItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VerifyVecItem& from);
  void MergeFrom(const VerifyVecItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes x_c0 = 1;
  inline bool has_x_c0() const;
  inline void clear_x_c0();
  static const int kXC0FieldNumber = 1;
  inline const ::std::string& x_c0() const;
  inline void set_x_c0(const ::std::string& value);
  inline void set_x_c0(const char* value);
  inline void set_x_c0(const void* value, size_t size);
  inline ::std::string* mutable_x_c0();
  inline ::std::string* release_x_c0();
  inline void set_allocated_x_c0(::std::string* x_c0);

  // optional bytes x_c1 = 2;
  inline bool has_x_c1() const;
  inline void clear_x_c1();
  static const int kXC1FieldNumber = 2;
  inline const ::std::string& x_c1() const;
  inline void set_x_c1(const ::std::string& value);
  inline void set_x_c1(const char* value);
  inline void set_x_c1(const void* value, size_t size);
  inline ::std::string* mutable_x_c1();
  inline ::std::string* release_x_c1();
  inline void set_allocated_x_c1(::std::string* x_c1);

  // optional bytes y_c0 = 3;
  inline bool has_y_c0() const;
  inline void clear_y_c0();
  static const int kYC0FieldNumber = 3;
  inline const ::std::string& y_c0() const;
  inline void set_y_c0(const ::std::string& value);
  inline void set_y_c0(const char* value);
  inline void set_y_c0(const void* value, size_t size);
  inline ::std::string* mutable_y_c0();
  inline ::std::string* release_y_c0();
  inline void set_allocated_y_c0(::std::string* y_c0);

  // optional bytes y_c1 = 4;
  inline bool has_y_c1() const;
  inline void clear_y_c1();
  static const int kYC1FieldNumber = 4;
  inline const ::std::string& y_c1() const;
  inline void set_y_c1(const ::std::string& value);
  inline void set_y_c1(const char* value);
  inline void set_y_c1(const void* value, size_t size);
  inline ::std::string* mutable_y_c1();
  inline ::std::string* release_y_c1();
  inline void set_allocated_y_c1(::std::string* y_c1);

  // optional bytes z_c0 = 5;
  inline bool has_z_c0() const;
  inline void clear_z_c0();
  static const int kZC0FieldNumber = 5;
  inline const ::std::string& z_c0() const;
  inline void set_z_c0(const ::std::string& value);
  inline void set_z_c0(const char* value);
  inline void set_z_c0(const void* value, size_t size);
  inline ::std::string* mutable_z_c0();
  inline ::std::string* release_z_c0();
  inline void set_allocated_z_c0(::std::string* z_c0);

  // optional bytes z_c1 = 6;
  inline bool has_z_c1() const;
  inline void clear_z_c1();
  static const int kZC1FieldNumber = 6;
  inline const ::std::string& z_c1() const;
  inline void set_z_c1(const ::std::string& value);
  inline void set_z_c1(const char* value);
  inline void set_z_c1(const void* value, size_t size);
  inline ::std::string* mutable_z_c1();
  inline ::std::string* release_z_c1();
  inline void set_allocated_z_c1(::std::string* z_c1);

  // @@protoc_insertion_point(class_scope:zjchain.bls.protobuf.VerifyVecItem)
 private:
  inline void set_has_x_c0();
  inline void clear_has_x_c0();
  inline void set_has_x_c1();
  inline void clear_has_x_c1();
  inline void set_has_y_c0();
  inline void clear_has_y_c0();
  inline void set_has_y_c1();
  inline void clear_has_y_c1();
  inline void set_has_z_c0();
  inline void clear_has_z_c0();
  inline void set_has_z_c1();
  inline void clear_has_z_c1();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* x_c0_;
  ::std::string* x_c1_;
  ::std::string* y_c0_;
  ::std::string* y_c1_;
  ::std::string* z_c0_;
  ::std::string* z_c1_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fbls_2eproto();
  friend void protobuf_AssignDesc_protos_2fbls_2eproto();
  friend void protobuf_ShutdownFile_protos_2fbls_2eproto();

  void InitAsDefaultInstance();
  static VerifyVecItem* default_instance_;
};
// -------------------------------------------------------------------

class BlsPublicKey : public ::google::protobuf::Message {
 public:
  BlsPublicKey();
  virtual ~BlsPublicKey();

  BlsPublicKey(const BlsPublicKey& from);

  inline BlsPublicKey& operator=(const BlsPublicKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlsPublicKey& default_instance();

  void Swap(BlsPublicKey* other);

  // implements Message ----------------------------------------------

  BlsPublicKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlsPublicKey& from);
  void MergeFrom(const BlsPublicKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes x_c0 = 1;
  inline bool has_x_c0() const;
  inline void clear_x_c0();
  static const int kXC0FieldNumber = 1;
  inline const ::std::string& x_c0() const;
  inline void set_x_c0(const ::std::string& value);
  inline void set_x_c0(const char* value);
  inline void set_x_c0(const void* value, size_t size);
  inline ::std::string* mutable_x_c0();
  inline ::std::string* release_x_c0();
  inline void set_allocated_x_c0(::std::string* x_c0);

  // optional bytes x_c1 = 2;
  inline bool has_x_c1() const;
  inline void clear_x_c1();
  static const int kXC1FieldNumber = 2;
  inline const ::std::string& x_c1() const;
  inline void set_x_c1(const ::std::string& value);
  inline void set_x_c1(const char* value);
  inline void set_x_c1(const void* value, size_t size);
  inline ::std::string* mutable_x_c1();
  inline ::std::string* release_x_c1();
  inline void set_allocated_x_c1(::std::string* x_c1);

  // optional bytes y_c0 = 3;
  inline bool has_y_c0() const;
  inline void clear_y_c0();
  static const int kYC0FieldNumber = 3;
  inline const ::std::string& y_c0() const;
  inline void set_y_c0(const ::std::string& value);
  inline void set_y_c0(const char* value);
  inline void set_y_c0(const void* value, size_t size);
  inline ::std::string* mutable_y_c0();
  inline ::std::string* release_y_c0();
  inline void set_allocated_y_c0(::std::string* y_c0);

  // optional bytes y_c1 = 4;
  inline bool has_y_c1() const;
  inline void clear_y_c1();
  static const int kYC1FieldNumber = 4;
  inline const ::std::string& y_c1() const;
  inline void set_y_c1(const ::std::string& value);
  inline void set_y_c1(const char* value);
  inline void set_y_c1(const void* value, size_t size);
  inline ::std::string* mutable_y_c1();
  inline ::std::string* release_y_c1();
  inline void set_allocated_y_c1(::std::string* y_c1);

  // @@protoc_insertion_point(class_scope:zjchain.bls.protobuf.BlsPublicKey)
 private:
  inline void set_has_x_c0();
  inline void clear_has_x_c0();
  inline void set_has_x_c1();
  inline void clear_has_x_c1();
  inline void set_has_y_c0();
  inline void clear_has_y_c0();
  inline void set_has_y_c1();
  inline void clear_has_y_c1();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* x_c0_;
  ::std::string* x_c1_;
  ::std::string* y_c0_;
  ::std::string* y_c1_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fbls_2eproto();
  friend void protobuf_AssignDesc_protos_2fbls_2eproto();
  friend void protobuf_ShutdownFile_protos_2fbls_2eproto();

  void InitAsDefaultInstance();
  static BlsPublicKey* default_instance_;
};
// -------------------------------------------------------------------

class VerifyVecBrdReq : public ::google::protobuf::Message {
 public:
  VerifyVecBrdReq();
  virtual ~VerifyVecBrdReq();

  VerifyVecBrdReq(const VerifyVecBrdReq& from);

  inline VerifyVecBrdReq& operator=(const VerifyVecBrdReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VerifyVecBrdReq& default_instance();

  void Swap(VerifyVecBrdReq* other);

  // implements Message ----------------------------------------------

  VerifyVecBrdReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VerifyVecBrdReq& from);
  void MergeFrom(const VerifyVecBrdReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zjchain.bls.protobuf.VerifyVecItem verify_vec = 1;
  inline int verify_vec_size() const;
  inline void clear_verify_vec();
  static const int kVerifyVecFieldNumber = 1;
  inline const ::zjchain::bls::protobuf::VerifyVecItem& verify_vec(int index) const;
  inline ::zjchain::bls::protobuf::VerifyVecItem* mutable_verify_vec(int index);
  inline ::zjchain::bls::protobuf::VerifyVecItem* add_verify_vec();
  inline const ::google::protobuf::RepeatedPtrField< ::zjchain::bls::protobuf::VerifyVecItem >&
      verify_vec() const;
  inline ::google::protobuf::RepeatedPtrField< ::zjchain::bls::protobuf::VerifyVecItem >*
      mutable_verify_vec();

  // optional uint32 change_idx = 2;
  inline bool has_change_idx() const;
  inline void clear_change_idx();
  static const int kChangeIdxFieldNumber = 2;
  inline ::google::protobuf::uint32 change_idx() const;
  inline void set_change_idx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zjchain.bls.protobuf.VerifyVecBrdReq)
 private:
  inline void set_has_change_idx();
  inline void clear_has_change_idx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::zjchain::bls::protobuf::VerifyVecItem > verify_vec_;
  ::google::protobuf::uint32 change_idx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fbls_2eproto();
  friend void protobuf_AssignDesc_protos_2fbls_2eproto();
  friend void protobuf_ShutdownFile_protos_2fbls_2eproto();

  void InitAsDefaultInstance();
  static VerifyVecBrdReq* default_instance_;
};
// -------------------------------------------------------------------

class JoinElectBlsInfo : public ::google::protobuf::Message {
 public:
  JoinElectBlsInfo();
  virtual ~JoinElectBlsInfo();

  JoinElectBlsInfo(const JoinElectBlsInfo& from);

  inline JoinElectBlsInfo& operator=(const JoinElectBlsInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinElectBlsInfo& default_instance();

  void Swap(JoinElectBlsInfo* other);

  // implements Message ----------------------------------------------

  JoinElectBlsInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JoinElectBlsInfo& from);
  void MergeFrom(const JoinElectBlsInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .zjchain.bls.protobuf.VerifyVecItem verified_g2 = 1;
  inline bool has_verified_g2() const;
  inline void clear_verified_g2();
  static const int kVerifiedG2FieldNumber = 1;
  inline const ::zjchain::bls::protobuf::VerifyVecItem& verified_g2() const;
  inline ::zjchain::bls::protobuf::VerifyVecItem* mutable_verified_g2();
  inline ::zjchain::bls::protobuf::VerifyVecItem* release_verified_g2();
  inline void set_allocated_verified_g2(::zjchain::bls::protobuf::VerifyVecItem* verified_g2);

  // @@protoc_insertion_point(class_scope:zjchain.bls.protobuf.JoinElectBlsInfo)
 private:
  inline void set_has_verified_g2();
  inline void clear_has_verified_g2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::zjchain::bls::protobuf::VerifyVecItem* verified_g2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fbls_2eproto();
  friend void protobuf_AssignDesc_protos_2fbls_2eproto();
  friend void protobuf_ShutdownFile_protos_2fbls_2eproto();

  void InitAsDefaultInstance();
  static JoinElectBlsInfo* default_instance_;
};
// -------------------------------------------------------------------

class JoinElectInfo : public ::google::protobuf::Message {
 public:
  JoinElectInfo();
  virtual ~JoinElectInfo();

  JoinElectInfo(const JoinElectInfo& from);

  inline JoinElectInfo& operator=(const JoinElectInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinElectInfo& default_instance();

  void Swap(JoinElectInfo* other);

  // implements Message ----------------------------------------------

  JoinElectInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JoinElectInfo& from);
  void MergeFrom(const JoinElectInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 shard_id = 1;
  inline bool has_shard_id() const;
  inline void clear_shard_id();
  static const int kShardIdFieldNumber = 1;
  inline ::google::protobuf::uint32 shard_id() const;
  inline void set_shard_id(::google::protobuf::uint32 value);

  // optional uint32 member_idx = 2;
  inline bool has_member_idx() const;
  inline void clear_member_idx();
  static const int kMemberIdxFieldNumber = 2;
  inline ::google::protobuf::uint32 member_idx() const;
  inline void set_member_idx(::google::protobuf::uint32 value);

  // optional uint32 change_idx = 3;
  inline bool has_change_idx() const;
  inline void clear_change_idx();
  static const int kChangeIdxFieldNumber = 3;
  inline ::google::protobuf::uint32 change_idx() const;
  inline void set_change_idx(::google::protobuf::uint32 value);

  // optional .zjchain.bls.protobuf.VerifyVecBrdReq g2_req = 4;
  inline bool has_g2_req() const;
  inline void clear_g2_req();
  static const int kG2ReqFieldNumber = 4;
  inline const ::zjchain::bls::protobuf::VerifyVecBrdReq& g2_req() const;
  inline ::zjchain::bls::protobuf::VerifyVecBrdReq* mutable_g2_req();
  inline ::zjchain::bls::protobuf::VerifyVecBrdReq* release_g2_req();
  inline void set_allocated_g2_req(::zjchain::bls::protobuf::VerifyVecBrdReq* g2_req);

  // @@protoc_insertion_point(class_scope:zjchain.bls.protobuf.JoinElectInfo)
 private:
  inline void set_has_shard_id();
  inline void clear_has_shard_id();
  inline void set_has_member_idx();
  inline void clear_has_member_idx();
  inline void set_has_change_idx();
  inline void clear_has_change_idx();
  inline void set_has_g2_req();
  inline void clear_has_g2_req();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 shard_id_;
  ::google::protobuf::uint32 member_idx_;
  ::zjchain::bls::protobuf::VerifyVecBrdReq* g2_req_;
  ::google::protobuf::uint32 change_idx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fbls_2eproto();
  friend void protobuf_AssignDesc_protos_2fbls_2eproto();
  friend void protobuf_ShutdownFile_protos_2fbls_2eproto();

  void InitAsDefaultInstance();
  static JoinElectInfo* default_instance_;
};
// -------------------------------------------------------------------

class LocalPolynomial : public ::google::protobuf::Message {
 public:
  LocalPolynomial();
  virtual ~LocalPolynomial();

  LocalPolynomial(const LocalPolynomial& from);

  inline LocalPolynomial& operator=(const LocalPolynomial& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalPolynomial& default_instance();

  void Swap(LocalPolynomial* other);

  // implements Message ----------------------------------------------

  LocalPolynomial* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalPolynomial& from);
  void MergeFrom(const LocalPolynomial& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes polynomial = 1;
  inline int polynomial_size() const;
  inline void clear_polynomial();
  static const int kPolynomialFieldNumber = 1;
  inline const ::std::string& polynomial(int index) const;
  inline ::std::string* mutable_polynomial(int index);
  inline void set_polynomial(int index, const ::std::string& value);
  inline void set_polynomial(int index, const char* value);
  inline void set_polynomial(int index, const void* value, size_t size);
  inline ::std::string* add_polynomial();
  inline void add_polynomial(const ::std::string& value);
  inline void add_polynomial(const char* value);
  inline void add_polynomial(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& polynomial() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_polynomial();

  // optional uint32 change_idx = 2 [default = 0];
  inline bool has_change_idx() const;
  inline void clear_change_idx();
  static const int kChangeIdxFieldNumber = 2;
  inline ::google::protobuf::uint32 change_idx() const;
  inline void set_change_idx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zjchain.bls.protobuf.LocalPolynomial)
 private:
  inline void set_has_change_idx();
  inline void clear_has_change_idx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> polynomial_;
  ::google::protobuf::uint32 change_idx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fbls_2eproto();
  friend void protobuf_AssignDesc_protos_2fbls_2eproto();
  friend void protobuf_ShutdownFile_protos_2fbls_2eproto();

  void InitAsDefaultInstance();
  static LocalPolynomial* default_instance_;
};
// -------------------------------------------------------------------

class LocalBlsItem : public ::google::protobuf::Message {
 public:
  LocalBlsItem();
  virtual ~LocalBlsItem();

  LocalBlsItem(const LocalBlsItem& from);

  inline LocalBlsItem& operator=(const LocalBlsItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalBlsItem& default_instance();

  void Swap(LocalBlsItem* other);

  // implements Message ----------------------------------------------

  LocalBlsItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalBlsItem& from);
  void MergeFrom(const LocalBlsItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes polynomial = 1;
  inline int polynomial_size() const;
  inline void clear_polynomial();
  static const int kPolynomialFieldNumber = 1;
  inline const ::std::string& polynomial(int index) const;
  inline ::std::string* mutable_polynomial(int index);
  inline void set_polynomial(int index, const ::std::string& value);
  inline void set_polynomial(int index, const char* value);
  inline void set_polynomial(int index, const void* value, size_t size);
  inline ::std::string* add_polynomial();
  inline void add_polynomial(const ::std::string& value);
  inline void add_polynomial(const char* value);
  inline void add_polynomial(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& polynomial() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_polynomial();

  // repeated .zjchain.bls.protobuf.VerifyVecItem verify_vec = 2;
  inline int verify_vec_size() const;
  inline void clear_verify_vec();
  static const int kVerifyVecFieldNumber = 2;
  inline const ::zjchain::bls::protobuf::VerifyVecItem& verify_vec(int index) const;
  inline ::zjchain::bls::protobuf::VerifyVecItem* mutable_verify_vec(int index);
  inline ::zjchain::bls::protobuf::VerifyVecItem* add_verify_vec();
  inline const ::google::protobuf::RepeatedPtrField< ::zjchain::bls::protobuf::VerifyVecItem >&
      verify_vec() const;
  inline ::google::protobuf::RepeatedPtrField< ::zjchain::bls::protobuf::VerifyVecItem >*
      mutable_verify_vec();

  // optional uint32 valid_t = 3;
  inline bool has_valid_t() const;
  inline void clear_valid_t();
  static const int kValidTFieldNumber = 3;
  inline ::google::protobuf::uint32 valid_t() const;
  inline void set_valid_t(::google::protobuf::uint32 value);

  // optional uint32 valid_n = 4;
  inline bool has_valid_n() const;
  inline void clear_valid_n();
  static const int kValidNFieldNumber = 4;
  inline ::google::protobuf::uint32 valid_n() const;
  inline void set_valid_n(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zjchain.bls.protobuf.LocalBlsItem)
 private:
  inline void set_has_valid_t();
  inline void clear_has_valid_t();
  inline void set_has_valid_n();
  inline void clear_has_valid_n();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> polynomial_;
  ::google::protobuf::RepeatedPtrField< ::zjchain::bls::protobuf::VerifyVecItem > verify_vec_;
  ::google::protobuf::uint32 valid_t_;
  ::google::protobuf::uint32 valid_n_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fbls_2eproto();
  friend void protobuf_AssignDesc_protos_2fbls_2eproto();
  friend void protobuf_ShutdownFile_protos_2fbls_2eproto();

  void InitAsDefaultInstance();
  static LocalBlsItem* default_instance_;
};
// -------------------------------------------------------------------

class BlsVerifyValue : public ::google::protobuf::Message {
 public:
  BlsVerifyValue();
  virtual ~BlsVerifyValue();

  BlsVerifyValue(const BlsVerifyValue& from);

  inline BlsVerifyValue& operator=(const BlsVerifyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlsVerifyValue& default_instance();

  void Swap(BlsVerifyValue* other);

  // implements Message ----------------------------------------------

  BlsVerifyValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlsVerifyValue& from);
  void MergeFrom(const BlsVerifyValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zjchain.bls.protobuf.VerifyVecItem verify_vec = 1;
  inline int verify_vec_size() const;
  inline void clear_verify_vec();
  static const int kVerifyVecFieldNumber = 1;
  inline const ::zjchain::bls::protobuf::VerifyVecItem& verify_vec(int index) const;
  inline ::zjchain::bls::protobuf::VerifyVecItem* mutable_verify_vec(int index);
  inline ::zjchain::bls::protobuf::VerifyVecItem* add_verify_vec();
  inline const ::google::protobuf::RepeatedPtrField< ::zjchain::bls::protobuf::VerifyVecItem >&
      verify_vec() const;
  inline ::google::protobuf::RepeatedPtrField< ::zjchain::bls::protobuf::VerifyVecItem >*
      mutable_verify_vec();

  // @@protoc_insertion_point(class_scope:zjchain.bls.protobuf.BlsVerifyValue)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::zjchain::bls::protobuf::VerifyVecItem > verify_vec_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fbls_2eproto();
  friend void protobuf_AssignDesc_protos_2fbls_2eproto();
  friend void protobuf_ShutdownFile_protos_2fbls_2eproto();

  void InitAsDefaultInstance();
  static BlsVerifyValue* default_instance_;
};
// -------------------------------------------------------------------

class VerifyVecBrdRes : public ::google::protobuf::Message {
 public:
  VerifyVecBrdRes();
  virtual ~VerifyVecBrdRes();

  VerifyVecBrdRes(const VerifyVecBrdRes& from);

  inline VerifyVecBrdRes& operator=(const VerifyVecBrdRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VerifyVecBrdRes& default_instance();

  void Swap(VerifyVecBrdRes* other);

  // implements Message ----------------------------------------------

  VerifyVecBrdRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VerifyVecBrdRes& from);
  void MergeFrom(const VerifyVecBrdRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes public_ip = 1;
  inline bool has_public_ip() const;
  inline void clear_public_ip();
  static const int kPublicIpFieldNumber = 1;
  inline const ::std::string& public_ip() const;
  inline void set_public_ip(const ::std::string& value);
  inline void set_public_ip(const char* value);
  inline void set_public_ip(const void* value, size_t size);
  inline ::std::string* mutable_public_ip();
  inline ::std::string* release_public_ip();
  inline void set_allocated_public_ip(::std::string* public_ip);

  // optional uint32 public_port = 2;
  inline bool has_public_port() const;
  inline void clear_public_port();
  static const int kPublicPortFieldNumber = 2;
  inline ::google::protobuf::uint32 public_port() const;
  inline void set_public_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zjchain.bls.protobuf.VerifyVecBrdRes)
 private:
  inline void set_has_public_ip();
  inline void clear_has_public_ip();
  inline void set_has_public_port();
  inline void clear_has_public_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* public_ip_;
  ::google::protobuf::uint32 public_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fbls_2eproto();
  friend void protobuf_AssignDesc_protos_2fbls_2eproto();
  friend void protobuf_ShutdownFile_protos_2fbls_2eproto();

  void InitAsDefaultInstance();
  static VerifyVecBrdRes* default_instance_;
};
// -------------------------------------------------------------------

class SwapSecKeyItem : public ::google::protobuf::Message {
 public:
  SwapSecKeyItem();
  virtual ~SwapSecKeyItem();

  SwapSecKeyItem(const SwapSecKeyItem& from);

  inline SwapSecKeyItem& operator=(const SwapSecKeyItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwapSecKeyItem& default_instance();

  void Swap(SwapSecKeyItem* other);

  // implements Message ----------------------------------------------

  SwapSecKeyItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwapSecKeyItem& from);
  void MergeFrom(const SwapSecKeyItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes sec_key = 1;
  inline bool has_sec_key() const;
  inline void clear_sec_key();
  static const int kSecKeyFieldNumber = 1;
  inline const ::std::string& sec_key() const;
  inline void set_sec_key(const ::std::string& value);
  inline void set_sec_key(const char* value);
  inline void set_sec_key(const void* value, size_t size);
  inline ::std::string* mutable_sec_key();
  inline ::std::string* release_sec_key();
  inline void set_allocated_sec_key(::std::string* sec_key);

  // optional uint32 sec_key_len = 2;
  inline bool has_sec_key_len() const;
  inline void clear_sec_key_len();
  static const int kSecKeyLenFieldNumber = 2;
  inline ::google::protobuf::uint32 sec_key_len() const;
  inline void set_sec_key_len(::google::protobuf::uint32 value);

  // optional .zjchain.bls.protobuf.BlsPublicKey old_g2 = 3;
  inline bool has_old_g2() const;
  inline void clear_old_g2();
  static const int kOldG2FieldNumber = 3;
  inline const ::zjchain::bls::protobuf::BlsPublicKey& old_g2() const;
  inline ::zjchain::bls::protobuf::BlsPublicKey* mutable_old_g2();
  inline ::zjchain::bls::protobuf::BlsPublicKey* release_old_g2();
  inline void set_allocated_old_g2(::zjchain::bls::protobuf::BlsPublicKey* old_g2);

  // @@protoc_insertion_point(class_scope:zjchain.bls.protobuf.SwapSecKeyItem)
 private:
  inline void set_has_sec_key();
  inline void clear_has_sec_key();
  inline void set_has_sec_key_len();
  inline void clear_has_sec_key_len();
  inline void set_has_old_g2();
  inline void clear_has_old_g2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sec_key_;
  ::zjchain::bls::protobuf::BlsPublicKey* old_g2_;
  ::google::protobuf::uint32 sec_key_len_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fbls_2eproto();
  friend void protobuf_AssignDesc_protos_2fbls_2eproto();
  friend void protobuf_ShutdownFile_protos_2fbls_2eproto();

  void InitAsDefaultInstance();
  static SwapSecKeyItem* default_instance_;
};
// -------------------------------------------------------------------

class SwapSecKeyReq : public ::google::protobuf::Message {
 public:
  SwapSecKeyReq();
  virtual ~SwapSecKeyReq();

  SwapSecKeyReq(const SwapSecKeyReq& from);

  inline SwapSecKeyReq& operator=(const SwapSecKeyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwapSecKeyReq& default_instance();

  void Swap(SwapSecKeyReq* other);

  // implements Message ----------------------------------------------

  SwapSecKeyReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwapSecKeyReq& from);
  void MergeFrom(const SwapSecKeyReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zjchain.bls.protobuf.SwapSecKeyItem keys = 1;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 1;
  inline const ::zjchain::bls::protobuf::SwapSecKeyItem& keys(int index) const;
  inline ::zjchain::bls::protobuf::SwapSecKeyItem* mutable_keys(int index);
  inline ::zjchain::bls::protobuf::SwapSecKeyItem* add_keys();
  inline const ::google::protobuf::RepeatedPtrField< ::zjchain::bls::protobuf::SwapSecKeyItem >&
      keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::zjchain::bls::protobuf::SwapSecKeyItem >*
      mutable_keys();

  // @@protoc_insertion_point(class_scope:zjchain.bls.protobuf.SwapSecKeyReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::zjchain::bls::protobuf::SwapSecKeyItem > keys_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fbls_2eproto();
  friend void protobuf_AssignDesc_protos_2fbls_2eproto();
  friend void protobuf_ShutdownFile_protos_2fbls_2eproto();

  void InitAsDefaultInstance();
  static SwapSecKeyReq* default_instance_;
};
// -------------------------------------------------------------------

class SwapSecKeyRes : public ::google::protobuf::Message {
 public:
  SwapSecKeyRes();
  virtual ~SwapSecKeyRes();

  SwapSecKeyRes(const SwapSecKeyRes& from);

  inline SwapSecKeyRes& operator=(const SwapSecKeyRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwapSecKeyRes& default_instance();

  void Swap(SwapSecKeyRes* other);

  // implements Message ----------------------------------------------

  SwapSecKeyRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwapSecKeyRes& from);
  void MergeFrom(const SwapSecKeyRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional bytes sec_key = 2;
  inline bool has_sec_key() const;
  inline void clear_sec_key();
  static const int kSecKeyFieldNumber = 2;
  inline const ::std::string& sec_key() const;
  inline void set_sec_key(const ::std::string& value);
  inline void set_sec_key(const char* value);
  inline void set_sec_key(const void* value, size_t size);
  inline ::std::string* mutable_sec_key();
  inline ::std::string* release_sec_key();
  inline void set_allocated_sec_key(::std::string* sec_key);

  // optional uint32 sec_key_len = 3;
  inline bool has_sec_key_len() const;
  inline void clear_sec_key_len();
  static const int kSecKeyLenFieldNumber = 3;
  inline ::google::protobuf::uint32 sec_key_len() const;
  inline void set_sec_key_len(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zjchain.bls.protobuf.SwapSecKeyRes)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_sec_key();
  inline void clear_has_sec_key();
  inline void set_has_sec_key_len();
  inline void clear_has_sec_key_len();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sec_key_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 sec_key_len_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fbls_2eproto();
  friend void protobuf_AssignDesc_protos_2fbls_2eproto();
  friend void protobuf_ShutdownFile_protos_2fbls_2eproto();

  void InitAsDefaultInstance();
  static SwapSecKeyRes* default_instance_;
};
// -------------------------------------------------------------------

class AgainstParticipant : public ::google::protobuf::Message {
 public:
  AgainstParticipant();
  virtual ~AgainstParticipant();

  AgainstParticipant(const AgainstParticipant& from);

  inline AgainstParticipant& operator=(const AgainstParticipant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AgainstParticipant& default_instance();

  void Swap(AgainstParticipant* other);

  // implements Message ----------------------------------------------

  AgainstParticipant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgainstParticipant& from);
  void MergeFrom(const AgainstParticipant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 against_index = 1;
  inline bool has_against_index() const;
  inline void clear_against_index();
  static const int kAgainstIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 against_index() const;
  inline void set_against_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zjchain.bls.protobuf.AgainstParticipant)
 private:
  inline void set_has_against_index();
  inline void clear_has_against_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 against_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fbls_2eproto();
  friend void protobuf_AssignDesc_protos_2fbls_2eproto();
  friend void protobuf_ShutdownFile_protos_2fbls_2eproto();

  void InitAsDefaultInstance();
  static AgainstParticipant* default_instance_;
};
// -------------------------------------------------------------------

class FinishBroadcast : public ::google::protobuf::Message {
 public:
  FinishBroadcast();
  virtual ~FinishBroadcast();

  FinishBroadcast(const FinishBroadcast& from);

  inline FinishBroadcast& operator=(const FinishBroadcast& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FinishBroadcast& default_instance();

  void Swap(FinishBroadcast* other);

  // implements Message ----------------------------------------------

  FinishBroadcast* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FinishBroadcast& from);
  void MergeFrom(const FinishBroadcast& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 bitmap = 1;
  inline int bitmap_size() const;
  inline void clear_bitmap();
  static const int kBitmapFieldNumber = 1;
  inline ::google::protobuf::uint64 bitmap(int index) const;
  inline void set_bitmap(int index, ::google::protobuf::uint64 value);
  inline void add_bitmap(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      bitmap() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_bitmap();

  // optional .zjchain.bls.protobuf.BlsPublicKey pubkey = 2;
  inline bool has_pubkey() const;
  inline void clear_pubkey();
  static const int kPubkeyFieldNumber = 2;
  inline const ::zjchain::bls::protobuf::BlsPublicKey& pubkey() const;
  inline ::zjchain::bls::protobuf::BlsPublicKey* mutable_pubkey();
  inline ::zjchain::bls::protobuf::BlsPublicKey* release_pubkey();
  inline void set_allocated_pubkey(::zjchain::bls::protobuf::BlsPublicKey* pubkey);

  // optional .zjchain.bls.protobuf.BlsPublicKey common_pubkey = 3;
  inline bool has_common_pubkey() const;
  inline void clear_common_pubkey();
  static const int kCommonPubkeyFieldNumber = 3;
  inline const ::zjchain::bls::protobuf::BlsPublicKey& common_pubkey() const;
  inline ::zjchain::bls::protobuf::BlsPublicKey* mutable_common_pubkey();
  inline ::zjchain::bls::protobuf::BlsPublicKey* release_common_pubkey();
  inline void set_allocated_common_pubkey(::zjchain::bls::protobuf::BlsPublicKey* common_pubkey);

  // optional uint32 network_id = 4;
  inline bool has_network_id() const;
  inline void clear_network_id();
  static const int kNetworkIdFieldNumber = 4;
  inline ::google::protobuf::uint32 network_id() const;
  inline void set_network_id(::google::protobuf::uint32 value);

  // optional bytes bls_sign_x = 5;
  inline bool has_bls_sign_x() const;
  inline void clear_bls_sign_x();
  static const int kBlsSignXFieldNumber = 5;
  inline const ::std::string& bls_sign_x() const;
  inline void set_bls_sign_x(const ::std::string& value);
  inline void set_bls_sign_x(const char* value);
  inline void set_bls_sign_x(const void* value, size_t size);
  inline ::std::string* mutable_bls_sign_x();
  inline ::std::string* release_bls_sign_x();
  inline void set_allocated_bls_sign_x(::std::string* bls_sign_x);

  // optional bytes bls_sign_y = 6;
  inline bool has_bls_sign_y() const;
  inline void clear_bls_sign_y();
  static const int kBlsSignYFieldNumber = 6;
  inline const ::std::string& bls_sign_y() const;
  inline void set_bls_sign_y(const ::std::string& value);
  inline void set_bls_sign_y(const char* value);
  inline void set_bls_sign_y(const void* value, size_t size);
  inline ::std::string* mutable_bls_sign_y();
  inline ::std::string* release_bls_sign_y();
  inline void set_allocated_bls_sign_y(::std::string* bls_sign_y);

  // @@protoc_insertion_point(class_scope:zjchain.bls.protobuf.FinishBroadcast)
 private:
  inline void set_has_pubkey();
  inline void clear_has_pubkey();
  inline void set_has_common_pubkey();
  inline void clear_has_common_pubkey();
  inline void set_has_network_id();
  inline void clear_has_network_id();
  inline void set_has_bls_sign_x();
  inline void clear_has_bls_sign_x();
  inline void set_has_bls_sign_y();
  inline void clear_has_bls_sign_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > bitmap_;
  ::zjchain::bls::protobuf::BlsPublicKey* pubkey_;
  ::zjchain::bls::protobuf::BlsPublicKey* common_pubkey_;
  ::std::string* bls_sign_x_;
  ::std::string* bls_sign_y_;
  ::google::protobuf::uint32 network_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fbls_2eproto();
  friend void protobuf_AssignDesc_protos_2fbls_2eproto();
  friend void protobuf_ShutdownFile_protos_2fbls_2eproto();

  void InitAsDefaultInstance();
  static FinishBroadcast* default_instance_;
};
// -------------------------------------------------------------------

class CheckVerfiyReq : public ::google::protobuf::Message {
 public:
  CheckVerfiyReq();
  virtual ~CheckVerfiyReq();

  CheckVerfiyReq(const CheckVerfiyReq& from);

  inline CheckVerfiyReq& operator=(const CheckVerfiyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckVerfiyReq& default_instance();

  void Swap(CheckVerfiyReq* other);

  // implements Message ----------------------------------------------

  CheckVerfiyReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckVerfiyReq& from);
  void MergeFrom(const CheckVerfiyReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zjchain.bls.protobuf.CheckVerfiyReq)
 private:
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fbls_2eproto();
  friend void protobuf_AssignDesc_protos_2fbls_2eproto();
  friend void protobuf_ShutdownFile_protos_2fbls_2eproto();

  void InitAsDefaultInstance();
  static CheckVerfiyReq* default_instance_;
};
// -------------------------------------------------------------------

class CheckSwapKeyReq : public ::google::protobuf::Message {
 public:
  CheckSwapKeyReq();
  virtual ~CheckSwapKeyReq();

  CheckSwapKeyReq(const CheckSwapKeyReq& from);

  inline CheckSwapKeyReq& operator=(const CheckSwapKeyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckSwapKeyReq& default_instance();

  void Swap(CheckSwapKeyReq* other);

  // implements Message ----------------------------------------------

  CheckSwapKeyReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckSwapKeyReq& from);
  void MergeFrom(const CheckSwapKeyReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zjchain.bls.protobuf.CheckSwapKeyReq)
 private:
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fbls_2eproto();
  friend void protobuf_AssignDesc_protos_2fbls_2eproto();
  friend void protobuf_ShutdownFile_protos_2fbls_2eproto();

  void InitAsDefaultInstance();
  static CheckSwapKeyReq* default_instance_;
};
// -------------------------------------------------------------------

class BlsMessage : public ::google::protobuf::Message {
 public:
  BlsMessage();
  virtual ~BlsMessage();

  BlsMessage(const BlsMessage& from);

  inline BlsMessage& operator=(const BlsMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlsMessage& default_instance();

  void Swap(BlsMessage* other);

  // implements Message ----------------------------------------------

  BlsMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlsMessage& from);
  void MergeFrom(const BlsMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .zjchain.bls.protobuf.VerifyVecBrdReq verify_brd = 1;
  inline bool has_verify_brd() const;
  inline void clear_verify_brd();
  static const int kVerifyBrdFieldNumber = 1;
  inline const ::zjchain::bls::protobuf::VerifyVecBrdReq& verify_brd() const;
  inline ::zjchain::bls::protobuf::VerifyVecBrdReq* mutable_verify_brd();
  inline ::zjchain::bls::protobuf::VerifyVecBrdReq* release_verify_brd();
  inline void set_allocated_verify_brd(::zjchain::bls::protobuf::VerifyVecBrdReq* verify_brd);

  // optional .zjchain.bls.protobuf.SwapSecKeyReq swap_req = 2;
  inline bool has_swap_req() const;
  inline void clear_swap_req();
  static const int kSwapReqFieldNumber = 2;
  inline const ::zjchain::bls::protobuf::SwapSecKeyReq& swap_req() const;
  inline ::zjchain::bls::protobuf::SwapSecKeyReq* mutable_swap_req();
  inline ::zjchain::bls::protobuf::SwapSecKeyReq* release_swap_req();
  inline void set_allocated_swap_req(::zjchain::bls::protobuf::SwapSecKeyReq* swap_req);

  // optional .zjchain.bls.protobuf.FinishBroadcast finish_req = 3;
  inline bool has_finish_req() const;
  inline void clear_finish_req();
  static const int kFinishReqFieldNumber = 3;
  inline const ::zjchain::bls::protobuf::FinishBroadcast& finish_req() const;
  inline ::zjchain::bls::protobuf::FinishBroadcast* mutable_finish_req();
  inline ::zjchain::bls::protobuf::FinishBroadcast* release_finish_req();
  inline void set_allocated_finish_req(::zjchain::bls::protobuf::FinishBroadcast* finish_req);

  // optional .zjchain.bls.protobuf.CheckVerfiyReq check_verify_req = 4;
  inline bool has_check_verify_req() const;
  inline void clear_check_verify_req();
  static const int kCheckVerifyReqFieldNumber = 4;
  inline const ::zjchain::bls::protobuf::CheckVerfiyReq& check_verify_req() const;
  inline ::zjchain::bls::protobuf::CheckVerfiyReq* mutable_check_verify_req();
  inline ::zjchain::bls::protobuf::CheckVerfiyReq* release_check_verify_req();
  inline void set_allocated_check_verify_req(::zjchain::bls::protobuf::CheckVerfiyReq* check_verify_req);

  // optional .zjchain.bls.protobuf.CheckSwapKeyReq check_swapkey_req = 5;
  inline bool has_check_swapkey_req() const;
  inline void clear_check_swapkey_req();
  static const int kCheckSwapkeyReqFieldNumber = 5;
  inline const ::zjchain::bls::protobuf::CheckSwapKeyReq& check_swapkey_req() const;
  inline ::zjchain::bls::protobuf::CheckSwapKeyReq* mutable_check_swapkey_req();
  inline ::zjchain::bls::protobuf::CheckSwapKeyReq* release_check_swapkey_req();
  inline void set_allocated_check_swapkey_req(::zjchain::bls::protobuf::CheckSwapKeyReq* check_swapkey_req);

  // optional uint32 index = 6;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 6;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint64 elect_height = 7;
  inline bool has_elect_height() const;
  inline void clear_elect_height();
  static const int kElectHeightFieldNumber = 7;
  inline ::google::protobuf::uint64 elect_height() const;
  inline void set_elect_height(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:zjchain.bls.protobuf.BlsMessage)
 private:
  inline void set_has_verify_brd();
  inline void clear_has_verify_brd();
  inline void set_has_swap_req();
  inline void clear_has_swap_req();
  inline void set_has_finish_req();
  inline void clear_has_finish_req();
  inline void set_has_check_verify_req();
  inline void clear_has_check_verify_req();
  inline void set_has_check_swapkey_req();
  inline void clear_has_check_swapkey_req();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_elect_height();
  inline void clear_has_elect_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::zjchain::bls::protobuf::VerifyVecBrdReq* verify_brd_;
  ::zjchain::bls::protobuf::SwapSecKeyReq* swap_req_;
  ::zjchain::bls::protobuf::FinishBroadcast* finish_req_;
  ::zjchain::bls::protobuf::CheckVerfiyReq* check_verify_req_;
  ::zjchain::bls::protobuf::CheckSwapKeyReq* check_swapkey_req_;
  ::google::protobuf::uint64 elect_height_;
  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fbls_2eproto();
  friend void protobuf_AssignDesc_protos_2fbls_2eproto();
  friend void protobuf_ShutdownFile_protos_2fbls_2eproto();

  void InitAsDefaultInstance();
  static BlsMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// VerifyVecItem

// optional bytes x_c0 = 1;
inline bool VerifyVecItem::has_x_c0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VerifyVecItem::set_has_x_c0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VerifyVecItem::clear_has_x_c0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VerifyVecItem::clear_x_c0() {
  if (x_c0_ != &::google::protobuf::internal::kEmptyString) {
    x_c0_->clear();
  }
  clear_has_x_c0();
}
inline const ::std::string& VerifyVecItem::x_c0() const {
  return *x_c0_;
}
inline void VerifyVecItem::set_x_c0(const ::std::string& value) {
  set_has_x_c0();
  if (x_c0_ == &::google::protobuf::internal::kEmptyString) {
    x_c0_ = new ::std::string;
  }
  x_c0_->assign(value);
}
inline void VerifyVecItem::set_x_c0(const char* value) {
  set_has_x_c0();
  if (x_c0_ == &::google::protobuf::internal::kEmptyString) {
    x_c0_ = new ::std::string;
  }
  x_c0_->assign(value);
}
inline void VerifyVecItem::set_x_c0(const void* value, size_t size) {
  set_has_x_c0();
  if (x_c0_ == &::google::protobuf::internal::kEmptyString) {
    x_c0_ = new ::std::string;
  }
  x_c0_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VerifyVecItem::mutable_x_c0() {
  set_has_x_c0();
  if (x_c0_ == &::google::protobuf::internal::kEmptyString) {
    x_c0_ = new ::std::string;
  }
  return x_c0_;
}
inline ::std::string* VerifyVecItem::release_x_c0() {
  clear_has_x_c0();
  if (x_c0_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = x_c0_;
    x_c0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VerifyVecItem::set_allocated_x_c0(::std::string* x_c0) {
  if (x_c0_ != &::google::protobuf::internal::kEmptyString) {
    delete x_c0_;
  }
  if (x_c0) {
    set_has_x_c0();
    x_c0_ = x_c0;
  } else {
    clear_has_x_c0();
    x_c0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes x_c1 = 2;
inline bool VerifyVecItem::has_x_c1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VerifyVecItem::set_has_x_c1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VerifyVecItem::clear_has_x_c1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VerifyVecItem::clear_x_c1() {
  if (x_c1_ != &::google::protobuf::internal::kEmptyString) {
    x_c1_->clear();
  }
  clear_has_x_c1();
}
inline const ::std::string& VerifyVecItem::x_c1() const {
  return *x_c1_;
}
inline void VerifyVecItem::set_x_c1(const ::std::string& value) {
  set_has_x_c1();
  if (x_c1_ == &::google::protobuf::internal::kEmptyString) {
    x_c1_ = new ::std::string;
  }
  x_c1_->assign(value);
}
inline void VerifyVecItem::set_x_c1(const char* value) {
  set_has_x_c1();
  if (x_c1_ == &::google::protobuf::internal::kEmptyString) {
    x_c1_ = new ::std::string;
  }
  x_c1_->assign(value);
}
inline void VerifyVecItem::set_x_c1(const void* value, size_t size) {
  set_has_x_c1();
  if (x_c1_ == &::google::protobuf::internal::kEmptyString) {
    x_c1_ = new ::std::string;
  }
  x_c1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VerifyVecItem::mutable_x_c1() {
  set_has_x_c1();
  if (x_c1_ == &::google::protobuf::internal::kEmptyString) {
    x_c1_ = new ::std::string;
  }
  return x_c1_;
}
inline ::std::string* VerifyVecItem::release_x_c1() {
  clear_has_x_c1();
  if (x_c1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = x_c1_;
    x_c1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VerifyVecItem::set_allocated_x_c1(::std::string* x_c1) {
  if (x_c1_ != &::google::protobuf::internal::kEmptyString) {
    delete x_c1_;
  }
  if (x_c1) {
    set_has_x_c1();
    x_c1_ = x_c1;
  } else {
    clear_has_x_c1();
    x_c1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes y_c0 = 3;
inline bool VerifyVecItem::has_y_c0() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VerifyVecItem::set_has_y_c0() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VerifyVecItem::clear_has_y_c0() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VerifyVecItem::clear_y_c0() {
  if (y_c0_ != &::google::protobuf::internal::kEmptyString) {
    y_c0_->clear();
  }
  clear_has_y_c0();
}
inline const ::std::string& VerifyVecItem::y_c0() const {
  return *y_c0_;
}
inline void VerifyVecItem::set_y_c0(const ::std::string& value) {
  set_has_y_c0();
  if (y_c0_ == &::google::protobuf::internal::kEmptyString) {
    y_c0_ = new ::std::string;
  }
  y_c0_->assign(value);
}
inline void VerifyVecItem::set_y_c0(const char* value) {
  set_has_y_c0();
  if (y_c0_ == &::google::protobuf::internal::kEmptyString) {
    y_c0_ = new ::std::string;
  }
  y_c0_->assign(value);
}
inline void VerifyVecItem::set_y_c0(const void* value, size_t size) {
  set_has_y_c0();
  if (y_c0_ == &::google::protobuf::internal::kEmptyString) {
    y_c0_ = new ::std::string;
  }
  y_c0_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VerifyVecItem::mutable_y_c0() {
  set_has_y_c0();
  if (y_c0_ == &::google::protobuf::internal::kEmptyString) {
    y_c0_ = new ::std::string;
  }
  return y_c0_;
}
inline ::std::string* VerifyVecItem::release_y_c0() {
  clear_has_y_c0();
  if (y_c0_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = y_c0_;
    y_c0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VerifyVecItem::set_allocated_y_c0(::std::string* y_c0) {
  if (y_c0_ != &::google::protobuf::internal::kEmptyString) {
    delete y_c0_;
  }
  if (y_c0) {
    set_has_y_c0();
    y_c0_ = y_c0;
  } else {
    clear_has_y_c0();
    y_c0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes y_c1 = 4;
inline bool VerifyVecItem::has_y_c1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VerifyVecItem::set_has_y_c1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VerifyVecItem::clear_has_y_c1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VerifyVecItem::clear_y_c1() {
  if (y_c1_ != &::google::protobuf::internal::kEmptyString) {
    y_c1_->clear();
  }
  clear_has_y_c1();
}
inline const ::std::string& VerifyVecItem::y_c1() const {
  return *y_c1_;
}
inline void VerifyVecItem::set_y_c1(const ::std::string& value) {
  set_has_y_c1();
  if (y_c1_ == &::google::protobuf::internal::kEmptyString) {
    y_c1_ = new ::std::string;
  }
  y_c1_->assign(value);
}
inline void VerifyVecItem::set_y_c1(const char* value) {
  set_has_y_c1();
  if (y_c1_ == &::google::protobuf::internal::kEmptyString) {
    y_c1_ = new ::std::string;
  }
  y_c1_->assign(value);
}
inline void VerifyVecItem::set_y_c1(const void* value, size_t size) {
  set_has_y_c1();
  if (y_c1_ == &::google::protobuf::internal::kEmptyString) {
    y_c1_ = new ::std::string;
  }
  y_c1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VerifyVecItem::mutable_y_c1() {
  set_has_y_c1();
  if (y_c1_ == &::google::protobuf::internal::kEmptyString) {
    y_c1_ = new ::std::string;
  }
  return y_c1_;
}
inline ::std::string* VerifyVecItem::release_y_c1() {
  clear_has_y_c1();
  if (y_c1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = y_c1_;
    y_c1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VerifyVecItem::set_allocated_y_c1(::std::string* y_c1) {
  if (y_c1_ != &::google::protobuf::internal::kEmptyString) {
    delete y_c1_;
  }
  if (y_c1) {
    set_has_y_c1();
    y_c1_ = y_c1;
  } else {
    clear_has_y_c1();
    y_c1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes z_c0 = 5;
inline bool VerifyVecItem::has_z_c0() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VerifyVecItem::set_has_z_c0() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VerifyVecItem::clear_has_z_c0() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VerifyVecItem::clear_z_c0() {
  if (z_c0_ != &::google::protobuf::internal::kEmptyString) {
    z_c0_->clear();
  }
  clear_has_z_c0();
}
inline const ::std::string& VerifyVecItem::z_c0() const {
  return *z_c0_;
}
inline void VerifyVecItem::set_z_c0(const ::std::string& value) {
  set_has_z_c0();
  if (z_c0_ == &::google::protobuf::internal::kEmptyString) {
    z_c0_ = new ::std::string;
  }
  z_c0_->assign(value);
}
inline void VerifyVecItem::set_z_c0(const char* value) {
  set_has_z_c0();
  if (z_c0_ == &::google::protobuf::internal::kEmptyString) {
    z_c0_ = new ::std::string;
  }
  z_c0_->assign(value);
}
inline void VerifyVecItem::set_z_c0(const void* value, size_t size) {
  set_has_z_c0();
  if (z_c0_ == &::google::protobuf::internal::kEmptyString) {
    z_c0_ = new ::std::string;
  }
  z_c0_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VerifyVecItem::mutable_z_c0() {
  set_has_z_c0();
  if (z_c0_ == &::google::protobuf::internal::kEmptyString) {
    z_c0_ = new ::std::string;
  }
  return z_c0_;
}
inline ::std::string* VerifyVecItem::release_z_c0() {
  clear_has_z_c0();
  if (z_c0_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = z_c0_;
    z_c0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VerifyVecItem::set_allocated_z_c0(::std::string* z_c0) {
  if (z_c0_ != &::google::protobuf::internal::kEmptyString) {
    delete z_c0_;
  }
  if (z_c0) {
    set_has_z_c0();
    z_c0_ = z_c0;
  } else {
    clear_has_z_c0();
    z_c0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes z_c1 = 6;
inline bool VerifyVecItem::has_z_c1() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VerifyVecItem::set_has_z_c1() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VerifyVecItem::clear_has_z_c1() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VerifyVecItem::clear_z_c1() {
  if (z_c1_ != &::google::protobuf::internal::kEmptyString) {
    z_c1_->clear();
  }
  clear_has_z_c1();
}
inline const ::std::string& VerifyVecItem::z_c1() const {
  return *z_c1_;
}
inline void VerifyVecItem::set_z_c1(const ::std::string& value) {
  set_has_z_c1();
  if (z_c1_ == &::google::protobuf::internal::kEmptyString) {
    z_c1_ = new ::std::string;
  }
  z_c1_->assign(value);
}
inline void VerifyVecItem::set_z_c1(const char* value) {
  set_has_z_c1();
  if (z_c1_ == &::google::protobuf::internal::kEmptyString) {
    z_c1_ = new ::std::string;
  }
  z_c1_->assign(value);
}
inline void VerifyVecItem::set_z_c1(const void* value, size_t size) {
  set_has_z_c1();
  if (z_c1_ == &::google::protobuf::internal::kEmptyString) {
    z_c1_ = new ::std::string;
  }
  z_c1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VerifyVecItem::mutable_z_c1() {
  set_has_z_c1();
  if (z_c1_ == &::google::protobuf::internal::kEmptyString) {
    z_c1_ = new ::std::string;
  }
  return z_c1_;
}
inline ::std::string* VerifyVecItem::release_z_c1() {
  clear_has_z_c1();
  if (z_c1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = z_c1_;
    z_c1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VerifyVecItem::set_allocated_z_c1(::std::string* z_c1) {
  if (z_c1_ != &::google::protobuf::internal::kEmptyString) {
    delete z_c1_;
  }
  if (z_c1) {
    set_has_z_c1();
    z_c1_ = z_c1;
  } else {
    clear_has_z_c1();
    z_c1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BlsPublicKey

// optional bytes x_c0 = 1;
inline bool BlsPublicKey::has_x_c0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlsPublicKey::set_has_x_c0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlsPublicKey::clear_has_x_c0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlsPublicKey::clear_x_c0() {
  if (x_c0_ != &::google::protobuf::internal::kEmptyString) {
    x_c0_->clear();
  }
  clear_has_x_c0();
}
inline const ::std::string& BlsPublicKey::x_c0() const {
  return *x_c0_;
}
inline void BlsPublicKey::set_x_c0(const ::std::string& value) {
  set_has_x_c0();
  if (x_c0_ == &::google::protobuf::internal::kEmptyString) {
    x_c0_ = new ::std::string;
  }
  x_c0_->assign(value);
}
inline void BlsPublicKey::set_x_c0(const char* value) {
  set_has_x_c0();
  if (x_c0_ == &::google::protobuf::internal::kEmptyString) {
    x_c0_ = new ::std::string;
  }
  x_c0_->assign(value);
}
inline void BlsPublicKey::set_x_c0(const void* value, size_t size) {
  set_has_x_c0();
  if (x_c0_ == &::google::protobuf::internal::kEmptyString) {
    x_c0_ = new ::std::string;
  }
  x_c0_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlsPublicKey::mutable_x_c0() {
  set_has_x_c0();
  if (x_c0_ == &::google::protobuf::internal::kEmptyString) {
    x_c0_ = new ::std::string;
  }
  return x_c0_;
}
inline ::std::string* BlsPublicKey::release_x_c0() {
  clear_has_x_c0();
  if (x_c0_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = x_c0_;
    x_c0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlsPublicKey::set_allocated_x_c0(::std::string* x_c0) {
  if (x_c0_ != &::google::protobuf::internal::kEmptyString) {
    delete x_c0_;
  }
  if (x_c0) {
    set_has_x_c0();
    x_c0_ = x_c0;
  } else {
    clear_has_x_c0();
    x_c0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes x_c1 = 2;
inline bool BlsPublicKey::has_x_c1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlsPublicKey::set_has_x_c1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlsPublicKey::clear_has_x_c1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlsPublicKey::clear_x_c1() {
  if (x_c1_ != &::google::protobuf::internal::kEmptyString) {
    x_c1_->clear();
  }
  clear_has_x_c1();
}
inline const ::std::string& BlsPublicKey::x_c1() const {
  return *x_c1_;
}
inline void BlsPublicKey::set_x_c1(const ::std::string& value) {
  set_has_x_c1();
  if (x_c1_ == &::google::protobuf::internal::kEmptyString) {
    x_c1_ = new ::std::string;
  }
  x_c1_->assign(value);
}
inline void BlsPublicKey::set_x_c1(const char* value) {
  set_has_x_c1();
  if (x_c1_ == &::google::protobuf::internal::kEmptyString) {
    x_c1_ = new ::std::string;
  }
  x_c1_->assign(value);
}
inline void BlsPublicKey::set_x_c1(const void* value, size_t size) {
  set_has_x_c1();
  if (x_c1_ == &::google::protobuf::internal::kEmptyString) {
    x_c1_ = new ::std::string;
  }
  x_c1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlsPublicKey::mutable_x_c1() {
  set_has_x_c1();
  if (x_c1_ == &::google::protobuf::internal::kEmptyString) {
    x_c1_ = new ::std::string;
  }
  return x_c1_;
}
inline ::std::string* BlsPublicKey::release_x_c1() {
  clear_has_x_c1();
  if (x_c1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = x_c1_;
    x_c1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlsPublicKey::set_allocated_x_c1(::std::string* x_c1) {
  if (x_c1_ != &::google::protobuf::internal::kEmptyString) {
    delete x_c1_;
  }
  if (x_c1) {
    set_has_x_c1();
    x_c1_ = x_c1;
  } else {
    clear_has_x_c1();
    x_c1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes y_c0 = 3;
inline bool BlsPublicKey::has_y_c0() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlsPublicKey::set_has_y_c0() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlsPublicKey::clear_has_y_c0() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlsPublicKey::clear_y_c0() {
  if (y_c0_ != &::google::protobuf::internal::kEmptyString) {
    y_c0_->clear();
  }
  clear_has_y_c0();
}
inline const ::std::string& BlsPublicKey::y_c0() const {
  return *y_c0_;
}
inline void BlsPublicKey::set_y_c0(const ::std::string& value) {
  set_has_y_c0();
  if (y_c0_ == &::google::protobuf::internal::kEmptyString) {
    y_c0_ = new ::std::string;
  }
  y_c0_->assign(value);
}
inline void BlsPublicKey::set_y_c0(const char* value) {
  set_has_y_c0();
  if (y_c0_ == &::google::protobuf::internal::kEmptyString) {
    y_c0_ = new ::std::string;
  }
  y_c0_->assign(value);
}
inline void BlsPublicKey::set_y_c0(const void* value, size_t size) {
  set_has_y_c0();
  if (y_c0_ == &::google::protobuf::internal::kEmptyString) {
    y_c0_ = new ::std::string;
  }
  y_c0_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlsPublicKey::mutable_y_c0() {
  set_has_y_c0();
  if (y_c0_ == &::google::protobuf::internal::kEmptyString) {
    y_c0_ = new ::std::string;
  }
  return y_c0_;
}
inline ::std::string* BlsPublicKey::release_y_c0() {
  clear_has_y_c0();
  if (y_c0_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = y_c0_;
    y_c0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlsPublicKey::set_allocated_y_c0(::std::string* y_c0) {
  if (y_c0_ != &::google::protobuf::internal::kEmptyString) {
    delete y_c0_;
  }
  if (y_c0) {
    set_has_y_c0();
    y_c0_ = y_c0;
  } else {
    clear_has_y_c0();
    y_c0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes y_c1 = 4;
inline bool BlsPublicKey::has_y_c1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlsPublicKey::set_has_y_c1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlsPublicKey::clear_has_y_c1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlsPublicKey::clear_y_c1() {
  if (y_c1_ != &::google::protobuf::internal::kEmptyString) {
    y_c1_->clear();
  }
  clear_has_y_c1();
}
inline const ::std::string& BlsPublicKey::y_c1() const {
  return *y_c1_;
}
inline void BlsPublicKey::set_y_c1(const ::std::string& value) {
  set_has_y_c1();
  if (y_c1_ == &::google::protobuf::internal::kEmptyString) {
    y_c1_ = new ::std::string;
  }
  y_c1_->assign(value);
}
inline void BlsPublicKey::set_y_c1(const char* value) {
  set_has_y_c1();
  if (y_c1_ == &::google::protobuf::internal::kEmptyString) {
    y_c1_ = new ::std::string;
  }
  y_c1_->assign(value);
}
inline void BlsPublicKey::set_y_c1(const void* value, size_t size) {
  set_has_y_c1();
  if (y_c1_ == &::google::protobuf::internal::kEmptyString) {
    y_c1_ = new ::std::string;
  }
  y_c1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlsPublicKey::mutable_y_c1() {
  set_has_y_c1();
  if (y_c1_ == &::google::protobuf::internal::kEmptyString) {
    y_c1_ = new ::std::string;
  }
  return y_c1_;
}
inline ::std::string* BlsPublicKey::release_y_c1() {
  clear_has_y_c1();
  if (y_c1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = y_c1_;
    y_c1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlsPublicKey::set_allocated_y_c1(::std::string* y_c1) {
  if (y_c1_ != &::google::protobuf::internal::kEmptyString) {
    delete y_c1_;
  }
  if (y_c1) {
    set_has_y_c1();
    y_c1_ = y_c1;
  } else {
    clear_has_y_c1();
    y_c1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// VerifyVecBrdReq

// repeated .zjchain.bls.protobuf.VerifyVecItem verify_vec = 1;
inline int VerifyVecBrdReq::verify_vec_size() const {
  return verify_vec_.size();
}
inline void VerifyVecBrdReq::clear_verify_vec() {
  verify_vec_.Clear();
}
inline const ::zjchain::bls::protobuf::VerifyVecItem& VerifyVecBrdReq::verify_vec(int index) const {
  return verify_vec_.Get(index);
}
inline ::zjchain::bls::protobuf::VerifyVecItem* VerifyVecBrdReq::mutable_verify_vec(int index) {
  return verify_vec_.Mutable(index);
}
inline ::zjchain::bls::protobuf::VerifyVecItem* VerifyVecBrdReq::add_verify_vec() {
  return verify_vec_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zjchain::bls::protobuf::VerifyVecItem >&
VerifyVecBrdReq::verify_vec() const {
  return verify_vec_;
}
inline ::google::protobuf::RepeatedPtrField< ::zjchain::bls::protobuf::VerifyVecItem >*
VerifyVecBrdReq::mutable_verify_vec() {
  return &verify_vec_;
}

// optional uint32 change_idx = 2;
inline bool VerifyVecBrdReq::has_change_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VerifyVecBrdReq::set_has_change_idx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VerifyVecBrdReq::clear_has_change_idx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VerifyVecBrdReq::clear_change_idx() {
  change_idx_ = 0u;
  clear_has_change_idx();
}
inline ::google::protobuf::uint32 VerifyVecBrdReq::change_idx() const {
  return change_idx_;
}
inline void VerifyVecBrdReq::set_change_idx(::google::protobuf::uint32 value) {
  set_has_change_idx();
  change_idx_ = value;
}

// -------------------------------------------------------------------

// JoinElectBlsInfo

// optional .zjchain.bls.protobuf.VerifyVecItem verified_g2 = 1;
inline bool JoinElectBlsInfo::has_verified_g2() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinElectBlsInfo::set_has_verified_g2() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinElectBlsInfo::clear_has_verified_g2() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinElectBlsInfo::clear_verified_g2() {
  if (verified_g2_ != NULL) verified_g2_->::zjchain::bls::protobuf::VerifyVecItem::Clear();
  clear_has_verified_g2();
}
inline const ::zjchain::bls::protobuf::VerifyVecItem& JoinElectBlsInfo::verified_g2() const {
  return verified_g2_ != NULL ? *verified_g2_ : *default_instance_->verified_g2_;
}
inline ::zjchain::bls::protobuf::VerifyVecItem* JoinElectBlsInfo::mutable_verified_g2() {
  set_has_verified_g2();
  if (verified_g2_ == NULL) verified_g2_ = new ::zjchain::bls::protobuf::VerifyVecItem;
  return verified_g2_;
}
inline ::zjchain::bls::protobuf::VerifyVecItem* JoinElectBlsInfo::release_verified_g2() {
  clear_has_verified_g2();
  ::zjchain::bls::protobuf::VerifyVecItem* temp = verified_g2_;
  verified_g2_ = NULL;
  return temp;
}
inline void JoinElectBlsInfo::set_allocated_verified_g2(::zjchain::bls::protobuf::VerifyVecItem* verified_g2) {
  delete verified_g2_;
  verified_g2_ = verified_g2;
  if (verified_g2) {
    set_has_verified_g2();
  } else {
    clear_has_verified_g2();
  }
}

// -------------------------------------------------------------------

// JoinElectInfo

// optional uint32 shard_id = 1;
inline bool JoinElectInfo::has_shard_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinElectInfo::set_has_shard_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinElectInfo::clear_has_shard_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinElectInfo::clear_shard_id() {
  shard_id_ = 0u;
  clear_has_shard_id();
}
inline ::google::protobuf::uint32 JoinElectInfo::shard_id() const {
  return shard_id_;
}
inline void JoinElectInfo::set_shard_id(::google::protobuf::uint32 value) {
  set_has_shard_id();
  shard_id_ = value;
}

// optional uint32 member_idx = 2;
inline bool JoinElectInfo::has_member_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinElectInfo::set_has_member_idx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinElectInfo::clear_has_member_idx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinElectInfo::clear_member_idx() {
  member_idx_ = 0u;
  clear_has_member_idx();
}
inline ::google::protobuf::uint32 JoinElectInfo::member_idx() const {
  return member_idx_;
}
inline void JoinElectInfo::set_member_idx(::google::protobuf::uint32 value) {
  set_has_member_idx();
  member_idx_ = value;
}

// optional uint32 change_idx = 3;
inline bool JoinElectInfo::has_change_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinElectInfo::set_has_change_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JoinElectInfo::clear_has_change_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JoinElectInfo::clear_change_idx() {
  change_idx_ = 0u;
  clear_has_change_idx();
}
inline ::google::protobuf::uint32 JoinElectInfo::change_idx() const {
  return change_idx_;
}
inline void JoinElectInfo::set_change_idx(::google::protobuf::uint32 value) {
  set_has_change_idx();
  change_idx_ = value;
}

// optional .zjchain.bls.protobuf.VerifyVecBrdReq g2_req = 4;
inline bool JoinElectInfo::has_g2_req() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JoinElectInfo::set_has_g2_req() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JoinElectInfo::clear_has_g2_req() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JoinElectInfo::clear_g2_req() {
  if (g2_req_ != NULL) g2_req_->::zjchain::bls::protobuf::VerifyVecBrdReq::Clear();
  clear_has_g2_req();
}
inline const ::zjchain::bls::protobuf::VerifyVecBrdReq& JoinElectInfo::g2_req() const {
  return g2_req_ != NULL ? *g2_req_ : *default_instance_->g2_req_;
}
inline ::zjchain::bls::protobuf::VerifyVecBrdReq* JoinElectInfo::mutable_g2_req() {
  set_has_g2_req();
  if (g2_req_ == NULL) g2_req_ = new ::zjchain::bls::protobuf::VerifyVecBrdReq;
  return g2_req_;
}
inline ::zjchain::bls::protobuf::VerifyVecBrdReq* JoinElectInfo::release_g2_req() {
  clear_has_g2_req();
  ::zjchain::bls::protobuf::VerifyVecBrdReq* temp = g2_req_;
  g2_req_ = NULL;
  return temp;
}
inline void JoinElectInfo::set_allocated_g2_req(::zjchain::bls::protobuf::VerifyVecBrdReq* g2_req) {
  delete g2_req_;
  g2_req_ = g2_req;
  if (g2_req) {
    set_has_g2_req();
  } else {
    clear_has_g2_req();
  }
}

// -------------------------------------------------------------------

// LocalPolynomial

// repeated bytes polynomial = 1;
inline int LocalPolynomial::polynomial_size() const {
  return polynomial_.size();
}
inline void LocalPolynomial::clear_polynomial() {
  polynomial_.Clear();
}
inline const ::std::string& LocalPolynomial::polynomial(int index) const {
  return polynomial_.Get(index);
}
inline ::std::string* LocalPolynomial::mutable_polynomial(int index) {
  return polynomial_.Mutable(index);
}
inline void LocalPolynomial::set_polynomial(int index, const ::std::string& value) {
  polynomial_.Mutable(index)->assign(value);
}
inline void LocalPolynomial::set_polynomial(int index, const char* value) {
  polynomial_.Mutable(index)->assign(value);
}
inline void LocalPolynomial::set_polynomial(int index, const void* value, size_t size) {
  polynomial_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalPolynomial::add_polynomial() {
  return polynomial_.Add();
}
inline void LocalPolynomial::add_polynomial(const ::std::string& value) {
  polynomial_.Add()->assign(value);
}
inline void LocalPolynomial::add_polynomial(const char* value) {
  polynomial_.Add()->assign(value);
}
inline void LocalPolynomial::add_polynomial(const void* value, size_t size) {
  polynomial_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LocalPolynomial::polynomial() const {
  return polynomial_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LocalPolynomial::mutable_polynomial() {
  return &polynomial_;
}

// optional uint32 change_idx = 2 [default = 0];
inline bool LocalPolynomial::has_change_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalPolynomial::set_has_change_idx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalPolynomial::clear_has_change_idx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocalPolynomial::clear_change_idx() {
  change_idx_ = 0u;
  clear_has_change_idx();
}
inline ::google::protobuf::uint32 LocalPolynomial::change_idx() const {
  return change_idx_;
}
inline void LocalPolynomial::set_change_idx(::google::protobuf::uint32 value) {
  set_has_change_idx();
  change_idx_ = value;
}

// -------------------------------------------------------------------

// LocalBlsItem

// repeated bytes polynomial = 1;
inline int LocalBlsItem::polynomial_size() const {
  return polynomial_.size();
}
inline void LocalBlsItem::clear_polynomial() {
  polynomial_.Clear();
}
inline const ::std::string& LocalBlsItem::polynomial(int index) const {
  return polynomial_.Get(index);
}
inline ::std::string* LocalBlsItem::mutable_polynomial(int index) {
  return polynomial_.Mutable(index);
}
inline void LocalBlsItem::set_polynomial(int index, const ::std::string& value) {
  polynomial_.Mutable(index)->assign(value);
}
inline void LocalBlsItem::set_polynomial(int index, const char* value) {
  polynomial_.Mutable(index)->assign(value);
}
inline void LocalBlsItem::set_polynomial(int index, const void* value, size_t size) {
  polynomial_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalBlsItem::add_polynomial() {
  return polynomial_.Add();
}
inline void LocalBlsItem::add_polynomial(const ::std::string& value) {
  polynomial_.Add()->assign(value);
}
inline void LocalBlsItem::add_polynomial(const char* value) {
  polynomial_.Add()->assign(value);
}
inline void LocalBlsItem::add_polynomial(const void* value, size_t size) {
  polynomial_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LocalBlsItem::polynomial() const {
  return polynomial_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LocalBlsItem::mutable_polynomial() {
  return &polynomial_;
}

// repeated .zjchain.bls.protobuf.VerifyVecItem verify_vec = 2;
inline int LocalBlsItem::verify_vec_size() const {
  return verify_vec_.size();
}
inline void LocalBlsItem::clear_verify_vec() {
  verify_vec_.Clear();
}
inline const ::zjchain::bls::protobuf::VerifyVecItem& LocalBlsItem::verify_vec(int index) const {
  return verify_vec_.Get(index);
}
inline ::zjchain::bls::protobuf::VerifyVecItem* LocalBlsItem::mutable_verify_vec(int index) {
  return verify_vec_.Mutable(index);
}
inline ::zjchain::bls::protobuf::VerifyVecItem* LocalBlsItem::add_verify_vec() {
  return verify_vec_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zjchain::bls::protobuf::VerifyVecItem >&
LocalBlsItem::verify_vec() const {
  return verify_vec_;
}
inline ::google::protobuf::RepeatedPtrField< ::zjchain::bls::protobuf::VerifyVecItem >*
LocalBlsItem::mutable_verify_vec() {
  return &verify_vec_;
}

// optional uint32 valid_t = 3;
inline bool LocalBlsItem::has_valid_t() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocalBlsItem::set_has_valid_t() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocalBlsItem::clear_has_valid_t() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocalBlsItem::clear_valid_t() {
  valid_t_ = 0u;
  clear_has_valid_t();
}
inline ::google::protobuf::uint32 LocalBlsItem::valid_t() const {
  return valid_t_;
}
inline void LocalBlsItem::set_valid_t(::google::protobuf::uint32 value) {
  set_has_valid_t();
  valid_t_ = value;
}

// optional uint32 valid_n = 4;
inline bool LocalBlsItem::has_valid_n() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocalBlsItem::set_has_valid_n() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocalBlsItem::clear_has_valid_n() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocalBlsItem::clear_valid_n() {
  valid_n_ = 0u;
  clear_has_valid_n();
}
inline ::google::protobuf::uint32 LocalBlsItem::valid_n() const {
  return valid_n_;
}
inline void LocalBlsItem::set_valid_n(::google::protobuf::uint32 value) {
  set_has_valid_n();
  valid_n_ = value;
}

// -------------------------------------------------------------------

// BlsVerifyValue

// repeated .zjchain.bls.protobuf.VerifyVecItem verify_vec = 1;
inline int BlsVerifyValue::verify_vec_size() const {
  return verify_vec_.size();
}
inline void BlsVerifyValue::clear_verify_vec() {
  verify_vec_.Clear();
}
inline const ::zjchain::bls::protobuf::VerifyVecItem& BlsVerifyValue::verify_vec(int index) const {
  return verify_vec_.Get(index);
}
inline ::zjchain::bls::protobuf::VerifyVecItem* BlsVerifyValue::mutable_verify_vec(int index) {
  return verify_vec_.Mutable(index);
}
inline ::zjchain::bls::protobuf::VerifyVecItem* BlsVerifyValue::add_verify_vec() {
  return verify_vec_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zjchain::bls::protobuf::VerifyVecItem >&
BlsVerifyValue::verify_vec() const {
  return verify_vec_;
}
inline ::google::protobuf::RepeatedPtrField< ::zjchain::bls::protobuf::VerifyVecItem >*
BlsVerifyValue::mutable_verify_vec() {
  return &verify_vec_;
}

// -------------------------------------------------------------------

// VerifyVecBrdRes

// optional bytes public_ip = 1;
inline bool VerifyVecBrdRes::has_public_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VerifyVecBrdRes::set_has_public_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VerifyVecBrdRes::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VerifyVecBrdRes::clear_public_ip() {
  if (public_ip_ != &::google::protobuf::internal::kEmptyString) {
    public_ip_->clear();
  }
  clear_has_public_ip();
}
inline const ::std::string& VerifyVecBrdRes::public_ip() const {
  return *public_ip_;
}
inline void VerifyVecBrdRes::set_public_ip(const ::std::string& value) {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  public_ip_->assign(value);
}
inline void VerifyVecBrdRes::set_public_ip(const char* value) {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  public_ip_->assign(value);
}
inline void VerifyVecBrdRes::set_public_ip(const void* value, size_t size) {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  public_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VerifyVecBrdRes::mutable_public_ip() {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  return public_ip_;
}
inline ::std::string* VerifyVecBrdRes::release_public_ip() {
  clear_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_ip_;
    public_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VerifyVecBrdRes::set_allocated_public_ip(::std::string* public_ip) {
  if (public_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete public_ip_;
  }
  if (public_ip) {
    set_has_public_ip();
    public_ip_ = public_ip;
  } else {
    clear_has_public_ip();
    public_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 public_port = 2;
inline bool VerifyVecBrdRes::has_public_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VerifyVecBrdRes::set_has_public_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VerifyVecBrdRes::clear_has_public_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VerifyVecBrdRes::clear_public_port() {
  public_port_ = 0u;
  clear_has_public_port();
}
inline ::google::protobuf::uint32 VerifyVecBrdRes::public_port() const {
  return public_port_;
}
inline void VerifyVecBrdRes::set_public_port(::google::protobuf::uint32 value) {
  set_has_public_port();
  public_port_ = value;
}

// -------------------------------------------------------------------

// SwapSecKeyItem

// optional bytes sec_key = 1;
inline bool SwapSecKeyItem::has_sec_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwapSecKeyItem::set_has_sec_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SwapSecKeyItem::clear_has_sec_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SwapSecKeyItem::clear_sec_key() {
  if (sec_key_ != &::google::protobuf::internal::kEmptyString) {
    sec_key_->clear();
  }
  clear_has_sec_key();
}
inline const ::std::string& SwapSecKeyItem::sec_key() const {
  return *sec_key_;
}
inline void SwapSecKeyItem::set_sec_key(const ::std::string& value) {
  set_has_sec_key();
  if (sec_key_ == &::google::protobuf::internal::kEmptyString) {
    sec_key_ = new ::std::string;
  }
  sec_key_->assign(value);
}
inline void SwapSecKeyItem::set_sec_key(const char* value) {
  set_has_sec_key();
  if (sec_key_ == &::google::protobuf::internal::kEmptyString) {
    sec_key_ = new ::std::string;
  }
  sec_key_->assign(value);
}
inline void SwapSecKeyItem::set_sec_key(const void* value, size_t size) {
  set_has_sec_key();
  if (sec_key_ == &::google::protobuf::internal::kEmptyString) {
    sec_key_ = new ::std::string;
  }
  sec_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapSecKeyItem::mutable_sec_key() {
  set_has_sec_key();
  if (sec_key_ == &::google::protobuf::internal::kEmptyString) {
    sec_key_ = new ::std::string;
  }
  return sec_key_;
}
inline ::std::string* SwapSecKeyItem::release_sec_key() {
  clear_has_sec_key();
  if (sec_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sec_key_;
    sec_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SwapSecKeyItem::set_allocated_sec_key(::std::string* sec_key) {
  if (sec_key_ != &::google::protobuf::internal::kEmptyString) {
    delete sec_key_;
  }
  if (sec_key) {
    set_has_sec_key();
    sec_key_ = sec_key;
  } else {
    clear_has_sec_key();
    sec_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 sec_key_len = 2;
inline bool SwapSecKeyItem::has_sec_key_len() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SwapSecKeyItem::set_has_sec_key_len() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SwapSecKeyItem::clear_has_sec_key_len() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SwapSecKeyItem::clear_sec_key_len() {
  sec_key_len_ = 0u;
  clear_has_sec_key_len();
}
inline ::google::protobuf::uint32 SwapSecKeyItem::sec_key_len() const {
  return sec_key_len_;
}
inline void SwapSecKeyItem::set_sec_key_len(::google::protobuf::uint32 value) {
  set_has_sec_key_len();
  sec_key_len_ = value;
}

// optional .zjchain.bls.protobuf.BlsPublicKey old_g2 = 3;
inline bool SwapSecKeyItem::has_old_g2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SwapSecKeyItem::set_has_old_g2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SwapSecKeyItem::clear_has_old_g2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SwapSecKeyItem::clear_old_g2() {
  if (old_g2_ != NULL) old_g2_->::zjchain::bls::protobuf::BlsPublicKey::Clear();
  clear_has_old_g2();
}
inline const ::zjchain::bls::protobuf::BlsPublicKey& SwapSecKeyItem::old_g2() const {
  return old_g2_ != NULL ? *old_g2_ : *default_instance_->old_g2_;
}
inline ::zjchain::bls::protobuf::BlsPublicKey* SwapSecKeyItem::mutable_old_g2() {
  set_has_old_g2();
  if (old_g2_ == NULL) old_g2_ = new ::zjchain::bls::protobuf::BlsPublicKey;
  return old_g2_;
}
inline ::zjchain::bls::protobuf::BlsPublicKey* SwapSecKeyItem::release_old_g2() {
  clear_has_old_g2();
  ::zjchain::bls::protobuf::BlsPublicKey* temp = old_g2_;
  old_g2_ = NULL;
  return temp;
}
inline void SwapSecKeyItem::set_allocated_old_g2(::zjchain::bls::protobuf::BlsPublicKey* old_g2) {
  delete old_g2_;
  old_g2_ = old_g2;
  if (old_g2) {
    set_has_old_g2();
  } else {
    clear_has_old_g2();
  }
}

// -------------------------------------------------------------------

// SwapSecKeyReq

// repeated .zjchain.bls.protobuf.SwapSecKeyItem keys = 1;
inline int SwapSecKeyReq::keys_size() const {
  return keys_.size();
}
inline void SwapSecKeyReq::clear_keys() {
  keys_.Clear();
}
inline const ::zjchain::bls::protobuf::SwapSecKeyItem& SwapSecKeyReq::keys(int index) const {
  return keys_.Get(index);
}
inline ::zjchain::bls::protobuf::SwapSecKeyItem* SwapSecKeyReq::mutable_keys(int index) {
  return keys_.Mutable(index);
}
inline ::zjchain::bls::protobuf::SwapSecKeyItem* SwapSecKeyReq::add_keys() {
  return keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zjchain::bls::protobuf::SwapSecKeyItem >&
SwapSecKeyReq::keys() const {
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::zjchain::bls::protobuf::SwapSecKeyItem >*
SwapSecKeyReq::mutable_keys() {
  return &keys_;
}

// -------------------------------------------------------------------

// SwapSecKeyRes

// optional uint32 index = 1;
inline bool SwapSecKeyRes::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwapSecKeyRes::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SwapSecKeyRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SwapSecKeyRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 SwapSecKeyRes::index() const {
  return index_;
}
inline void SwapSecKeyRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional bytes sec_key = 2;
inline bool SwapSecKeyRes::has_sec_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SwapSecKeyRes::set_has_sec_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SwapSecKeyRes::clear_has_sec_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SwapSecKeyRes::clear_sec_key() {
  if (sec_key_ != &::google::protobuf::internal::kEmptyString) {
    sec_key_->clear();
  }
  clear_has_sec_key();
}
inline const ::std::string& SwapSecKeyRes::sec_key() const {
  return *sec_key_;
}
inline void SwapSecKeyRes::set_sec_key(const ::std::string& value) {
  set_has_sec_key();
  if (sec_key_ == &::google::protobuf::internal::kEmptyString) {
    sec_key_ = new ::std::string;
  }
  sec_key_->assign(value);
}
inline void SwapSecKeyRes::set_sec_key(const char* value) {
  set_has_sec_key();
  if (sec_key_ == &::google::protobuf::internal::kEmptyString) {
    sec_key_ = new ::std::string;
  }
  sec_key_->assign(value);
}
inline void SwapSecKeyRes::set_sec_key(const void* value, size_t size) {
  set_has_sec_key();
  if (sec_key_ == &::google::protobuf::internal::kEmptyString) {
    sec_key_ = new ::std::string;
  }
  sec_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapSecKeyRes::mutable_sec_key() {
  set_has_sec_key();
  if (sec_key_ == &::google::protobuf::internal::kEmptyString) {
    sec_key_ = new ::std::string;
  }
  return sec_key_;
}
inline ::std::string* SwapSecKeyRes::release_sec_key() {
  clear_has_sec_key();
  if (sec_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sec_key_;
    sec_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SwapSecKeyRes::set_allocated_sec_key(::std::string* sec_key) {
  if (sec_key_ != &::google::protobuf::internal::kEmptyString) {
    delete sec_key_;
  }
  if (sec_key) {
    set_has_sec_key();
    sec_key_ = sec_key;
  } else {
    clear_has_sec_key();
    sec_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 sec_key_len = 3;
inline bool SwapSecKeyRes::has_sec_key_len() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SwapSecKeyRes::set_has_sec_key_len() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SwapSecKeyRes::clear_has_sec_key_len() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SwapSecKeyRes::clear_sec_key_len() {
  sec_key_len_ = 0u;
  clear_has_sec_key_len();
}
inline ::google::protobuf::uint32 SwapSecKeyRes::sec_key_len() const {
  return sec_key_len_;
}
inline void SwapSecKeyRes::set_sec_key_len(::google::protobuf::uint32 value) {
  set_has_sec_key_len();
  sec_key_len_ = value;
}

// -------------------------------------------------------------------

// AgainstParticipant

// optional uint32 against_index = 1;
inline bool AgainstParticipant::has_against_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgainstParticipant::set_has_against_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgainstParticipant::clear_has_against_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgainstParticipant::clear_against_index() {
  against_index_ = 0u;
  clear_has_against_index();
}
inline ::google::protobuf::uint32 AgainstParticipant::against_index() const {
  return against_index_;
}
inline void AgainstParticipant::set_against_index(::google::protobuf::uint32 value) {
  set_has_against_index();
  against_index_ = value;
}

// -------------------------------------------------------------------

// FinishBroadcast

// repeated uint64 bitmap = 1;
inline int FinishBroadcast::bitmap_size() const {
  return bitmap_.size();
}
inline void FinishBroadcast::clear_bitmap() {
  bitmap_.Clear();
}
inline ::google::protobuf::uint64 FinishBroadcast::bitmap(int index) const {
  return bitmap_.Get(index);
}
inline void FinishBroadcast::set_bitmap(int index, ::google::protobuf::uint64 value) {
  bitmap_.Set(index, value);
}
inline void FinishBroadcast::add_bitmap(::google::protobuf::uint64 value) {
  bitmap_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
FinishBroadcast::bitmap() const {
  return bitmap_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
FinishBroadcast::mutable_bitmap() {
  return &bitmap_;
}

// optional .zjchain.bls.protobuf.BlsPublicKey pubkey = 2;
inline bool FinishBroadcast::has_pubkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FinishBroadcast::set_has_pubkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FinishBroadcast::clear_has_pubkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FinishBroadcast::clear_pubkey() {
  if (pubkey_ != NULL) pubkey_->::zjchain::bls::protobuf::BlsPublicKey::Clear();
  clear_has_pubkey();
}
inline const ::zjchain::bls::protobuf::BlsPublicKey& FinishBroadcast::pubkey() const {
  return pubkey_ != NULL ? *pubkey_ : *default_instance_->pubkey_;
}
inline ::zjchain::bls::protobuf::BlsPublicKey* FinishBroadcast::mutable_pubkey() {
  set_has_pubkey();
  if (pubkey_ == NULL) pubkey_ = new ::zjchain::bls::protobuf::BlsPublicKey;
  return pubkey_;
}
inline ::zjchain::bls::protobuf::BlsPublicKey* FinishBroadcast::release_pubkey() {
  clear_has_pubkey();
  ::zjchain::bls::protobuf::BlsPublicKey* temp = pubkey_;
  pubkey_ = NULL;
  return temp;
}
inline void FinishBroadcast::set_allocated_pubkey(::zjchain::bls::protobuf::BlsPublicKey* pubkey) {
  delete pubkey_;
  pubkey_ = pubkey;
  if (pubkey) {
    set_has_pubkey();
  } else {
    clear_has_pubkey();
  }
}

// optional .zjchain.bls.protobuf.BlsPublicKey common_pubkey = 3;
inline bool FinishBroadcast::has_common_pubkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FinishBroadcast::set_has_common_pubkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FinishBroadcast::clear_has_common_pubkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FinishBroadcast::clear_common_pubkey() {
  if (common_pubkey_ != NULL) common_pubkey_->::zjchain::bls::protobuf::BlsPublicKey::Clear();
  clear_has_common_pubkey();
}
inline const ::zjchain::bls::protobuf::BlsPublicKey& FinishBroadcast::common_pubkey() const {
  return common_pubkey_ != NULL ? *common_pubkey_ : *default_instance_->common_pubkey_;
}
inline ::zjchain::bls::protobuf::BlsPublicKey* FinishBroadcast::mutable_common_pubkey() {
  set_has_common_pubkey();
  if (common_pubkey_ == NULL) common_pubkey_ = new ::zjchain::bls::protobuf::BlsPublicKey;
  return common_pubkey_;
}
inline ::zjchain::bls::protobuf::BlsPublicKey* FinishBroadcast::release_common_pubkey() {
  clear_has_common_pubkey();
  ::zjchain::bls::protobuf::BlsPublicKey* temp = common_pubkey_;
  common_pubkey_ = NULL;
  return temp;
}
inline void FinishBroadcast::set_allocated_common_pubkey(::zjchain::bls::protobuf::BlsPublicKey* common_pubkey) {
  delete common_pubkey_;
  common_pubkey_ = common_pubkey;
  if (common_pubkey) {
    set_has_common_pubkey();
  } else {
    clear_has_common_pubkey();
  }
}

// optional uint32 network_id = 4;
inline bool FinishBroadcast::has_network_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FinishBroadcast::set_has_network_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FinishBroadcast::clear_has_network_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FinishBroadcast::clear_network_id() {
  network_id_ = 0u;
  clear_has_network_id();
}
inline ::google::protobuf::uint32 FinishBroadcast::network_id() const {
  return network_id_;
}
inline void FinishBroadcast::set_network_id(::google::protobuf::uint32 value) {
  set_has_network_id();
  network_id_ = value;
}

// optional bytes bls_sign_x = 5;
inline bool FinishBroadcast::has_bls_sign_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FinishBroadcast::set_has_bls_sign_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FinishBroadcast::clear_has_bls_sign_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FinishBroadcast::clear_bls_sign_x() {
  if (bls_sign_x_ != &::google::protobuf::internal::kEmptyString) {
    bls_sign_x_->clear();
  }
  clear_has_bls_sign_x();
}
inline const ::std::string& FinishBroadcast::bls_sign_x() const {
  return *bls_sign_x_;
}
inline void FinishBroadcast::set_bls_sign_x(const ::std::string& value) {
  set_has_bls_sign_x();
  if (bls_sign_x_ == &::google::protobuf::internal::kEmptyString) {
    bls_sign_x_ = new ::std::string;
  }
  bls_sign_x_->assign(value);
}
inline void FinishBroadcast::set_bls_sign_x(const char* value) {
  set_has_bls_sign_x();
  if (bls_sign_x_ == &::google::protobuf::internal::kEmptyString) {
    bls_sign_x_ = new ::std::string;
  }
  bls_sign_x_->assign(value);
}
inline void FinishBroadcast::set_bls_sign_x(const void* value, size_t size) {
  set_has_bls_sign_x();
  if (bls_sign_x_ == &::google::protobuf::internal::kEmptyString) {
    bls_sign_x_ = new ::std::string;
  }
  bls_sign_x_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FinishBroadcast::mutable_bls_sign_x() {
  set_has_bls_sign_x();
  if (bls_sign_x_ == &::google::protobuf::internal::kEmptyString) {
    bls_sign_x_ = new ::std::string;
  }
  return bls_sign_x_;
}
inline ::std::string* FinishBroadcast::release_bls_sign_x() {
  clear_has_bls_sign_x();
  if (bls_sign_x_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bls_sign_x_;
    bls_sign_x_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FinishBroadcast::set_allocated_bls_sign_x(::std::string* bls_sign_x) {
  if (bls_sign_x_ != &::google::protobuf::internal::kEmptyString) {
    delete bls_sign_x_;
  }
  if (bls_sign_x) {
    set_has_bls_sign_x();
    bls_sign_x_ = bls_sign_x;
  } else {
    clear_has_bls_sign_x();
    bls_sign_x_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes bls_sign_y = 6;
inline bool FinishBroadcast::has_bls_sign_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FinishBroadcast::set_has_bls_sign_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FinishBroadcast::clear_has_bls_sign_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FinishBroadcast::clear_bls_sign_y() {
  if (bls_sign_y_ != &::google::protobuf::internal::kEmptyString) {
    bls_sign_y_->clear();
  }
  clear_has_bls_sign_y();
}
inline const ::std::string& FinishBroadcast::bls_sign_y() const {
  return *bls_sign_y_;
}
inline void FinishBroadcast::set_bls_sign_y(const ::std::string& value) {
  set_has_bls_sign_y();
  if (bls_sign_y_ == &::google::protobuf::internal::kEmptyString) {
    bls_sign_y_ = new ::std::string;
  }
  bls_sign_y_->assign(value);
}
inline void FinishBroadcast::set_bls_sign_y(const char* value) {
  set_has_bls_sign_y();
  if (bls_sign_y_ == &::google::protobuf::internal::kEmptyString) {
    bls_sign_y_ = new ::std::string;
  }
  bls_sign_y_->assign(value);
}
inline void FinishBroadcast::set_bls_sign_y(const void* value, size_t size) {
  set_has_bls_sign_y();
  if (bls_sign_y_ == &::google::protobuf::internal::kEmptyString) {
    bls_sign_y_ = new ::std::string;
  }
  bls_sign_y_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FinishBroadcast::mutable_bls_sign_y() {
  set_has_bls_sign_y();
  if (bls_sign_y_ == &::google::protobuf::internal::kEmptyString) {
    bls_sign_y_ = new ::std::string;
  }
  return bls_sign_y_;
}
inline ::std::string* FinishBroadcast::release_bls_sign_y() {
  clear_has_bls_sign_y();
  if (bls_sign_y_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bls_sign_y_;
    bls_sign_y_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FinishBroadcast::set_allocated_bls_sign_y(::std::string* bls_sign_y) {
  if (bls_sign_y_ != &::google::protobuf::internal::kEmptyString) {
    delete bls_sign_y_;
  }
  if (bls_sign_y) {
    set_has_bls_sign_y();
    bls_sign_y_ = bls_sign_y;
  } else {
    clear_has_bls_sign_y();
    bls_sign_y_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CheckVerfiyReq

// optional uint32 index = 1;
inline bool CheckVerfiyReq::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckVerfiyReq::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckVerfiyReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckVerfiyReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CheckVerfiyReq::index() const {
  return index_;
}
inline void CheckVerfiyReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// CheckSwapKeyReq

// optional uint32 index = 1;
inline bool CheckSwapKeyReq::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckSwapKeyReq::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckSwapKeyReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckSwapKeyReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CheckSwapKeyReq::index() const {
  return index_;
}
inline void CheckSwapKeyReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// BlsMessage

// optional .zjchain.bls.protobuf.VerifyVecBrdReq verify_brd = 1;
inline bool BlsMessage::has_verify_brd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlsMessage::set_has_verify_brd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlsMessage::clear_has_verify_brd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlsMessage::clear_verify_brd() {
  if (verify_brd_ != NULL) verify_brd_->::zjchain::bls::protobuf::VerifyVecBrdReq::Clear();
  clear_has_verify_brd();
}
inline const ::zjchain::bls::protobuf::VerifyVecBrdReq& BlsMessage::verify_brd() const {
  return verify_brd_ != NULL ? *verify_brd_ : *default_instance_->verify_brd_;
}
inline ::zjchain::bls::protobuf::VerifyVecBrdReq* BlsMessage::mutable_verify_brd() {
  set_has_verify_brd();
  if (verify_brd_ == NULL) verify_brd_ = new ::zjchain::bls::protobuf::VerifyVecBrdReq;
  return verify_brd_;
}
inline ::zjchain::bls::protobuf::VerifyVecBrdReq* BlsMessage::release_verify_brd() {
  clear_has_verify_brd();
  ::zjchain::bls::protobuf::VerifyVecBrdReq* temp = verify_brd_;
  verify_brd_ = NULL;
  return temp;
}
inline void BlsMessage::set_allocated_verify_brd(::zjchain::bls::protobuf::VerifyVecBrdReq* verify_brd) {
  delete verify_brd_;
  verify_brd_ = verify_brd;
  if (verify_brd) {
    set_has_verify_brd();
  } else {
    clear_has_verify_brd();
  }
}

// optional .zjchain.bls.protobuf.SwapSecKeyReq swap_req = 2;
inline bool BlsMessage::has_swap_req() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlsMessage::set_has_swap_req() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlsMessage::clear_has_swap_req() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlsMessage::clear_swap_req() {
  if (swap_req_ != NULL) swap_req_->::zjchain::bls::protobuf::SwapSecKeyReq::Clear();
  clear_has_swap_req();
}
inline const ::zjchain::bls::protobuf::SwapSecKeyReq& BlsMessage::swap_req() const {
  return swap_req_ != NULL ? *swap_req_ : *default_instance_->swap_req_;
}
inline ::zjchain::bls::protobuf::SwapSecKeyReq* BlsMessage::mutable_swap_req() {
  set_has_swap_req();
  if (swap_req_ == NULL) swap_req_ = new ::zjchain::bls::protobuf::SwapSecKeyReq;
  return swap_req_;
}
inline ::zjchain::bls::protobuf::SwapSecKeyReq* BlsMessage::release_swap_req() {
  clear_has_swap_req();
  ::zjchain::bls::protobuf::SwapSecKeyReq* temp = swap_req_;
  swap_req_ = NULL;
  return temp;
}
inline void BlsMessage::set_allocated_swap_req(::zjchain::bls::protobuf::SwapSecKeyReq* swap_req) {
  delete swap_req_;
  swap_req_ = swap_req;
  if (swap_req) {
    set_has_swap_req();
  } else {
    clear_has_swap_req();
  }
}

// optional .zjchain.bls.protobuf.FinishBroadcast finish_req = 3;
inline bool BlsMessage::has_finish_req() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlsMessage::set_has_finish_req() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlsMessage::clear_has_finish_req() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlsMessage::clear_finish_req() {
  if (finish_req_ != NULL) finish_req_->::zjchain::bls::protobuf::FinishBroadcast::Clear();
  clear_has_finish_req();
}
inline const ::zjchain::bls::protobuf::FinishBroadcast& BlsMessage::finish_req() const {
  return finish_req_ != NULL ? *finish_req_ : *default_instance_->finish_req_;
}
inline ::zjchain::bls::protobuf::FinishBroadcast* BlsMessage::mutable_finish_req() {
  set_has_finish_req();
  if (finish_req_ == NULL) finish_req_ = new ::zjchain::bls::protobuf::FinishBroadcast;
  return finish_req_;
}
inline ::zjchain::bls::protobuf::FinishBroadcast* BlsMessage::release_finish_req() {
  clear_has_finish_req();
  ::zjchain::bls::protobuf::FinishBroadcast* temp = finish_req_;
  finish_req_ = NULL;
  return temp;
}
inline void BlsMessage::set_allocated_finish_req(::zjchain::bls::protobuf::FinishBroadcast* finish_req) {
  delete finish_req_;
  finish_req_ = finish_req;
  if (finish_req) {
    set_has_finish_req();
  } else {
    clear_has_finish_req();
  }
}

// optional .zjchain.bls.protobuf.CheckVerfiyReq check_verify_req = 4;
inline bool BlsMessage::has_check_verify_req() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlsMessage::set_has_check_verify_req() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlsMessage::clear_has_check_verify_req() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlsMessage::clear_check_verify_req() {
  if (check_verify_req_ != NULL) check_verify_req_->::zjchain::bls::protobuf::CheckVerfiyReq::Clear();
  clear_has_check_verify_req();
}
inline const ::zjchain::bls::protobuf::CheckVerfiyReq& BlsMessage::check_verify_req() const {
  return check_verify_req_ != NULL ? *check_verify_req_ : *default_instance_->check_verify_req_;
}
inline ::zjchain::bls::protobuf::CheckVerfiyReq* BlsMessage::mutable_check_verify_req() {
  set_has_check_verify_req();
  if (check_verify_req_ == NULL) check_verify_req_ = new ::zjchain::bls::protobuf::CheckVerfiyReq;
  return check_verify_req_;
}
inline ::zjchain::bls::protobuf::CheckVerfiyReq* BlsMessage::release_check_verify_req() {
  clear_has_check_verify_req();
  ::zjchain::bls::protobuf::CheckVerfiyReq* temp = check_verify_req_;
  check_verify_req_ = NULL;
  return temp;
}
inline void BlsMessage::set_allocated_check_verify_req(::zjchain::bls::protobuf::CheckVerfiyReq* check_verify_req) {
  delete check_verify_req_;
  check_verify_req_ = check_verify_req;
  if (check_verify_req) {
    set_has_check_verify_req();
  } else {
    clear_has_check_verify_req();
  }
}

// optional .zjchain.bls.protobuf.CheckSwapKeyReq check_swapkey_req = 5;
inline bool BlsMessage::has_check_swapkey_req() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlsMessage::set_has_check_swapkey_req() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlsMessage::clear_has_check_swapkey_req() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlsMessage::clear_check_swapkey_req() {
  if (check_swapkey_req_ != NULL) check_swapkey_req_->::zjchain::bls::protobuf::CheckSwapKeyReq::Clear();
  clear_has_check_swapkey_req();
}
inline const ::zjchain::bls::protobuf::CheckSwapKeyReq& BlsMessage::check_swapkey_req() const {
  return check_swapkey_req_ != NULL ? *check_swapkey_req_ : *default_instance_->check_swapkey_req_;
}
inline ::zjchain::bls::protobuf::CheckSwapKeyReq* BlsMessage::mutable_check_swapkey_req() {
  set_has_check_swapkey_req();
  if (check_swapkey_req_ == NULL) check_swapkey_req_ = new ::zjchain::bls::protobuf::CheckSwapKeyReq;
  return check_swapkey_req_;
}
inline ::zjchain::bls::protobuf::CheckSwapKeyReq* BlsMessage::release_check_swapkey_req() {
  clear_has_check_swapkey_req();
  ::zjchain::bls::protobuf::CheckSwapKeyReq* temp = check_swapkey_req_;
  check_swapkey_req_ = NULL;
  return temp;
}
inline void BlsMessage::set_allocated_check_swapkey_req(::zjchain::bls::protobuf::CheckSwapKeyReq* check_swapkey_req) {
  delete check_swapkey_req_;
  check_swapkey_req_ = check_swapkey_req;
  if (check_swapkey_req) {
    set_has_check_swapkey_req();
  } else {
    clear_has_check_swapkey_req();
  }
}

// optional uint32 index = 6;
inline bool BlsMessage::has_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BlsMessage::set_has_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BlsMessage::clear_has_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BlsMessage::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 BlsMessage::index() const {
  return index_;
}
inline void BlsMessage::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint64 elect_height = 7;
inline bool BlsMessage::has_elect_height() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BlsMessage::set_has_elect_height() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BlsMessage::clear_has_elect_height() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BlsMessage::clear_elect_height() {
  elect_height_ = GOOGLE_ULONGLONG(0);
  clear_has_elect_height();
}
inline ::google::protobuf::uint64 BlsMessage::elect_height() const {
  return elect_height_;
}
inline void BlsMessage::set_elect_height(::google::protobuf::uint64 value) {
  set_has_elect_height();
  elect_height_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace bls
}  // namespace zjchain

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fbls_2eproto__INCLUDED
