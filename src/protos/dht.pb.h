// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/dht.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protos_2fdht_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protos_2fdht_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protos_2fdht_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fdht_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protos_2fdht_2eproto;
namespace zjchain {
namespace dht {
namespace protobuf {
class BootstrapRequest;
struct BootstrapRequestDefaultTypeInternal;
extern BootstrapRequestDefaultTypeInternal _BootstrapRequest_default_instance_;
class BootstrapResponse;
struct BootstrapResponseDefaultTypeInternal;
extern BootstrapResponseDefaultTypeInternal _BootstrapResponse_default_instance_;
class ConnectReqeust;
struct ConnectReqeustDefaultTypeInternal;
extern ConnectReqeustDefaultTypeInternal _ConnectReqeust_default_instance_;
class DhtMessage;
struct DhtMessageDefaultTypeInternal;
extern DhtMessageDefaultTypeInternal _DhtMessage_default_instance_;
class HeartbeatRequest;
struct HeartbeatRequestDefaultTypeInternal;
extern HeartbeatRequestDefaultTypeInternal _HeartbeatRequest_default_instance_;
class HeartbeatResponse;
struct HeartbeatResponseDefaultTypeInternal;
extern HeartbeatResponseDefaultTypeInternal _HeartbeatResponse_default_instance_;
class NodeInfo;
struct NodeInfoDefaultTypeInternal;
extern NodeInfoDefaultTypeInternal _NodeInfo_default_instance_;
class RefreshNeighborsRequest;
struct RefreshNeighborsRequestDefaultTypeInternal;
extern RefreshNeighborsRequestDefaultTypeInternal _RefreshNeighborsRequest_default_instance_;
class RefreshNeighborsResponse;
struct RefreshNeighborsResponseDefaultTypeInternal;
extern RefreshNeighborsResponseDefaultTypeInternal _RefreshNeighborsResponse_default_instance_;
class TimerRequest;
struct TimerRequestDefaultTypeInternal;
extern TimerRequestDefaultTypeInternal _TimerRequest_default_instance_;
}  // namespace protobuf
}  // namespace dht
}  // namespace zjchain
PROTOBUF_NAMESPACE_OPEN
template<> ::zjchain::dht::protobuf::BootstrapRequest* Arena::CreateMaybeMessage<::zjchain::dht::protobuf::BootstrapRequest>(Arena*);
template<> ::zjchain::dht::protobuf::BootstrapResponse* Arena::CreateMaybeMessage<::zjchain::dht::protobuf::BootstrapResponse>(Arena*);
template<> ::zjchain::dht::protobuf::ConnectReqeust* Arena::CreateMaybeMessage<::zjchain::dht::protobuf::ConnectReqeust>(Arena*);
template<> ::zjchain::dht::protobuf::DhtMessage* Arena::CreateMaybeMessage<::zjchain::dht::protobuf::DhtMessage>(Arena*);
template<> ::zjchain::dht::protobuf::HeartbeatRequest* Arena::CreateMaybeMessage<::zjchain::dht::protobuf::HeartbeatRequest>(Arena*);
template<> ::zjchain::dht::protobuf::HeartbeatResponse* Arena::CreateMaybeMessage<::zjchain::dht::protobuf::HeartbeatResponse>(Arena*);
template<> ::zjchain::dht::protobuf::NodeInfo* Arena::CreateMaybeMessage<::zjchain::dht::protobuf::NodeInfo>(Arena*);
template<> ::zjchain::dht::protobuf::RefreshNeighborsRequest* Arena::CreateMaybeMessage<::zjchain::dht::protobuf::RefreshNeighborsRequest>(Arena*);
template<> ::zjchain::dht::protobuf::RefreshNeighborsResponse* Arena::CreateMaybeMessage<::zjchain::dht::protobuf::RefreshNeighborsResponse>(Arena*);
template<> ::zjchain::dht::protobuf::TimerRequest* Arena::CreateMaybeMessage<::zjchain::dht::protobuf::TimerRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace zjchain {
namespace dht {
namespace protobuf {

// ===================================================================

class BootstrapRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zjchain.dht.protobuf.BootstrapRequest) */ {
 public:
  inline BootstrapRequest() : BootstrapRequest(nullptr) {}
  ~BootstrapRequest() override;
  explicit PROTOBUF_CONSTEXPR BootstrapRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BootstrapRequest(const BootstrapRequest& from);
  BootstrapRequest(BootstrapRequest&& from) noexcept
    : BootstrapRequest() {
    *this = ::std::move(from);
  }

  inline BootstrapRequest& operator=(const BootstrapRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BootstrapRequest& operator=(BootstrapRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BootstrapRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BootstrapRequest* internal_default_instance() {
    return reinterpret_cast<const BootstrapRequest*>(
               &_BootstrapRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BootstrapRequest& a, BootstrapRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BootstrapRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BootstrapRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BootstrapRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BootstrapRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BootstrapRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BootstrapRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BootstrapRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zjchain.dht.protobuf.BootstrapRequest";
  }
  protected:
  explicit BootstrapRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubkeyFieldNumber = 1,
    kPublicIpFieldNumber = 2,
    kPublicPortFieldNumber = 3,
  };
  // optional bytes pubkey = 1;
  bool has_pubkey() const;
  private:
  bool _internal_has_pubkey() const;
  public:
  void clear_pubkey();
  const std::string& pubkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pubkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pubkey();
  PROTOBUF_NODISCARD std::string* release_pubkey();
  void set_allocated_pubkey(std::string* pubkey);
  private:
  const std::string& _internal_pubkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pubkey(const std::string& value);
  std::string* _internal_mutable_pubkey();
  public:

  // optional string public_ip = 2;
  bool has_public_ip() const;
  private:
  bool _internal_has_public_ip() const;
  public:
  void clear_public_ip();
  const std::string& public_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_ip();
  PROTOBUF_NODISCARD std::string* release_public_ip();
  void set_allocated_public_ip(std::string* public_ip);
  private:
  const std::string& _internal_public_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_ip(const std::string& value);
  std::string* _internal_mutable_public_ip();
  public:

  // optional int32 public_port = 3;
  bool has_public_port() const;
  private:
  bool _internal_has_public_port() const;
  public:
  void clear_public_port();
  int32_t public_port() const;
  void set_public_port(int32_t value);
  private:
  int32_t _internal_public_port() const;
  void _internal_set_public_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zjchain.dht.protobuf.BootstrapRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pubkey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_ip_;
  int32_t public_port_;
  friend struct ::TableStruct_protos_2fdht_2eproto;
};
// -------------------------------------------------------------------

class BootstrapResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zjchain.dht.protobuf.BootstrapResponse) */ {
 public:
  inline BootstrapResponse() : BootstrapResponse(nullptr) {}
  ~BootstrapResponse() override;
  explicit PROTOBUF_CONSTEXPR BootstrapResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BootstrapResponse(const BootstrapResponse& from);
  BootstrapResponse(BootstrapResponse&& from) noexcept
    : BootstrapResponse() {
    *this = ::std::move(from);
  }

  inline BootstrapResponse& operator=(const BootstrapResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BootstrapResponse& operator=(BootstrapResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BootstrapResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BootstrapResponse* internal_default_instance() {
    return reinterpret_cast<const BootstrapResponse*>(
               &_BootstrapResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BootstrapResponse& a, BootstrapResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BootstrapResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BootstrapResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BootstrapResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BootstrapResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BootstrapResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BootstrapResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BootstrapResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zjchain.dht.protobuf.BootstrapResponse";
  }
  protected:
  explicit BootstrapResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubkeyFieldNumber = 1,
    kPublicIpFieldNumber = 2,
    kPublicPortFieldNumber = 3,
  };
  // optional bytes pubkey = 1;
  bool has_pubkey() const;
  private:
  bool _internal_has_pubkey() const;
  public:
  void clear_pubkey();
  const std::string& pubkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pubkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pubkey();
  PROTOBUF_NODISCARD std::string* release_pubkey();
  void set_allocated_pubkey(std::string* pubkey);
  private:
  const std::string& _internal_pubkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pubkey(const std::string& value);
  std::string* _internal_mutable_pubkey();
  public:

  // optional string public_ip = 2;
  bool has_public_ip() const;
  private:
  bool _internal_has_public_ip() const;
  public:
  void clear_public_ip();
  const std::string& public_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_ip();
  PROTOBUF_NODISCARD std::string* release_public_ip();
  void set_allocated_public_ip(std::string* public_ip);
  private:
  const std::string& _internal_public_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_ip(const std::string& value);
  std::string* _internal_mutable_public_ip();
  public:

  // optional int32 public_port = 3;
  bool has_public_port() const;
  private:
  bool _internal_has_public_port() const;
  public:
  void clear_public_port();
  int32_t public_port() const;
  void set_public_port(int32_t value);
  private:
  int32_t _internal_public_port() const;
  void _internal_set_public_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zjchain.dht.protobuf.BootstrapResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pubkey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_ip_;
  int32_t public_port_;
  friend struct ::TableStruct_protos_2fdht_2eproto;
};
// -------------------------------------------------------------------

class NodeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zjchain.dht.protobuf.NodeInfo) */ {
 public:
  inline NodeInfo() : NodeInfo(nullptr) {}
  ~NodeInfo() override;
  explicit PROTOBUF_CONSTEXPR NodeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeInfo(const NodeInfo& from);
  NodeInfo(NodeInfo&& from) noexcept
    : NodeInfo() {
    *this = ::std::move(from);
  }

  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfo& operator=(NodeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo*>(
               &_NodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NodeInfo& a, NodeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NodeInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zjchain.dht.protobuf.NodeInfo";
  }
  protected:
  explicit NodeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicIpFieldNumber = 1,
    kPubkeyFieldNumber = 3,
    kPublicPortFieldNumber = 2,
    kShardingIdFieldNumber = 4,
  };
  // optional bytes public_ip = 1;
  bool has_public_ip() const;
  private:
  bool _internal_has_public_ip() const;
  public:
  void clear_public_ip();
  const std::string& public_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_ip();
  PROTOBUF_NODISCARD std::string* release_public_ip();
  void set_allocated_public_ip(std::string* public_ip);
  private:
  const std::string& _internal_public_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_ip(const std::string& value);
  std::string* _internal_mutable_public_ip();
  public:

  // optional bytes pubkey = 3;
  bool has_pubkey() const;
  private:
  bool _internal_has_pubkey() const;
  public:
  void clear_pubkey();
  const std::string& pubkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pubkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pubkey();
  PROTOBUF_NODISCARD std::string* release_pubkey();
  void set_allocated_pubkey(std::string* pubkey);
  private:
  const std::string& _internal_pubkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pubkey(const std::string& value);
  std::string* _internal_mutable_pubkey();
  public:

  // optional int32 public_port = 2;
  bool has_public_port() const;
  private:
  bool _internal_has_public_port() const;
  public:
  void clear_public_port();
  int32_t public_port() const;
  void set_public_port(int32_t value);
  private:
  int32_t _internal_public_port() const;
  void _internal_set_public_port(int32_t value);
  public:

  // optional int32 sharding_id = 4;
  bool has_sharding_id() const;
  private:
  bool _internal_has_sharding_id() const;
  public:
  void clear_sharding_id();
  int32_t sharding_id() const;
  void set_sharding_id(int32_t value);
  private:
  int32_t _internal_sharding_id() const;
  void _internal_set_sharding_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zjchain.dht.protobuf.NodeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pubkey_;
  int32_t public_port_;
  int32_t sharding_id_;
  friend struct ::TableStruct_protos_2fdht_2eproto;
};
// -------------------------------------------------------------------

class RefreshNeighborsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zjchain.dht.protobuf.RefreshNeighborsRequest) */ {
 public:
  inline RefreshNeighborsRequest() : RefreshNeighborsRequest(nullptr) {}
  ~RefreshNeighborsRequest() override;
  explicit PROTOBUF_CONSTEXPR RefreshNeighborsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshNeighborsRequest(const RefreshNeighborsRequest& from);
  RefreshNeighborsRequest(RefreshNeighborsRequest&& from) noexcept
    : RefreshNeighborsRequest() {
    *this = ::std::move(from);
  }

  inline RefreshNeighborsRequest& operator=(const RefreshNeighborsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshNeighborsRequest& operator=(RefreshNeighborsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshNeighborsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshNeighborsRequest* internal_default_instance() {
    return reinterpret_cast<const RefreshNeighborsRequest*>(
               &_RefreshNeighborsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RefreshNeighborsRequest& a, RefreshNeighborsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshNeighborsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshNeighborsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshNeighborsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshNeighborsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshNeighborsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RefreshNeighborsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshNeighborsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zjchain.dht.protobuf.RefreshNeighborsRequest";
  }
  protected:
  explicit RefreshNeighborsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBloomfilterFieldNumber = 2,
    kIdsFieldNumber = 6,
    kPubkeyFieldNumber = 3,
    kPublicIpFieldNumber = 4,
    kCountFieldNumber = 1,
    kPublicPortFieldNumber = 5,
  };
  // repeated uint64 bloomfilter = 2;
  int bloomfilter_size() const;
  private:
  int _internal_bloomfilter_size() const;
  public:
  void clear_bloomfilter();
  private:
  uint64_t _internal_bloomfilter(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_bloomfilter() const;
  void _internal_add_bloomfilter(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_bloomfilter();
  public:
  uint64_t bloomfilter(int index) const;
  void set_bloomfilter(int index, uint64_t value);
  void add_bloomfilter(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      bloomfilter() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_bloomfilter();

  // repeated bytes ids = 6;
  int ids_size() const;
  private:
  int _internal_ids_size() const;
  public:
  void clear_ids();
  const std::string& ids(int index) const;
  std::string* mutable_ids(int index);
  void set_ids(int index, const std::string& value);
  void set_ids(int index, std::string&& value);
  void set_ids(int index, const char* value);
  void set_ids(int index, const void* value, size_t size);
  std::string* add_ids();
  void add_ids(const std::string& value);
  void add_ids(std::string&& value);
  void add_ids(const char* value);
  void add_ids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ids();
  private:
  const std::string& _internal_ids(int index) const;
  std::string* _internal_add_ids();
  public:

  // optional bytes pubkey = 3;
  bool has_pubkey() const;
  private:
  bool _internal_has_pubkey() const;
  public:
  void clear_pubkey();
  const std::string& pubkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pubkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pubkey();
  PROTOBUF_NODISCARD std::string* release_pubkey();
  void set_allocated_pubkey(std::string* pubkey);
  private:
  const std::string& _internal_pubkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pubkey(const std::string& value);
  std::string* _internal_mutable_pubkey();
  public:

  // optional string public_ip = 4;
  bool has_public_ip() const;
  private:
  bool _internal_has_public_ip() const;
  public:
  void clear_public_ip();
  const std::string& public_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_ip();
  PROTOBUF_NODISCARD std::string* release_public_ip();
  void set_allocated_public_ip(std::string* public_ip);
  private:
  const std::string& _internal_public_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_ip(const std::string& value);
  std::string* _internal_mutable_public_ip();
  public:

  // optional uint32 count = 1;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // optional int32 public_port = 5;
  bool has_public_port() const;
  private:
  bool _internal_has_public_port() const;
  public:
  void clear_public_port();
  int32_t public_port() const;
  void set_public_port(int32_t value);
  private:
  int32_t _internal_public_port() const;
  void _internal_set_public_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zjchain.dht.protobuf.RefreshNeighborsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > bloomfilter_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pubkey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_ip_;
  uint32_t count_;
  int32_t public_port_;
  friend struct ::TableStruct_protos_2fdht_2eproto;
};
// -------------------------------------------------------------------

class RefreshNeighborsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zjchain.dht.protobuf.RefreshNeighborsResponse) */ {
 public:
  inline RefreshNeighborsResponse() : RefreshNeighborsResponse(nullptr) {}
  ~RefreshNeighborsResponse() override;
  explicit PROTOBUF_CONSTEXPR RefreshNeighborsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshNeighborsResponse(const RefreshNeighborsResponse& from);
  RefreshNeighborsResponse(RefreshNeighborsResponse&& from) noexcept
    : RefreshNeighborsResponse() {
    *this = ::std::move(from);
  }

  inline RefreshNeighborsResponse& operator=(const RefreshNeighborsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshNeighborsResponse& operator=(RefreshNeighborsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshNeighborsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshNeighborsResponse* internal_default_instance() {
    return reinterpret_cast<const RefreshNeighborsResponse*>(
               &_RefreshNeighborsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RefreshNeighborsResponse& a, RefreshNeighborsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshNeighborsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshNeighborsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshNeighborsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshNeighborsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshNeighborsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RefreshNeighborsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshNeighborsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zjchain.dht.protobuf.RefreshNeighborsResponse";
  }
  protected:
  explicit RefreshNeighborsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
  };
  // repeated .zjchain.dht.protobuf.NodeInfo nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::zjchain::dht::protobuf::NodeInfo* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zjchain::dht::protobuf::NodeInfo >*
      mutable_nodes();
  private:
  const ::zjchain::dht::protobuf::NodeInfo& _internal_nodes(int index) const;
  ::zjchain::dht::protobuf::NodeInfo* _internal_add_nodes();
  public:
  const ::zjchain::dht::protobuf::NodeInfo& nodes(int index) const;
  ::zjchain::dht::protobuf::NodeInfo* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zjchain::dht::protobuf::NodeInfo >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:zjchain.dht.protobuf.RefreshNeighborsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zjchain::dht::protobuf::NodeInfo > nodes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fdht_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zjchain.dht.protobuf.HeartbeatRequest) */ {
 public:
  inline HeartbeatRequest() : HeartbeatRequest(nullptr) {}
  ~HeartbeatRequest() override;
  explicit PROTOBUF_CONSTEXPR HeartbeatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatRequest(const HeartbeatRequest& from);
  HeartbeatRequest(HeartbeatRequest&& from) noexcept
    : HeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline HeartbeatRequest& operator=(const HeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatRequest& operator=(HeartbeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartbeatRequest*>(
               &_HeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(HeartbeatRequest& a, HeartbeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HeartbeatRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zjchain.dht.protobuf.HeartbeatRequest";
  }
  protected:
  explicit HeartbeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDhtKeyHashFieldNumber = 1,
  };
  // optional uint64 dht_key_hash = 1;
  bool has_dht_key_hash() const;
  private:
  bool _internal_has_dht_key_hash() const;
  public:
  void clear_dht_key_hash();
  uint64_t dht_key_hash() const;
  void set_dht_key_hash(uint64_t value);
  private:
  uint64_t _internal_dht_key_hash() const;
  void _internal_set_dht_key_hash(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:zjchain.dht.protobuf.HeartbeatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t dht_key_hash_;
  friend struct ::TableStruct_protos_2fdht_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zjchain.dht.protobuf.HeartbeatResponse) */ {
 public:
  inline HeartbeatResponse() : HeartbeatResponse(nullptr) {}
  ~HeartbeatResponse() override;
  explicit PROTOBUF_CONSTEXPR HeartbeatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatResponse(const HeartbeatResponse& from);
  HeartbeatResponse(HeartbeatResponse&& from) noexcept
    : HeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline HeartbeatResponse& operator=(const HeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatResponse& operator=(HeartbeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const HeartbeatResponse*>(
               &_HeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(HeartbeatResponse& a, HeartbeatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HeartbeatResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zjchain.dht.protobuf.HeartbeatResponse";
  }
  protected:
  explicit HeartbeatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDhtKeyHashFieldNumber = 1,
  };
  // optional uint64 dht_key_hash = 1;
  bool has_dht_key_hash() const;
  private:
  bool _internal_has_dht_key_hash() const;
  public:
  void clear_dht_key_hash();
  uint64_t dht_key_hash() const;
  void set_dht_key_hash(uint64_t value);
  private:
  uint64_t _internal_dht_key_hash() const;
  void _internal_set_dht_key_hash(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:zjchain.dht.protobuf.HeartbeatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t dht_key_hash_;
  friend struct ::TableStruct_protos_2fdht_2eproto;
};
// -------------------------------------------------------------------

class ConnectReqeust final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zjchain.dht.protobuf.ConnectReqeust) */ {
 public:
  inline ConnectReqeust() : ConnectReqeust(nullptr) {}
  ~ConnectReqeust() override;
  explicit PROTOBUF_CONSTEXPR ConnectReqeust(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectReqeust(const ConnectReqeust& from);
  ConnectReqeust(ConnectReqeust&& from) noexcept
    : ConnectReqeust() {
    *this = ::std::move(from);
  }

  inline ConnectReqeust& operator=(const ConnectReqeust& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectReqeust& operator=(ConnectReqeust&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectReqeust& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectReqeust* internal_default_instance() {
    return reinterpret_cast<const ConnectReqeust*>(
               &_ConnectReqeust_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ConnectReqeust& a, ConnectReqeust& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectReqeust* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectReqeust* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectReqeust* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectReqeust>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectReqeust& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConnectReqeust& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectReqeust* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zjchain.dht.protobuf.ConnectReqeust";
  }
  protected:
  explicit ConnectReqeust(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubkeyFieldNumber = 1,
    kPublicIpFieldNumber = 3,
    kIsResponseFieldNumber = 2,
    kPublicPortFieldNumber = 4,
  };
  // optional bytes pubkey = 1;
  bool has_pubkey() const;
  private:
  bool _internal_has_pubkey() const;
  public:
  void clear_pubkey();
  const std::string& pubkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pubkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pubkey();
  PROTOBUF_NODISCARD std::string* release_pubkey();
  void set_allocated_pubkey(std::string* pubkey);
  private:
  const std::string& _internal_pubkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pubkey(const std::string& value);
  std::string* _internal_mutable_pubkey();
  public:

  // optional string public_ip = 3;
  bool has_public_ip() const;
  private:
  bool _internal_has_public_ip() const;
  public:
  void clear_public_ip();
  const std::string& public_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_ip();
  PROTOBUF_NODISCARD std::string* release_public_ip();
  void set_allocated_public_ip(std::string* public_ip);
  private:
  const std::string& _internal_public_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_ip(const std::string& value);
  std::string* _internal_mutable_public_ip();
  public:

  // optional bool is_response = 2;
  bool has_is_response() const;
  private:
  bool _internal_has_is_response() const;
  public:
  void clear_is_response();
  bool is_response() const;
  void set_is_response(bool value);
  private:
  bool _internal_is_response() const;
  void _internal_set_is_response(bool value);
  public:

  // optional int32 public_port = 4;
  bool has_public_port() const;
  private:
  bool _internal_has_public_port() const;
  public:
  void clear_public_port();
  int32_t public_port() const;
  void set_public_port(int32_t value);
  private:
  int32_t _internal_public_port() const;
  void _internal_set_public_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zjchain.dht.protobuf.ConnectReqeust)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pubkey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_ip_;
  bool is_response_;
  int32_t public_port_;
  friend struct ::TableStruct_protos_2fdht_2eproto;
};
// -------------------------------------------------------------------

class TimerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zjchain.dht.protobuf.TimerRequest) */ {
 public:
  inline TimerRequest() : TimerRequest(nullptr) {}
  ~TimerRequest() override;
  explicit PROTOBUF_CONSTEXPR TimerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimerRequest(const TimerRequest& from);
  TimerRequest(TimerRequest&& from) noexcept
    : TimerRequest() {
    *this = ::std::move(from);
  }

  inline TimerRequest& operator=(const TimerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimerRequest& operator=(TimerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimerRequest* internal_default_instance() {
    return reinterpret_cast<const TimerRequest*>(
               &_TimerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TimerRequest& a, TimerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TimerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TimerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zjchain.dht.protobuf.TimerRequest";
  }
  protected:
  explicit TimerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTmMilliFieldNumber = 1,
  };
  // optional uint64 tm_milli = 1;
  bool has_tm_milli() const;
  private:
  bool _internal_has_tm_milli() const;
  public:
  void clear_tm_milli();
  uint64_t tm_milli() const;
  void set_tm_milli(uint64_t value);
  private:
  uint64_t _internal_tm_milli() const;
  void _internal_set_tm_milli(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:zjchain.dht.protobuf.TimerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t tm_milli_;
  friend struct ::TableStruct_protos_2fdht_2eproto;
};
// -------------------------------------------------------------------

class DhtMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zjchain.dht.protobuf.DhtMessage) */ {
 public:
  inline DhtMessage() : DhtMessage(nullptr) {}
  ~DhtMessage() override;
  explicit PROTOBUF_CONSTEXPR DhtMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DhtMessage(const DhtMessage& from);
  DhtMessage(DhtMessage&& from) noexcept
    : DhtMessage() {
    *this = ::std::move(from);
  }

  inline DhtMessage& operator=(const DhtMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DhtMessage& operator=(DhtMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DhtMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DhtMessage* internal_default_instance() {
    return reinterpret_cast<const DhtMessage*>(
               &_DhtMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DhtMessage& a, DhtMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DhtMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DhtMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DhtMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DhtMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DhtMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DhtMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DhtMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zjchain.dht.protobuf.DhtMessage";
  }
  protected:
  explicit DhtMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBootstrapReqFieldNumber = 1,
    kBootstrapResFieldNumber = 2,
    kRefreshNeighborsReqFieldNumber = 3,
    kRefreshNeighborsResFieldNumber = 4,
    kConnectReqFieldNumber = 5,
    kHeartbeatReqFieldNumber = 6,
    kHeartbeatResFieldNumber = 7,
    kTimerFieldNumber = 8,
  };
  // optional .zjchain.dht.protobuf.BootstrapRequest bootstrap_req = 1;
  bool has_bootstrap_req() const;
  private:
  bool _internal_has_bootstrap_req() const;
  public:
  void clear_bootstrap_req();
  const ::zjchain::dht::protobuf::BootstrapRequest& bootstrap_req() const;
  PROTOBUF_NODISCARD ::zjchain::dht::protobuf::BootstrapRequest* release_bootstrap_req();
  ::zjchain::dht::protobuf::BootstrapRequest* mutable_bootstrap_req();
  void set_allocated_bootstrap_req(::zjchain::dht::protobuf::BootstrapRequest* bootstrap_req);
  private:
  const ::zjchain::dht::protobuf::BootstrapRequest& _internal_bootstrap_req() const;
  ::zjchain::dht::protobuf::BootstrapRequest* _internal_mutable_bootstrap_req();
  public:
  void unsafe_arena_set_allocated_bootstrap_req(
      ::zjchain::dht::protobuf::BootstrapRequest* bootstrap_req);
  ::zjchain::dht::protobuf::BootstrapRequest* unsafe_arena_release_bootstrap_req();

  // optional .zjchain.dht.protobuf.BootstrapResponse bootstrap_res = 2;
  bool has_bootstrap_res() const;
  private:
  bool _internal_has_bootstrap_res() const;
  public:
  void clear_bootstrap_res();
  const ::zjchain::dht::protobuf::BootstrapResponse& bootstrap_res() const;
  PROTOBUF_NODISCARD ::zjchain::dht::protobuf::BootstrapResponse* release_bootstrap_res();
  ::zjchain::dht::protobuf::BootstrapResponse* mutable_bootstrap_res();
  void set_allocated_bootstrap_res(::zjchain::dht::protobuf::BootstrapResponse* bootstrap_res);
  private:
  const ::zjchain::dht::protobuf::BootstrapResponse& _internal_bootstrap_res() const;
  ::zjchain::dht::protobuf::BootstrapResponse* _internal_mutable_bootstrap_res();
  public:
  void unsafe_arena_set_allocated_bootstrap_res(
      ::zjchain::dht::protobuf::BootstrapResponse* bootstrap_res);
  ::zjchain::dht::protobuf::BootstrapResponse* unsafe_arena_release_bootstrap_res();

  // optional .zjchain.dht.protobuf.RefreshNeighborsRequest refresh_neighbors_req = 3;
  bool has_refresh_neighbors_req() const;
  private:
  bool _internal_has_refresh_neighbors_req() const;
  public:
  void clear_refresh_neighbors_req();
  const ::zjchain::dht::protobuf::RefreshNeighborsRequest& refresh_neighbors_req() const;
  PROTOBUF_NODISCARD ::zjchain::dht::protobuf::RefreshNeighborsRequest* release_refresh_neighbors_req();
  ::zjchain::dht::protobuf::RefreshNeighborsRequest* mutable_refresh_neighbors_req();
  void set_allocated_refresh_neighbors_req(::zjchain::dht::protobuf::RefreshNeighborsRequest* refresh_neighbors_req);
  private:
  const ::zjchain::dht::protobuf::RefreshNeighborsRequest& _internal_refresh_neighbors_req() const;
  ::zjchain::dht::protobuf::RefreshNeighborsRequest* _internal_mutable_refresh_neighbors_req();
  public:
  void unsafe_arena_set_allocated_refresh_neighbors_req(
      ::zjchain::dht::protobuf::RefreshNeighborsRequest* refresh_neighbors_req);
  ::zjchain::dht::protobuf::RefreshNeighborsRequest* unsafe_arena_release_refresh_neighbors_req();

  // optional .zjchain.dht.protobuf.RefreshNeighborsResponse refresh_neighbors_res = 4;
  bool has_refresh_neighbors_res() const;
  private:
  bool _internal_has_refresh_neighbors_res() const;
  public:
  void clear_refresh_neighbors_res();
  const ::zjchain::dht::protobuf::RefreshNeighborsResponse& refresh_neighbors_res() const;
  PROTOBUF_NODISCARD ::zjchain::dht::protobuf::RefreshNeighborsResponse* release_refresh_neighbors_res();
  ::zjchain::dht::protobuf::RefreshNeighborsResponse* mutable_refresh_neighbors_res();
  void set_allocated_refresh_neighbors_res(::zjchain::dht::protobuf::RefreshNeighborsResponse* refresh_neighbors_res);
  private:
  const ::zjchain::dht::protobuf::RefreshNeighborsResponse& _internal_refresh_neighbors_res() const;
  ::zjchain::dht::protobuf::RefreshNeighborsResponse* _internal_mutable_refresh_neighbors_res();
  public:
  void unsafe_arena_set_allocated_refresh_neighbors_res(
      ::zjchain::dht::protobuf::RefreshNeighborsResponse* refresh_neighbors_res);
  ::zjchain::dht::protobuf::RefreshNeighborsResponse* unsafe_arena_release_refresh_neighbors_res();

  // optional .zjchain.dht.protobuf.ConnectReqeust connect_req = 5;
  bool has_connect_req() const;
  private:
  bool _internal_has_connect_req() const;
  public:
  void clear_connect_req();
  const ::zjchain::dht::protobuf::ConnectReqeust& connect_req() const;
  PROTOBUF_NODISCARD ::zjchain::dht::protobuf::ConnectReqeust* release_connect_req();
  ::zjchain::dht::protobuf::ConnectReqeust* mutable_connect_req();
  void set_allocated_connect_req(::zjchain::dht::protobuf::ConnectReqeust* connect_req);
  private:
  const ::zjchain::dht::protobuf::ConnectReqeust& _internal_connect_req() const;
  ::zjchain::dht::protobuf::ConnectReqeust* _internal_mutable_connect_req();
  public:
  void unsafe_arena_set_allocated_connect_req(
      ::zjchain::dht::protobuf::ConnectReqeust* connect_req);
  ::zjchain::dht::protobuf::ConnectReqeust* unsafe_arena_release_connect_req();

  // optional .zjchain.dht.protobuf.HeartbeatRequest heartbeat_req = 6;
  bool has_heartbeat_req() const;
  private:
  bool _internal_has_heartbeat_req() const;
  public:
  void clear_heartbeat_req();
  const ::zjchain::dht::protobuf::HeartbeatRequest& heartbeat_req() const;
  PROTOBUF_NODISCARD ::zjchain::dht::protobuf::HeartbeatRequest* release_heartbeat_req();
  ::zjchain::dht::protobuf::HeartbeatRequest* mutable_heartbeat_req();
  void set_allocated_heartbeat_req(::zjchain::dht::protobuf::HeartbeatRequest* heartbeat_req);
  private:
  const ::zjchain::dht::protobuf::HeartbeatRequest& _internal_heartbeat_req() const;
  ::zjchain::dht::protobuf::HeartbeatRequest* _internal_mutable_heartbeat_req();
  public:
  void unsafe_arena_set_allocated_heartbeat_req(
      ::zjchain::dht::protobuf::HeartbeatRequest* heartbeat_req);
  ::zjchain::dht::protobuf::HeartbeatRequest* unsafe_arena_release_heartbeat_req();

  // optional .zjchain.dht.protobuf.HeartbeatResponse heartbeat_res = 7;
  bool has_heartbeat_res() const;
  private:
  bool _internal_has_heartbeat_res() const;
  public:
  void clear_heartbeat_res();
  const ::zjchain::dht::protobuf::HeartbeatResponse& heartbeat_res() const;
  PROTOBUF_NODISCARD ::zjchain::dht::protobuf::HeartbeatResponse* release_heartbeat_res();
  ::zjchain::dht::protobuf::HeartbeatResponse* mutable_heartbeat_res();
  void set_allocated_heartbeat_res(::zjchain::dht::protobuf::HeartbeatResponse* heartbeat_res);
  private:
  const ::zjchain::dht::protobuf::HeartbeatResponse& _internal_heartbeat_res() const;
  ::zjchain::dht::protobuf::HeartbeatResponse* _internal_mutable_heartbeat_res();
  public:
  void unsafe_arena_set_allocated_heartbeat_res(
      ::zjchain::dht::protobuf::HeartbeatResponse* heartbeat_res);
  ::zjchain::dht::protobuf::HeartbeatResponse* unsafe_arena_release_heartbeat_res();

  // optional .zjchain.dht.protobuf.TimerRequest timer = 8;
  bool has_timer() const;
  private:
  bool _internal_has_timer() const;
  public:
  void clear_timer();
  const ::zjchain::dht::protobuf::TimerRequest& timer() const;
  PROTOBUF_NODISCARD ::zjchain::dht::protobuf::TimerRequest* release_timer();
  ::zjchain::dht::protobuf::TimerRequest* mutable_timer();
  void set_allocated_timer(::zjchain::dht::protobuf::TimerRequest* timer);
  private:
  const ::zjchain::dht::protobuf::TimerRequest& _internal_timer() const;
  ::zjchain::dht::protobuf::TimerRequest* _internal_mutable_timer();
  public:
  void unsafe_arena_set_allocated_timer(
      ::zjchain::dht::protobuf::TimerRequest* timer);
  ::zjchain::dht::protobuf::TimerRequest* unsafe_arena_release_timer();

  // @@protoc_insertion_point(class_scope:zjchain.dht.protobuf.DhtMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::zjchain::dht::protobuf::BootstrapRequest* bootstrap_req_;
  ::zjchain::dht::protobuf::BootstrapResponse* bootstrap_res_;
  ::zjchain::dht::protobuf::RefreshNeighborsRequest* refresh_neighbors_req_;
  ::zjchain::dht::protobuf::RefreshNeighborsResponse* refresh_neighbors_res_;
  ::zjchain::dht::protobuf::ConnectReqeust* connect_req_;
  ::zjchain::dht::protobuf::HeartbeatRequest* heartbeat_req_;
  ::zjchain::dht::protobuf::HeartbeatResponse* heartbeat_res_;
  ::zjchain::dht::protobuf::TimerRequest* timer_;
  friend struct ::TableStruct_protos_2fdht_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BootstrapRequest

// optional bytes pubkey = 1;
inline bool BootstrapRequest::_internal_has_pubkey() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BootstrapRequest::has_pubkey() const {
  return _internal_has_pubkey();
}
inline void BootstrapRequest::clear_pubkey() {
  pubkey_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BootstrapRequest::pubkey() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.BootstrapRequest.pubkey)
  return _internal_pubkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BootstrapRequest::set_pubkey(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 pubkey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.BootstrapRequest.pubkey)
}
inline std::string* BootstrapRequest::mutable_pubkey() {
  std::string* _s = _internal_mutable_pubkey();
  // @@protoc_insertion_point(field_mutable:zjchain.dht.protobuf.BootstrapRequest.pubkey)
  return _s;
}
inline const std::string& BootstrapRequest::_internal_pubkey() const {
  return pubkey_.Get();
}
inline void BootstrapRequest::_internal_set_pubkey(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  pubkey_.Set(value, GetArenaForAllocation());
}
inline std::string* BootstrapRequest::_internal_mutable_pubkey() {
  _has_bits_[0] |= 0x00000001u;
  return pubkey_.Mutable(GetArenaForAllocation());
}
inline std::string* BootstrapRequest::release_pubkey() {
  // @@protoc_insertion_point(field_release:zjchain.dht.protobuf.BootstrapRequest.pubkey)
  if (!_internal_has_pubkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = pubkey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pubkey_.IsDefault()) {
    pubkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BootstrapRequest::set_allocated_pubkey(std::string* pubkey) {
  if (pubkey != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pubkey_.SetAllocated(pubkey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pubkey_.IsDefault()) {
    pubkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zjchain.dht.protobuf.BootstrapRequest.pubkey)
}

// optional string public_ip = 2;
inline bool BootstrapRequest::_internal_has_public_ip() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BootstrapRequest::has_public_ip() const {
  return _internal_has_public_ip();
}
inline void BootstrapRequest::clear_public_ip() {
  public_ip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BootstrapRequest::public_ip() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.BootstrapRequest.public_ip)
  return _internal_public_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BootstrapRequest::set_public_ip(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 public_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.BootstrapRequest.public_ip)
}
inline std::string* BootstrapRequest::mutable_public_ip() {
  std::string* _s = _internal_mutable_public_ip();
  // @@protoc_insertion_point(field_mutable:zjchain.dht.protobuf.BootstrapRequest.public_ip)
  return _s;
}
inline const std::string& BootstrapRequest::_internal_public_ip() const {
  return public_ip_.Get();
}
inline void BootstrapRequest::_internal_set_public_ip(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  public_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* BootstrapRequest::_internal_mutable_public_ip() {
  _has_bits_[0] |= 0x00000002u;
  return public_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* BootstrapRequest::release_public_ip() {
  // @@protoc_insertion_point(field_release:zjchain.dht.protobuf.BootstrapRequest.public_ip)
  if (!_internal_has_public_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = public_ip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_ip_.IsDefault()) {
    public_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BootstrapRequest::set_allocated_public_ip(std::string* public_ip) {
  if (public_ip != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  public_ip_.SetAllocated(public_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_ip_.IsDefault()) {
    public_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zjchain.dht.protobuf.BootstrapRequest.public_ip)
}

// optional int32 public_port = 3;
inline bool BootstrapRequest::_internal_has_public_port() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BootstrapRequest::has_public_port() const {
  return _internal_has_public_port();
}
inline void BootstrapRequest::clear_public_port() {
  public_port_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t BootstrapRequest::_internal_public_port() const {
  return public_port_;
}
inline int32_t BootstrapRequest::public_port() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.BootstrapRequest.public_port)
  return _internal_public_port();
}
inline void BootstrapRequest::_internal_set_public_port(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  public_port_ = value;
}
inline void BootstrapRequest::set_public_port(int32_t value) {
  _internal_set_public_port(value);
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.BootstrapRequest.public_port)
}

// -------------------------------------------------------------------

// BootstrapResponse

// optional bytes pubkey = 1;
inline bool BootstrapResponse::_internal_has_pubkey() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BootstrapResponse::has_pubkey() const {
  return _internal_has_pubkey();
}
inline void BootstrapResponse::clear_pubkey() {
  pubkey_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BootstrapResponse::pubkey() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.BootstrapResponse.pubkey)
  return _internal_pubkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BootstrapResponse::set_pubkey(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 pubkey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.BootstrapResponse.pubkey)
}
inline std::string* BootstrapResponse::mutable_pubkey() {
  std::string* _s = _internal_mutable_pubkey();
  // @@protoc_insertion_point(field_mutable:zjchain.dht.protobuf.BootstrapResponse.pubkey)
  return _s;
}
inline const std::string& BootstrapResponse::_internal_pubkey() const {
  return pubkey_.Get();
}
inline void BootstrapResponse::_internal_set_pubkey(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  pubkey_.Set(value, GetArenaForAllocation());
}
inline std::string* BootstrapResponse::_internal_mutable_pubkey() {
  _has_bits_[0] |= 0x00000001u;
  return pubkey_.Mutable(GetArenaForAllocation());
}
inline std::string* BootstrapResponse::release_pubkey() {
  // @@protoc_insertion_point(field_release:zjchain.dht.protobuf.BootstrapResponse.pubkey)
  if (!_internal_has_pubkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = pubkey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pubkey_.IsDefault()) {
    pubkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BootstrapResponse::set_allocated_pubkey(std::string* pubkey) {
  if (pubkey != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pubkey_.SetAllocated(pubkey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pubkey_.IsDefault()) {
    pubkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zjchain.dht.protobuf.BootstrapResponse.pubkey)
}

// optional string public_ip = 2;
inline bool BootstrapResponse::_internal_has_public_ip() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BootstrapResponse::has_public_ip() const {
  return _internal_has_public_ip();
}
inline void BootstrapResponse::clear_public_ip() {
  public_ip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BootstrapResponse::public_ip() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.BootstrapResponse.public_ip)
  return _internal_public_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BootstrapResponse::set_public_ip(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 public_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.BootstrapResponse.public_ip)
}
inline std::string* BootstrapResponse::mutable_public_ip() {
  std::string* _s = _internal_mutable_public_ip();
  // @@protoc_insertion_point(field_mutable:zjchain.dht.protobuf.BootstrapResponse.public_ip)
  return _s;
}
inline const std::string& BootstrapResponse::_internal_public_ip() const {
  return public_ip_.Get();
}
inline void BootstrapResponse::_internal_set_public_ip(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  public_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* BootstrapResponse::_internal_mutable_public_ip() {
  _has_bits_[0] |= 0x00000002u;
  return public_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* BootstrapResponse::release_public_ip() {
  // @@protoc_insertion_point(field_release:zjchain.dht.protobuf.BootstrapResponse.public_ip)
  if (!_internal_has_public_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = public_ip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_ip_.IsDefault()) {
    public_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BootstrapResponse::set_allocated_public_ip(std::string* public_ip) {
  if (public_ip != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  public_ip_.SetAllocated(public_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_ip_.IsDefault()) {
    public_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zjchain.dht.protobuf.BootstrapResponse.public_ip)
}

// optional int32 public_port = 3;
inline bool BootstrapResponse::_internal_has_public_port() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BootstrapResponse::has_public_port() const {
  return _internal_has_public_port();
}
inline void BootstrapResponse::clear_public_port() {
  public_port_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t BootstrapResponse::_internal_public_port() const {
  return public_port_;
}
inline int32_t BootstrapResponse::public_port() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.BootstrapResponse.public_port)
  return _internal_public_port();
}
inline void BootstrapResponse::_internal_set_public_port(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  public_port_ = value;
}
inline void BootstrapResponse::set_public_port(int32_t value) {
  _internal_set_public_port(value);
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.BootstrapResponse.public_port)
}

// -------------------------------------------------------------------

// NodeInfo

// optional bytes public_ip = 1;
inline bool NodeInfo::_internal_has_public_ip() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NodeInfo::has_public_ip() const {
  return _internal_has_public_ip();
}
inline void NodeInfo::clear_public_ip() {
  public_ip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NodeInfo::public_ip() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.NodeInfo.public_ip)
  return _internal_public_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo::set_public_ip(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 public_ip_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.NodeInfo.public_ip)
}
inline std::string* NodeInfo::mutable_public_ip() {
  std::string* _s = _internal_mutable_public_ip();
  // @@protoc_insertion_point(field_mutable:zjchain.dht.protobuf.NodeInfo.public_ip)
  return _s;
}
inline const std::string& NodeInfo::_internal_public_ip() const {
  return public_ip_.Get();
}
inline void NodeInfo::_internal_set_public_ip(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  public_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeInfo::_internal_mutable_public_ip() {
  _has_bits_[0] |= 0x00000001u;
  return public_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeInfo::release_public_ip() {
  // @@protoc_insertion_point(field_release:zjchain.dht.protobuf.NodeInfo.public_ip)
  if (!_internal_has_public_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = public_ip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_ip_.IsDefault()) {
    public_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NodeInfo::set_allocated_public_ip(std::string* public_ip) {
  if (public_ip != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  public_ip_.SetAllocated(public_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_ip_.IsDefault()) {
    public_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zjchain.dht.protobuf.NodeInfo.public_ip)
}

// optional int32 public_port = 2;
inline bool NodeInfo::_internal_has_public_port() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NodeInfo::has_public_port() const {
  return _internal_has_public_port();
}
inline void NodeInfo::clear_public_port() {
  public_port_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t NodeInfo::_internal_public_port() const {
  return public_port_;
}
inline int32_t NodeInfo::public_port() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.NodeInfo.public_port)
  return _internal_public_port();
}
inline void NodeInfo::_internal_set_public_port(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  public_port_ = value;
}
inline void NodeInfo::set_public_port(int32_t value) {
  _internal_set_public_port(value);
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.NodeInfo.public_port)
}

// optional bytes pubkey = 3;
inline bool NodeInfo::_internal_has_pubkey() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NodeInfo::has_pubkey() const {
  return _internal_has_pubkey();
}
inline void NodeInfo::clear_pubkey() {
  pubkey_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NodeInfo::pubkey() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.NodeInfo.pubkey)
  return _internal_pubkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo::set_pubkey(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 pubkey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.NodeInfo.pubkey)
}
inline std::string* NodeInfo::mutable_pubkey() {
  std::string* _s = _internal_mutable_pubkey();
  // @@protoc_insertion_point(field_mutable:zjchain.dht.protobuf.NodeInfo.pubkey)
  return _s;
}
inline const std::string& NodeInfo::_internal_pubkey() const {
  return pubkey_.Get();
}
inline void NodeInfo::_internal_set_pubkey(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  pubkey_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeInfo::_internal_mutable_pubkey() {
  _has_bits_[0] |= 0x00000002u;
  return pubkey_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeInfo::release_pubkey() {
  // @@protoc_insertion_point(field_release:zjchain.dht.protobuf.NodeInfo.pubkey)
  if (!_internal_has_pubkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = pubkey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pubkey_.IsDefault()) {
    pubkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NodeInfo::set_allocated_pubkey(std::string* pubkey) {
  if (pubkey != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pubkey_.SetAllocated(pubkey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pubkey_.IsDefault()) {
    pubkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zjchain.dht.protobuf.NodeInfo.pubkey)
}

// optional int32 sharding_id = 4;
inline bool NodeInfo::_internal_has_sharding_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NodeInfo::has_sharding_id() const {
  return _internal_has_sharding_id();
}
inline void NodeInfo::clear_sharding_id() {
  sharding_id_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t NodeInfo::_internal_sharding_id() const {
  return sharding_id_;
}
inline int32_t NodeInfo::sharding_id() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.NodeInfo.sharding_id)
  return _internal_sharding_id();
}
inline void NodeInfo::_internal_set_sharding_id(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  sharding_id_ = value;
}
inline void NodeInfo::set_sharding_id(int32_t value) {
  _internal_set_sharding_id(value);
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.NodeInfo.sharding_id)
}

// -------------------------------------------------------------------

// RefreshNeighborsRequest

// optional uint32 count = 1;
inline bool RefreshNeighborsRequest::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RefreshNeighborsRequest::has_count() const {
  return _internal_has_count();
}
inline void RefreshNeighborsRequest::clear_count() {
  count_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t RefreshNeighborsRequest::_internal_count() const {
  return count_;
}
inline uint32_t RefreshNeighborsRequest::count() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.RefreshNeighborsRequest.count)
  return _internal_count();
}
inline void RefreshNeighborsRequest::_internal_set_count(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  count_ = value;
}
inline void RefreshNeighborsRequest::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.RefreshNeighborsRequest.count)
}

// repeated uint64 bloomfilter = 2;
inline int RefreshNeighborsRequest::_internal_bloomfilter_size() const {
  return bloomfilter_.size();
}
inline int RefreshNeighborsRequest::bloomfilter_size() const {
  return _internal_bloomfilter_size();
}
inline void RefreshNeighborsRequest::clear_bloomfilter() {
  bloomfilter_.Clear();
}
inline uint64_t RefreshNeighborsRequest::_internal_bloomfilter(int index) const {
  return bloomfilter_.Get(index);
}
inline uint64_t RefreshNeighborsRequest::bloomfilter(int index) const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.RefreshNeighborsRequest.bloomfilter)
  return _internal_bloomfilter(index);
}
inline void RefreshNeighborsRequest::set_bloomfilter(int index, uint64_t value) {
  bloomfilter_.Set(index, value);
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.RefreshNeighborsRequest.bloomfilter)
}
inline void RefreshNeighborsRequest::_internal_add_bloomfilter(uint64_t value) {
  bloomfilter_.Add(value);
}
inline void RefreshNeighborsRequest::add_bloomfilter(uint64_t value) {
  _internal_add_bloomfilter(value);
  // @@protoc_insertion_point(field_add:zjchain.dht.protobuf.RefreshNeighborsRequest.bloomfilter)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
RefreshNeighborsRequest::_internal_bloomfilter() const {
  return bloomfilter_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
RefreshNeighborsRequest::bloomfilter() const {
  // @@protoc_insertion_point(field_list:zjchain.dht.protobuf.RefreshNeighborsRequest.bloomfilter)
  return _internal_bloomfilter();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
RefreshNeighborsRequest::_internal_mutable_bloomfilter() {
  return &bloomfilter_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
RefreshNeighborsRequest::mutable_bloomfilter() {
  // @@protoc_insertion_point(field_mutable_list:zjchain.dht.protobuf.RefreshNeighborsRequest.bloomfilter)
  return _internal_mutable_bloomfilter();
}

// optional bytes pubkey = 3;
inline bool RefreshNeighborsRequest::_internal_has_pubkey() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RefreshNeighborsRequest::has_pubkey() const {
  return _internal_has_pubkey();
}
inline void RefreshNeighborsRequest::clear_pubkey() {
  pubkey_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RefreshNeighborsRequest::pubkey() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.RefreshNeighborsRequest.pubkey)
  return _internal_pubkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RefreshNeighborsRequest::set_pubkey(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 pubkey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.RefreshNeighborsRequest.pubkey)
}
inline std::string* RefreshNeighborsRequest::mutable_pubkey() {
  std::string* _s = _internal_mutable_pubkey();
  // @@protoc_insertion_point(field_mutable:zjchain.dht.protobuf.RefreshNeighborsRequest.pubkey)
  return _s;
}
inline const std::string& RefreshNeighborsRequest::_internal_pubkey() const {
  return pubkey_.Get();
}
inline void RefreshNeighborsRequest::_internal_set_pubkey(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  pubkey_.Set(value, GetArenaForAllocation());
}
inline std::string* RefreshNeighborsRequest::_internal_mutable_pubkey() {
  _has_bits_[0] |= 0x00000001u;
  return pubkey_.Mutable(GetArenaForAllocation());
}
inline std::string* RefreshNeighborsRequest::release_pubkey() {
  // @@protoc_insertion_point(field_release:zjchain.dht.protobuf.RefreshNeighborsRequest.pubkey)
  if (!_internal_has_pubkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = pubkey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pubkey_.IsDefault()) {
    pubkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RefreshNeighborsRequest::set_allocated_pubkey(std::string* pubkey) {
  if (pubkey != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pubkey_.SetAllocated(pubkey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pubkey_.IsDefault()) {
    pubkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zjchain.dht.protobuf.RefreshNeighborsRequest.pubkey)
}

// optional string public_ip = 4;
inline bool RefreshNeighborsRequest::_internal_has_public_ip() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RefreshNeighborsRequest::has_public_ip() const {
  return _internal_has_public_ip();
}
inline void RefreshNeighborsRequest::clear_public_ip() {
  public_ip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RefreshNeighborsRequest::public_ip() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.RefreshNeighborsRequest.public_ip)
  return _internal_public_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RefreshNeighborsRequest::set_public_ip(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 public_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.RefreshNeighborsRequest.public_ip)
}
inline std::string* RefreshNeighborsRequest::mutable_public_ip() {
  std::string* _s = _internal_mutable_public_ip();
  // @@protoc_insertion_point(field_mutable:zjchain.dht.protobuf.RefreshNeighborsRequest.public_ip)
  return _s;
}
inline const std::string& RefreshNeighborsRequest::_internal_public_ip() const {
  return public_ip_.Get();
}
inline void RefreshNeighborsRequest::_internal_set_public_ip(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  public_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* RefreshNeighborsRequest::_internal_mutable_public_ip() {
  _has_bits_[0] |= 0x00000002u;
  return public_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* RefreshNeighborsRequest::release_public_ip() {
  // @@protoc_insertion_point(field_release:zjchain.dht.protobuf.RefreshNeighborsRequest.public_ip)
  if (!_internal_has_public_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = public_ip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_ip_.IsDefault()) {
    public_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RefreshNeighborsRequest::set_allocated_public_ip(std::string* public_ip) {
  if (public_ip != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  public_ip_.SetAllocated(public_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_ip_.IsDefault()) {
    public_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zjchain.dht.protobuf.RefreshNeighborsRequest.public_ip)
}

// optional int32 public_port = 5;
inline bool RefreshNeighborsRequest::_internal_has_public_port() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RefreshNeighborsRequest::has_public_port() const {
  return _internal_has_public_port();
}
inline void RefreshNeighborsRequest::clear_public_port() {
  public_port_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t RefreshNeighborsRequest::_internal_public_port() const {
  return public_port_;
}
inline int32_t RefreshNeighborsRequest::public_port() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.RefreshNeighborsRequest.public_port)
  return _internal_public_port();
}
inline void RefreshNeighborsRequest::_internal_set_public_port(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  public_port_ = value;
}
inline void RefreshNeighborsRequest::set_public_port(int32_t value) {
  _internal_set_public_port(value);
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.RefreshNeighborsRequest.public_port)
}

// repeated bytes ids = 6;
inline int RefreshNeighborsRequest::_internal_ids_size() const {
  return ids_.size();
}
inline int RefreshNeighborsRequest::ids_size() const {
  return _internal_ids_size();
}
inline void RefreshNeighborsRequest::clear_ids() {
  ids_.Clear();
}
inline std::string* RefreshNeighborsRequest::add_ids() {
  std::string* _s = _internal_add_ids();
  // @@protoc_insertion_point(field_add_mutable:zjchain.dht.protobuf.RefreshNeighborsRequest.ids)
  return _s;
}
inline const std::string& RefreshNeighborsRequest::_internal_ids(int index) const {
  return ids_.Get(index);
}
inline const std::string& RefreshNeighborsRequest::ids(int index) const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.RefreshNeighborsRequest.ids)
  return _internal_ids(index);
}
inline std::string* RefreshNeighborsRequest::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:zjchain.dht.protobuf.RefreshNeighborsRequest.ids)
  return ids_.Mutable(index);
}
inline void RefreshNeighborsRequest::set_ids(int index, const std::string& value) {
  ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.RefreshNeighborsRequest.ids)
}
inline void RefreshNeighborsRequest::set_ids(int index, std::string&& value) {
  ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.RefreshNeighborsRequest.ids)
}
inline void RefreshNeighborsRequest::set_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zjchain.dht.protobuf.RefreshNeighborsRequest.ids)
}
inline void RefreshNeighborsRequest::set_ids(int index, const void* value, size_t size) {
  ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zjchain.dht.protobuf.RefreshNeighborsRequest.ids)
}
inline std::string* RefreshNeighborsRequest::_internal_add_ids() {
  return ids_.Add();
}
inline void RefreshNeighborsRequest::add_ids(const std::string& value) {
  ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zjchain.dht.protobuf.RefreshNeighborsRequest.ids)
}
inline void RefreshNeighborsRequest::add_ids(std::string&& value) {
  ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zjchain.dht.protobuf.RefreshNeighborsRequest.ids)
}
inline void RefreshNeighborsRequest::add_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zjchain.dht.protobuf.RefreshNeighborsRequest.ids)
}
inline void RefreshNeighborsRequest::add_ids(const void* value, size_t size) {
  ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zjchain.dht.protobuf.RefreshNeighborsRequest.ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RefreshNeighborsRequest::ids() const {
  // @@protoc_insertion_point(field_list:zjchain.dht.protobuf.RefreshNeighborsRequest.ids)
  return ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RefreshNeighborsRequest::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:zjchain.dht.protobuf.RefreshNeighborsRequest.ids)
  return &ids_;
}

// -------------------------------------------------------------------

// RefreshNeighborsResponse

// repeated .zjchain.dht.protobuf.NodeInfo nodes = 1;
inline int RefreshNeighborsResponse::_internal_nodes_size() const {
  return nodes_.size();
}
inline int RefreshNeighborsResponse::nodes_size() const {
  return _internal_nodes_size();
}
inline void RefreshNeighborsResponse::clear_nodes() {
  nodes_.Clear();
}
inline ::zjchain::dht::protobuf::NodeInfo* RefreshNeighborsResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:zjchain.dht.protobuf.RefreshNeighborsResponse.nodes)
  return nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zjchain::dht::protobuf::NodeInfo >*
RefreshNeighborsResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:zjchain.dht.protobuf.RefreshNeighborsResponse.nodes)
  return &nodes_;
}
inline const ::zjchain::dht::protobuf::NodeInfo& RefreshNeighborsResponse::_internal_nodes(int index) const {
  return nodes_.Get(index);
}
inline const ::zjchain::dht::protobuf::NodeInfo& RefreshNeighborsResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.RefreshNeighborsResponse.nodes)
  return _internal_nodes(index);
}
inline ::zjchain::dht::protobuf::NodeInfo* RefreshNeighborsResponse::_internal_add_nodes() {
  return nodes_.Add();
}
inline ::zjchain::dht::protobuf::NodeInfo* RefreshNeighborsResponse::add_nodes() {
  ::zjchain::dht::protobuf::NodeInfo* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:zjchain.dht.protobuf.RefreshNeighborsResponse.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zjchain::dht::protobuf::NodeInfo >&
RefreshNeighborsResponse::nodes() const {
  // @@protoc_insertion_point(field_list:zjchain.dht.protobuf.RefreshNeighborsResponse.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// HeartbeatRequest

// optional uint64 dht_key_hash = 1;
inline bool HeartbeatRequest::_internal_has_dht_key_hash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HeartbeatRequest::has_dht_key_hash() const {
  return _internal_has_dht_key_hash();
}
inline void HeartbeatRequest::clear_dht_key_hash() {
  dht_key_hash_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t HeartbeatRequest::_internal_dht_key_hash() const {
  return dht_key_hash_;
}
inline uint64_t HeartbeatRequest::dht_key_hash() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.HeartbeatRequest.dht_key_hash)
  return _internal_dht_key_hash();
}
inline void HeartbeatRequest::_internal_set_dht_key_hash(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  dht_key_hash_ = value;
}
inline void HeartbeatRequest::set_dht_key_hash(uint64_t value) {
  _internal_set_dht_key_hash(value);
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.HeartbeatRequest.dht_key_hash)
}

// -------------------------------------------------------------------

// HeartbeatResponse

// optional uint64 dht_key_hash = 1;
inline bool HeartbeatResponse::_internal_has_dht_key_hash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HeartbeatResponse::has_dht_key_hash() const {
  return _internal_has_dht_key_hash();
}
inline void HeartbeatResponse::clear_dht_key_hash() {
  dht_key_hash_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t HeartbeatResponse::_internal_dht_key_hash() const {
  return dht_key_hash_;
}
inline uint64_t HeartbeatResponse::dht_key_hash() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.HeartbeatResponse.dht_key_hash)
  return _internal_dht_key_hash();
}
inline void HeartbeatResponse::_internal_set_dht_key_hash(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  dht_key_hash_ = value;
}
inline void HeartbeatResponse::set_dht_key_hash(uint64_t value) {
  _internal_set_dht_key_hash(value);
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.HeartbeatResponse.dht_key_hash)
}

// -------------------------------------------------------------------

// ConnectReqeust

// optional bytes pubkey = 1;
inline bool ConnectReqeust::_internal_has_pubkey() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConnectReqeust::has_pubkey() const {
  return _internal_has_pubkey();
}
inline void ConnectReqeust::clear_pubkey() {
  pubkey_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConnectReqeust::pubkey() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.ConnectReqeust.pubkey)
  return _internal_pubkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectReqeust::set_pubkey(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 pubkey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.ConnectReqeust.pubkey)
}
inline std::string* ConnectReqeust::mutable_pubkey() {
  std::string* _s = _internal_mutable_pubkey();
  // @@protoc_insertion_point(field_mutable:zjchain.dht.protobuf.ConnectReqeust.pubkey)
  return _s;
}
inline const std::string& ConnectReqeust::_internal_pubkey() const {
  return pubkey_.Get();
}
inline void ConnectReqeust::_internal_set_pubkey(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  pubkey_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectReqeust::_internal_mutable_pubkey() {
  _has_bits_[0] |= 0x00000001u;
  return pubkey_.Mutable(GetArenaForAllocation());
}
inline std::string* ConnectReqeust::release_pubkey() {
  // @@protoc_insertion_point(field_release:zjchain.dht.protobuf.ConnectReqeust.pubkey)
  if (!_internal_has_pubkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = pubkey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pubkey_.IsDefault()) {
    pubkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConnectReqeust::set_allocated_pubkey(std::string* pubkey) {
  if (pubkey != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pubkey_.SetAllocated(pubkey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pubkey_.IsDefault()) {
    pubkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zjchain.dht.protobuf.ConnectReqeust.pubkey)
}

// optional bool is_response = 2;
inline bool ConnectReqeust::_internal_has_is_response() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConnectReqeust::has_is_response() const {
  return _internal_has_is_response();
}
inline void ConnectReqeust::clear_is_response() {
  is_response_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ConnectReqeust::_internal_is_response() const {
  return is_response_;
}
inline bool ConnectReqeust::is_response() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.ConnectReqeust.is_response)
  return _internal_is_response();
}
inline void ConnectReqeust::_internal_set_is_response(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_response_ = value;
}
inline void ConnectReqeust::set_is_response(bool value) {
  _internal_set_is_response(value);
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.ConnectReqeust.is_response)
}

// optional string public_ip = 3;
inline bool ConnectReqeust::_internal_has_public_ip() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConnectReqeust::has_public_ip() const {
  return _internal_has_public_ip();
}
inline void ConnectReqeust::clear_public_ip() {
  public_ip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConnectReqeust::public_ip() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.ConnectReqeust.public_ip)
  return _internal_public_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectReqeust::set_public_ip(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 public_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.ConnectReqeust.public_ip)
}
inline std::string* ConnectReqeust::mutable_public_ip() {
  std::string* _s = _internal_mutable_public_ip();
  // @@protoc_insertion_point(field_mutable:zjchain.dht.protobuf.ConnectReqeust.public_ip)
  return _s;
}
inline const std::string& ConnectReqeust::_internal_public_ip() const {
  return public_ip_.Get();
}
inline void ConnectReqeust::_internal_set_public_ip(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  public_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectReqeust::_internal_mutable_public_ip() {
  _has_bits_[0] |= 0x00000002u;
  return public_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* ConnectReqeust::release_public_ip() {
  // @@protoc_insertion_point(field_release:zjchain.dht.protobuf.ConnectReqeust.public_ip)
  if (!_internal_has_public_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = public_ip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_ip_.IsDefault()) {
    public_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConnectReqeust::set_allocated_public_ip(std::string* public_ip) {
  if (public_ip != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  public_ip_.SetAllocated(public_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_ip_.IsDefault()) {
    public_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zjchain.dht.protobuf.ConnectReqeust.public_ip)
}

// optional int32 public_port = 4;
inline bool ConnectReqeust::_internal_has_public_port() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConnectReqeust::has_public_port() const {
  return _internal_has_public_port();
}
inline void ConnectReqeust::clear_public_port() {
  public_port_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t ConnectReqeust::_internal_public_port() const {
  return public_port_;
}
inline int32_t ConnectReqeust::public_port() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.ConnectReqeust.public_port)
  return _internal_public_port();
}
inline void ConnectReqeust::_internal_set_public_port(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  public_port_ = value;
}
inline void ConnectReqeust::set_public_port(int32_t value) {
  _internal_set_public_port(value);
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.ConnectReqeust.public_port)
}

// -------------------------------------------------------------------

// TimerRequest

// optional uint64 tm_milli = 1;
inline bool TimerRequest::_internal_has_tm_milli() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TimerRequest::has_tm_milli() const {
  return _internal_has_tm_milli();
}
inline void TimerRequest::clear_tm_milli() {
  tm_milli_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t TimerRequest::_internal_tm_milli() const {
  return tm_milli_;
}
inline uint64_t TimerRequest::tm_milli() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.TimerRequest.tm_milli)
  return _internal_tm_milli();
}
inline void TimerRequest::_internal_set_tm_milli(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  tm_milli_ = value;
}
inline void TimerRequest::set_tm_milli(uint64_t value) {
  _internal_set_tm_milli(value);
  // @@protoc_insertion_point(field_set:zjchain.dht.protobuf.TimerRequest.tm_milli)
}

// -------------------------------------------------------------------

// DhtMessage

// optional .zjchain.dht.protobuf.BootstrapRequest bootstrap_req = 1;
inline bool DhtMessage::_internal_has_bootstrap_req() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || bootstrap_req_ != nullptr);
  return value;
}
inline bool DhtMessage::has_bootstrap_req() const {
  return _internal_has_bootstrap_req();
}
inline void DhtMessage::clear_bootstrap_req() {
  if (bootstrap_req_ != nullptr) bootstrap_req_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::zjchain::dht::protobuf::BootstrapRequest& DhtMessage::_internal_bootstrap_req() const {
  const ::zjchain::dht::protobuf::BootstrapRequest* p = bootstrap_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::zjchain::dht::protobuf::BootstrapRequest&>(
      ::zjchain::dht::protobuf::_BootstrapRequest_default_instance_);
}
inline const ::zjchain::dht::protobuf::BootstrapRequest& DhtMessage::bootstrap_req() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.DhtMessage.bootstrap_req)
  return _internal_bootstrap_req();
}
inline void DhtMessage::unsafe_arena_set_allocated_bootstrap_req(
    ::zjchain::dht::protobuf::BootstrapRequest* bootstrap_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bootstrap_req_);
  }
  bootstrap_req_ = bootstrap_req;
  if (bootstrap_req) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zjchain.dht.protobuf.DhtMessage.bootstrap_req)
}
inline ::zjchain::dht::protobuf::BootstrapRequest* DhtMessage::release_bootstrap_req() {
  _has_bits_[0] &= ~0x00000001u;
  ::zjchain::dht::protobuf::BootstrapRequest* temp = bootstrap_req_;
  bootstrap_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zjchain::dht::protobuf::BootstrapRequest* DhtMessage::unsafe_arena_release_bootstrap_req() {
  // @@protoc_insertion_point(field_release:zjchain.dht.protobuf.DhtMessage.bootstrap_req)
  _has_bits_[0] &= ~0x00000001u;
  ::zjchain::dht::protobuf::BootstrapRequest* temp = bootstrap_req_;
  bootstrap_req_ = nullptr;
  return temp;
}
inline ::zjchain::dht::protobuf::BootstrapRequest* DhtMessage::_internal_mutable_bootstrap_req() {
  _has_bits_[0] |= 0x00000001u;
  if (bootstrap_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::zjchain::dht::protobuf::BootstrapRequest>(GetArenaForAllocation());
    bootstrap_req_ = p;
  }
  return bootstrap_req_;
}
inline ::zjchain::dht::protobuf::BootstrapRequest* DhtMessage::mutable_bootstrap_req() {
  ::zjchain::dht::protobuf::BootstrapRequest* _msg = _internal_mutable_bootstrap_req();
  // @@protoc_insertion_point(field_mutable:zjchain.dht.protobuf.DhtMessage.bootstrap_req)
  return _msg;
}
inline void DhtMessage::set_allocated_bootstrap_req(::zjchain::dht::protobuf::BootstrapRequest* bootstrap_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bootstrap_req_;
  }
  if (bootstrap_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bootstrap_req);
    if (message_arena != submessage_arena) {
      bootstrap_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bootstrap_req, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  bootstrap_req_ = bootstrap_req;
  // @@protoc_insertion_point(field_set_allocated:zjchain.dht.protobuf.DhtMessage.bootstrap_req)
}

// optional .zjchain.dht.protobuf.BootstrapResponse bootstrap_res = 2;
inline bool DhtMessage::_internal_has_bootstrap_res() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || bootstrap_res_ != nullptr);
  return value;
}
inline bool DhtMessage::has_bootstrap_res() const {
  return _internal_has_bootstrap_res();
}
inline void DhtMessage::clear_bootstrap_res() {
  if (bootstrap_res_ != nullptr) bootstrap_res_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::zjchain::dht::protobuf::BootstrapResponse& DhtMessage::_internal_bootstrap_res() const {
  const ::zjchain::dht::protobuf::BootstrapResponse* p = bootstrap_res_;
  return p != nullptr ? *p : reinterpret_cast<const ::zjchain::dht::protobuf::BootstrapResponse&>(
      ::zjchain::dht::protobuf::_BootstrapResponse_default_instance_);
}
inline const ::zjchain::dht::protobuf::BootstrapResponse& DhtMessage::bootstrap_res() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.DhtMessage.bootstrap_res)
  return _internal_bootstrap_res();
}
inline void DhtMessage::unsafe_arena_set_allocated_bootstrap_res(
    ::zjchain::dht::protobuf::BootstrapResponse* bootstrap_res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bootstrap_res_);
  }
  bootstrap_res_ = bootstrap_res;
  if (bootstrap_res) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zjchain.dht.protobuf.DhtMessage.bootstrap_res)
}
inline ::zjchain::dht::protobuf::BootstrapResponse* DhtMessage::release_bootstrap_res() {
  _has_bits_[0] &= ~0x00000002u;
  ::zjchain::dht::protobuf::BootstrapResponse* temp = bootstrap_res_;
  bootstrap_res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zjchain::dht::protobuf::BootstrapResponse* DhtMessage::unsafe_arena_release_bootstrap_res() {
  // @@protoc_insertion_point(field_release:zjchain.dht.protobuf.DhtMessage.bootstrap_res)
  _has_bits_[0] &= ~0x00000002u;
  ::zjchain::dht::protobuf::BootstrapResponse* temp = bootstrap_res_;
  bootstrap_res_ = nullptr;
  return temp;
}
inline ::zjchain::dht::protobuf::BootstrapResponse* DhtMessage::_internal_mutable_bootstrap_res() {
  _has_bits_[0] |= 0x00000002u;
  if (bootstrap_res_ == nullptr) {
    auto* p = CreateMaybeMessage<::zjchain::dht::protobuf::BootstrapResponse>(GetArenaForAllocation());
    bootstrap_res_ = p;
  }
  return bootstrap_res_;
}
inline ::zjchain::dht::protobuf::BootstrapResponse* DhtMessage::mutable_bootstrap_res() {
  ::zjchain::dht::protobuf::BootstrapResponse* _msg = _internal_mutable_bootstrap_res();
  // @@protoc_insertion_point(field_mutable:zjchain.dht.protobuf.DhtMessage.bootstrap_res)
  return _msg;
}
inline void DhtMessage::set_allocated_bootstrap_res(::zjchain::dht::protobuf::BootstrapResponse* bootstrap_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bootstrap_res_;
  }
  if (bootstrap_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bootstrap_res);
    if (message_arena != submessage_arena) {
      bootstrap_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bootstrap_res, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  bootstrap_res_ = bootstrap_res;
  // @@protoc_insertion_point(field_set_allocated:zjchain.dht.protobuf.DhtMessage.bootstrap_res)
}

// optional .zjchain.dht.protobuf.RefreshNeighborsRequest refresh_neighbors_req = 3;
inline bool DhtMessage::_internal_has_refresh_neighbors_req() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || refresh_neighbors_req_ != nullptr);
  return value;
}
inline bool DhtMessage::has_refresh_neighbors_req() const {
  return _internal_has_refresh_neighbors_req();
}
inline void DhtMessage::clear_refresh_neighbors_req() {
  if (refresh_neighbors_req_ != nullptr) refresh_neighbors_req_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::zjchain::dht::protobuf::RefreshNeighborsRequest& DhtMessage::_internal_refresh_neighbors_req() const {
  const ::zjchain::dht::protobuf::RefreshNeighborsRequest* p = refresh_neighbors_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::zjchain::dht::protobuf::RefreshNeighborsRequest&>(
      ::zjchain::dht::protobuf::_RefreshNeighborsRequest_default_instance_);
}
inline const ::zjchain::dht::protobuf::RefreshNeighborsRequest& DhtMessage::refresh_neighbors_req() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.DhtMessage.refresh_neighbors_req)
  return _internal_refresh_neighbors_req();
}
inline void DhtMessage::unsafe_arena_set_allocated_refresh_neighbors_req(
    ::zjchain::dht::protobuf::RefreshNeighborsRequest* refresh_neighbors_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(refresh_neighbors_req_);
  }
  refresh_neighbors_req_ = refresh_neighbors_req;
  if (refresh_neighbors_req) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zjchain.dht.protobuf.DhtMessage.refresh_neighbors_req)
}
inline ::zjchain::dht::protobuf::RefreshNeighborsRequest* DhtMessage::release_refresh_neighbors_req() {
  _has_bits_[0] &= ~0x00000004u;
  ::zjchain::dht::protobuf::RefreshNeighborsRequest* temp = refresh_neighbors_req_;
  refresh_neighbors_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zjchain::dht::protobuf::RefreshNeighborsRequest* DhtMessage::unsafe_arena_release_refresh_neighbors_req() {
  // @@protoc_insertion_point(field_release:zjchain.dht.protobuf.DhtMessage.refresh_neighbors_req)
  _has_bits_[0] &= ~0x00000004u;
  ::zjchain::dht::protobuf::RefreshNeighborsRequest* temp = refresh_neighbors_req_;
  refresh_neighbors_req_ = nullptr;
  return temp;
}
inline ::zjchain::dht::protobuf::RefreshNeighborsRequest* DhtMessage::_internal_mutable_refresh_neighbors_req() {
  _has_bits_[0] |= 0x00000004u;
  if (refresh_neighbors_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::zjchain::dht::protobuf::RefreshNeighborsRequest>(GetArenaForAllocation());
    refresh_neighbors_req_ = p;
  }
  return refresh_neighbors_req_;
}
inline ::zjchain::dht::protobuf::RefreshNeighborsRequest* DhtMessage::mutable_refresh_neighbors_req() {
  ::zjchain::dht::protobuf::RefreshNeighborsRequest* _msg = _internal_mutable_refresh_neighbors_req();
  // @@protoc_insertion_point(field_mutable:zjchain.dht.protobuf.DhtMessage.refresh_neighbors_req)
  return _msg;
}
inline void DhtMessage::set_allocated_refresh_neighbors_req(::zjchain::dht::protobuf::RefreshNeighborsRequest* refresh_neighbors_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete refresh_neighbors_req_;
  }
  if (refresh_neighbors_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(refresh_neighbors_req);
    if (message_arena != submessage_arena) {
      refresh_neighbors_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, refresh_neighbors_req, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  refresh_neighbors_req_ = refresh_neighbors_req;
  // @@protoc_insertion_point(field_set_allocated:zjchain.dht.protobuf.DhtMessage.refresh_neighbors_req)
}

// optional .zjchain.dht.protobuf.RefreshNeighborsResponse refresh_neighbors_res = 4;
inline bool DhtMessage::_internal_has_refresh_neighbors_res() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || refresh_neighbors_res_ != nullptr);
  return value;
}
inline bool DhtMessage::has_refresh_neighbors_res() const {
  return _internal_has_refresh_neighbors_res();
}
inline void DhtMessage::clear_refresh_neighbors_res() {
  if (refresh_neighbors_res_ != nullptr) refresh_neighbors_res_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::zjchain::dht::protobuf::RefreshNeighborsResponse& DhtMessage::_internal_refresh_neighbors_res() const {
  const ::zjchain::dht::protobuf::RefreshNeighborsResponse* p = refresh_neighbors_res_;
  return p != nullptr ? *p : reinterpret_cast<const ::zjchain::dht::protobuf::RefreshNeighborsResponse&>(
      ::zjchain::dht::protobuf::_RefreshNeighborsResponse_default_instance_);
}
inline const ::zjchain::dht::protobuf::RefreshNeighborsResponse& DhtMessage::refresh_neighbors_res() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.DhtMessage.refresh_neighbors_res)
  return _internal_refresh_neighbors_res();
}
inline void DhtMessage::unsafe_arena_set_allocated_refresh_neighbors_res(
    ::zjchain::dht::protobuf::RefreshNeighborsResponse* refresh_neighbors_res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(refresh_neighbors_res_);
  }
  refresh_neighbors_res_ = refresh_neighbors_res;
  if (refresh_neighbors_res) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zjchain.dht.protobuf.DhtMessage.refresh_neighbors_res)
}
inline ::zjchain::dht::protobuf::RefreshNeighborsResponse* DhtMessage::release_refresh_neighbors_res() {
  _has_bits_[0] &= ~0x00000008u;
  ::zjchain::dht::protobuf::RefreshNeighborsResponse* temp = refresh_neighbors_res_;
  refresh_neighbors_res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zjchain::dht::protobuf::RefreshNeighborsResponse* DhtMessage::unsafe_arena_release_refresh_neighbors_res() {
  // @@protoc_insertion_point(field_release:zjchain.dht.protobuf.DhtMessage.refresh_neighbors_res)
  _has_bits_[0] &= ~0x00000008u;
  ::zjchain::dht::protobuf::RefreshNeighborsResponse* temp = refresh_neighbors_res_;
  refresh_neighbors_res_ = nullptr;
  return temp;
}
inline ::zjchain::dht::protobuf::RefreshNeighborsResponse* DhtMessage::_internal_mutable_refresh_neighbors_res() {
  _has_bits_[0] |= 0x00000008u;
  if (refresh_neighbors_res_ == nullptr) {
    auto* p = CreateMaybeMessage<::zjchain::dht::protobuf::RefreshNeighborsResponse>(GetArenaForAllocation());
    refresh_neighbors_res_ = p;
  }
  return refresh_neighbors_res_;
}
inline ::zjchain::dht::protobuf::RefreshNeighborsResponse* DhtMessage::mutable_refresh_neighbors_res() {
  ::zjchain::dht::protobuf::RefreshNeighborsResponse* _msg = _internal_mutable_refresh_neighbors_res();
  // @@protoc_insertion_point(field_mutable:zjchain.dht.protobuf.DhtMessage.refresh_neighbors_res)
  return _msg;
}
inline void DhtMessage::set_allocated_refresh_neighbors_res(::zjchain::dht::protobuf::RefreshNeighborsResponse* refresh_neighbors_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete refresh_neighbors_res_;
  }
  if (refresh_neighbors_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(refresh_neighbors_res);
    if (message_arena != submessage_arena) {
      refresh_neighbors_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, refresh_neighbors_res, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  refresh_neighbors_res_ = refresh_neighbors_res;
  // @@protoc_insertion_point(field_set_allocated:zjchain.dht.protobuf.DhtMessage.refresh_neighbors_res)
}

// optional .zjchain.dht.protobuf.ConnectReqeust connect_req = 5;
inline bool DhtMessage::_internal_has_connect_req() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || connect_req_ != nullptr);
  return value;
}
inline bool DhtMessage::has_connect_req() const {
  return _internal_has_connect_req();
}
inline void DhtMessage::clear_connect_req() {
  if (connect_req_ != nullptr) connect_req_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::zjchain::dht::protobuf::ConnectReqeust& DhtMessage::_internal_connect_req() const {
  const ::zjchain::dht::protobuf::ConnectReqeust* p = connect_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::zjchain::dht::protobuf::ConnectReqeust&>(
      ::zjchain::dht::protobuf::_ConnectReqeust_default_instance_);
}
inline const ::zjchain::dht::protobuf::ConnectReqeust& DhtMessage::connect_req() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.DhtMessage.connect_req)
  return _internal_connect_req();
}
inline void DhtMessage::unsafe_arena_set_allocated_connect_req(
    ::zjchain::dht::protobuf::ConnectReqeust* connect_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connect_req_);
  }
  connect_req_ = connect_req;
  if (connect_req) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zjchain.dht.protobuf.DhtMessage.connect_req)
}
inline ::zjchain::dht::protobuf::ConnectReqeust* DhtMessage::release_connect_req() {
  _has_bits_[0] &= ~0x00000010u;
  ::zjchain::dht::protobuf::ConnectReqeust* temp = connect_req_;
  connect_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zjchain::dht::protobuf::ConnectReqeust* DhtMessage::unsafe_arena_release_connect_req() {
  // @@protoc_insertion_point(field_release:zjchain.dht.protobuf.DhtMessage.connect_req)
  _has_bits_[0] &= ~0x00000010u;
  ::zjchain::dht::protobuf::ConnectReqeust* temp = connect_req_;
  connect_req_ = nullptr;
  return temp;
}
inline ::zjchain::dht::protobuf::ConnectReqeust* DhtMessage::_internal_mutable_connect_req() {
  _has_bits_[0] |= 0x00000010u;
  if (connect_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::zjchain::dht::protobuf::ConnectReqeust>(GetArenaForAllocation());
    connect_req_ = p;
  }
  return connect_req_;
}
inline ::zjchain::dht::protobuf::ConnectReqeust* DhtMessage::mutable_connect_req() {
  ::zjchain::dht::protobuf::ConnectReqeust* _msg = _internal_mutable_connect_req();
  // @@protoc_insertion_point(field_mutable:zjchain.dht.protobuf.DhtMessage.connect_req)
  return _msg;
}
inline void DhtMessage::set_allocated_connect_req(::zjchain::dht::protobuf::ConnectReqeust* connect_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete connect_req_;
  }
  if (connect_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(connect_req);
    if (message_arena != submessage_arena) {
      connect_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connect_req, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  connect_req_ = connect_req;
  // @@protoc_insertion_point(field_set_allocated:zjchain.dht.protobuf.DhtMessage.connect_req)
}

// optional .zjchain.dht.protobuf.HeartbeatRequest heartbeat_req = 6;
inline bool DhtMessage::_internal_has_heartbeat_req() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || heartbeat_req_ != nullptr);
  return value;
}
inline bool DhtMessage::has_heartbeat_req() const {
  return _internal_has_heartbeat_req();
}
inline void DhtMessage::clear_heartbeat_req() {
  if (heartbeat_req_ != nullptr) heartbeat_req_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::zjchain::dht::protobuf::HeartbeatRequest& DhtMessage::_internal_heartbeat_req() const {
  const ::zjchain::dht::protobuf::HeartbeatRequest* p = heartbeat_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::zjchain::dht::protobuf::HeartbeatRequest&>(
      ::zjchain::dht::protobuf::_HeartbeatRequest_default_instance_);
}
inline const ::zjchain::dht::protobuf::HeartbeatRequest& DhtMessage::heartbeat_req() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.DhtMessage.heartbeat_req)
  return _internal_heartbeat_req();
}
inline void DhtMessage::unsafe_arena_set_allocated_heartbeat_req(
    ::zjchain::dht::protobuf::HeartbeatRequest* heartbeat_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heartbeat_req_);
  }
  heartbeat_req_ = heartbeat_req;
  if (heartbeat_req) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zjchain.dht.protobuf.DhtMessage.heartbeat_req)
}
inline ::zjchain::dht::protobuf::HeartbeatRequest* DhtMessage::release_heartbeat_req() {
  _has_bits_[0] &= ~0x00000020u;
  ::zjchain::dht::protobuf::HeartbeatRequest* temp = heartbeat_req_;
  heartbeat_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zjchain::dht::protobuf::HeartbeatRequest* DhtMessage::unsafe_arena_release_heartbeat_req() {
  // @@protoc_insertion_point(field_release:zjchain.dht.protobuf.DhtMessage.heartbeat_req)
  _has_bits_[0] &= ~0x00000020u;
  ::zjchain::dht::protobuf::HeartbeatRequest* temp = heartbeat_req_;
  heartbeat_req_ = nullptr;
  return temp;
}
inline ::zjchain::dht::protobuf::HeartbeatRequest* DhtMessage::_internal_mutable_heartbeat_req() {
  _has_bits_[0] |= 0x00000020u;
  if (heartbeat_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::zjchain::dht::protobuf::HeartbeatRequest>(GetArenaForAllocation());
    heartbeat_req_ = p;
  }
  return heartbeat_req_;
}
inline ::zjchain::dht::protobuf::HeartbeatRequest* DhtMessage::mutable_heartbeat_req() {
  ::zjchain::dht::protobuf::HeartbeatRequest* _msg = _internal_mutable_heartbeat_req();
  // @@protoc_insertion_point(field_mutable:zjchain.dht.protobuf.DhtMessage.heartbeat_req)
  return _msg;
}
inline void DhtMessage::set_allocated_heartbeat_req(::zjchain::dht::protobuf::HeartbeatRequest* heartbeat_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete heartbeat_req_;
  }
  if (heartbeat_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(heartbeat_req);
    if (message_arena != submessage_arena) {
      heartbeat_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heartbeat_req, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  heartbeat_req_ = heartbeat_req;
  // @@protoc_insertion_point(field_set_allocated:zjchain.dht.protobuf.DhtMessage.heartbeat_req)
}

// optional .zjchain.dht.protobuf.HeartbeatResponse heartbeat_res = 7;
inline bool DhtMessage::_internal_has_heartbeat_res() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || heartbeat_res_ != nullptr);
  return value;
}
inline bool DhtMessage::has_heartbeat_res() const {
  return _internal_has_heartbeat_res();
}
inline void DhtMessage::clear_heartbeat_res() {
  if (heartbeat_res_ != nullptr) heartbeat_res_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::zjchain::dht::protobuf::HeartbeatResponse& DhtMessage::_internal_heartbeat_res() const {
  const ::zjchain::dht::protobuf::HeartbeatResponse* p = heartbeat_res_;
  return p != nullptr ? *p : reinterpret_cast<const ::zjchain::dht::protobuf::HeartbeatResponse&>(
      ::zjchain::dht::protobuf::_HeartbeatResponse_default_instance_);
}
inline const ::zjchain::dht::protobuf::HeartbeatResponse& DhtMessage::heartbeat_res() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.DhtMessage.heartbeat_res)
  return _internal_heartbeat_res();
}
inline void DhtMessage::unsafe_arena_set_allocated_heartbeat_res(
    ::zjchain::dht::protobuf::HeartbeatResponse* heartbeat_res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heartbeat_res_);
  }
  heartbeat_res_ = heartbeat_res;
  if (heartbeat_res) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zjchain.dht.protobuf.DhtMessage.heartbeat_res)
}
inline ::zjchain::dht::protobuf::HeartbeatResponse* DhtMessage::release_heartbeat_res() {
  _has_bits_[0] &= ~0x00000040u;
  ::zjchain::dht::protobuf::HeartbeatResponse* temp = heartbeat_res_;
  heartbeat_res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zjchain::dht::protobuf::HeartbeatResponse* DhtMessage::unsafe_arena_release_heartbeat_res() {
  // @@protoc_insertion_point(field_release:zjchain.dht.protobuf.DhtMessage.heartbeat_res)
  _has_bits_[0] &= ~0x00000040u;
  ::zjchain::dht::protobuf::HeartbeatResponse* temp = heartbeat_res_;
  heartbeat_res_ = nullptr;
  return temp;
}
inline ::zjchain::dht::protobuf::HeartbeatResponse* DhtMessage::_internal_mutable_heartbeat_res() {
  _has_bits_[0] |= 0x00000040u;
  if (heartbeat_res_ == nullptr) {
    auto* p = CreateMaybeMessage<::zjchain::dht::protobuf::HeartbeatResponse>(GetArenaForAllocation());
    heartbeat_res_ = p;
  }
  return heartbeat_res_;
}
inline ::zjchain::dht::protobuf::HeartbeatResponse* DhtMessage::mutable_heartbeat_res() {
  ::zjchain::dht::protobuf::HeartbeatResponse* _msg = _internal_mutable_heartbeat_res();
  // @@protoc_insertion_point(field_mutable:zjchain.dht.protobuf.DhtMessage.heartbeat_res)
  return _msg;
}
inline void DhtMessage::set_allocated_heartbeat_res(::zjchain::dht::protobuf::HeartbeatResponse* heartbeat_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete heartbeat_res_;
  }
  if (heartbeat_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(heartbeat_res);
    if (message_arena != submessage_arena) {
      heartbeat_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heartbeat_res, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  heartbeat_res_ = heartbeat_res;
  // @@protoc_insertion_point(field_set_allocated:zjchain.dht.protobuf.DhtMessage.heartbeat_res)
}

// optional .zjchain.dht.protobuf.TimerRequest timer = 8;
inline bool DhtMessage::_internal_has_timer() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || timer_ != nullptr);
  return value;
}
inline bool DhtMessage::has_timer() const {
  return _internal_has_timer();
}
inline void DhtMessage::clear_timer() {
  if (timer_ != nullptr) timer_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::zjchain::dht::protobuf::TimerRequest& DhtMessage::_internal_timer() const {
  const ::zjchain::dht::protobuf::TimerRequest* p = timer_;
  return p != nullptr ? *p : reinterpret_cast<const ::zjchain::dht::protobuf::TimerRequest&>(
      ::zjchain::dht::protobuf::_TimerRequest_default_instance_);
}
inline const ::zjchain::dht::protobuf::TimerRequest& DhtMessage::timer() const {
  // @@protoc_insertion_point(field_get:zjchain.dht.protobuf.DhtMessage.timer)
  return _internal_timer();
}
inline void DhtMessage::unsafe_arena_set_allocated_timer(
    ::zjchain::dht::protobuf::TimerRequest* timer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timer_);
  }
  timer_ = timer;
  if (timer) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zjchain.dht.protobuf.DhtMessage.timer)
}
inline ::zjchain::dht::protobuf::TimerRequest* DhtMessage::release_timer() {
  _has_bits_[0] &= ~0x00000080u;
  ::zjchain::dht::protobuf::TimerRequest* temp = timer_;
  timer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zjchain::dht::protobuf::TimerRequest* DhtMessage::unsafe_arena_release_timer() {
  // @@protoc_insertion_point(field_release:zjchain.dht.protobuf.DhtMessage.timer)
  _has_bits_[0] &= ~0x00000080u;
  ::zjchain::dht::protobuf::TimerRequest* temp = timer_;
  timer_ = nullptr;
  return temp;
}
inline ::zjchain::dht::protobuf::TimerRequest* DhtMessage::_internal_mutable_timer() {
  _has_bits_[0] |= 0x00000080u;
  if (timer_ == nullptr) {
    auto* p = CreateMaybeMessage<::zjchain::dht::protobuf::TimerRequest>(GetArenaForAllocation());
    timer_ = p;
  }
  return timer_;
}
inline ::zjchain::dht::protobuf::TimerRequest* DhtMessage::mutable_timer() {
  ::zjchain::dht::protobuf::TimerRequest* _msg = _internal_mutable_timer();
  // @@protoc_insertion_point(field_mutable:zjchain.dht.protobuf.DhtMessage.timer)
  return _msg;
}
inline void DhtMessage::set_allocated_timer(::zjchain::dht::protobuf::TimerRequest* timer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete timer_;
  }
  if (timer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(timer);
    if (message_arena != submessage_arena) {
      timer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timer, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  timer_ = timer;
  // @@protoc_insertion_point(field_set_allocated:zjchain.dht.protobuf.DhtMessage.timer)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace dht
}  // namespace zjchain

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protos_2fdht_2eproto
