// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/dht.proto

#ifndef PROTOBUF_protos_2fdht_2eproto__INCLUDED
#define PROTOBUF_protos_2fdht_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace zjchain {
namespace dht {
namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_protos_2fdht_2eproto();
void protobuf_AssignDesc_protos_2fdht_2eproto();
void protobuf_ShutdownFile_protos_2fdht_2eproto();

class BootstrapRequest;
class BootstrapResponse;
class NodeInfo;
class RefreshNeighborsRequest;
class RefreshNeighborsResponse;
class HeartbeatRequest;
class HeartbeatResponse;
class ConnectReqeust;
class TimerRequest;
class DhtMessage;

// ===================================================================

class BootstrapRequest : public ::google::protobuf::Message {
 public:
  BootstrapRequest();
  virtual ~BootstrapRequest();

  BootstrapRequest(const BootstrapRequest& from);

  inline BootstrapRequest& operator=(const BootstrapRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BootstrapRequest& default_instance();

  void Swap(BootstrapRequest* other);

  // implements Message ----------------------------------------------

  BootstrapRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BootstrapRequest& from);
  void MergeFrom(const BootstrapRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes pubkey = 1;
  inline bool has_pubkey() const;
  inline void clear_pubkey();
  static const int kPubkeyFieldNumber = 1;
  inline const ::std::string& pubkey() const;
  inline void set_pubkey(const ::std::string& value);
  inline void set_pubkey(const char* value);
  inline void set_pubkey(const void* value, size_t size);
  inline ::std::string* mutable_pubkey();
  inline ::std::string* release_pubkey();
  inline void set_allocated_pubkey(::std::string* pubkey);

  // optional string public_ip = 2;
  inline bool has_public_ip() const;
  inline void clear_public_ip();
  static const int kPublicIpFieldNumber = 2;
  inline const ::std::string& public_ip() const;
  inline void set_public_ip(const ::std::string& value);
  inline void set_public_ip(const char* value);
  inline void set_public_ip(const char* value, size_t size);
  inline ::std::string* mutable_public_ip();
  inline ::std::string* release_public_ip();
  inline void set_allocated_public_ip(::std::string* public_ip);

  // optional int32 public_port = 3;
  inline bool has_public_port() const;
  inline void clear_public_port();
  static const int kPublicPortFieldNumber = 3;
  inline ::google::protobuf::int32 public_port() const;
  inline void set_public_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zjchain.dht.protobuf.BootstrapRequest)
 private:
  inline void set_has_pubkey();
  inline void clear_has_pubkey();
  inline void set_has_public_ip();
  inline void clear_has_public_ip();
  inline void set_has_public_port();
  inline void clear_has_public_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pubkey_;
  ::std::string* public_ip_;
  ::google::protobuf::int32 public_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fdht_2eproto();
  friend void protobuf_AssignDesc_protos_2fdht_2eproto();
  friend void protobuf_ShutdownFile_protos_2fdht_2eproto();

  void InitAsDefaultInstance();
  static BootstrapRequest* default_instance_;
};
// -------------------------------------------------------------------

class BootstrapResponse : public ::google::protobuf::Message {
 public:
  BootstrapResponse();
  virtual ~BootstrapResponse();

  BootstrapResponse(const BootstrapResponse& from);

  inline BootstrapResponse& operator=(const BootstrapResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BootstrapResponse& default_instance();

  void Swap(BootstrapResponse* other);

  // implements Message ----------------------------------------------

  BootstrapResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BootstrapResponse& from);
  void MergeFrom(const BootstrapResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes pubkey = 1;
  inline bool has_pubkey() const;
  inline void clear_pubkey();
  static const int kPubkeyFieldNumber = 1;
  inline const ::std::string& pubkey() const;
  inline void set_pubkey(const ::std::string& value);
  inline void set_pubkey(const char* value);
  inline void set_pubkey(const void* value, size_t size);
  inline ::std::string* mutable_pubkey();
  inline ::std::string* release_pubkey();
  inline void set_allocated_pubkey(::std::string* pubkey);

  // optional string public_ip = 2;
  inline bool has_public_ip() const;
  inline void clear_public_ip();
  static const int kPublicIpFieldNumber = 2;
  inline const ::std::string& public_ip() const;
  inline void set_public_ip(const ::std::string& value);
  inline void set_public_ip(const char* value);
  inline void set_public_ip(const char* value, size_t size);
  inline ::std::string* mutable_public_ip();
  inline ::std::string* release_public_ip();
  inline void set_allocated_public_ip(::std::string* public_ip);

  // optional int32 public_port = 3;
  inline bool has_public_port() const;
  inline void clear_public_port();
  static const int kPublicPortFieldNumber = 3;
  inline ::google::protobuf::int32 public_port() const;
  inline void set_public_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zjchain.dht.protobuf.BootstrapResponse)
 private:
  inline void set_has_pubkey();
  inline void clear_has_pubkey();
  inline void set_has_public_ip();
  inline void clear_has_public_ip();
  inline void set_has_public_port();
  inline void clear_has_public_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pubkey_;
  ::std::string* public_ip_;
  ::google::protobuf::int32 public_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fdht_2eproto();
  friend void protobuf_AssignDesc_protos_2fdht_2eproto();
  friend void protobuf_ShutdownFile_protos_2fdht_2eproto();

  void InitAsDefaultInstance();
  static BootstrapResponse* default_instance_;
};
// -------------------------------------------------------------------

class NodeInfo : public ::google::protobuf::Message {
 public:
  NodeInfo();
  virtual ~NodeInfo();

  NodeInfo(const NodeInfo& from);

  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeInfo& default_instance();

  void Swap(NodeInfo* other);

  // implements Message ----------------------------------------------

  NodeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeInfo& from);
  void MergeFrom(const NodeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes public_ip = 1;
  inline bool has_public_ip() const;
  inline void clear_public_ip();
  static const int kPublicIpFieldNumber = 1;
  inline const ::std::string& public_ip() const;
  inline void set_public_ip(const ::std::string& value);
  inline void set_public_ip(const char* value);
  inline void set_public_ip(const void* value, size_t size);
  inline ::std::string* mutable_public_ip();
  inline ::std::string* release_public_ip();
  inline void set_allocated_public_ip(::std::string* public_ip);

  // optional int32 public_port = 2;
  inline bool has_public_port() const;
  inline void clear_public_port();
  static const int kPublicPortFieldNumber = 2;
  inline ::google::protobuf::int32 public_port() const;
  inline void set_public_port(::google::protobuf::int32 value);

  // optional bytes pubkey = 3;
  inline bool has_pubkey() const;
  inline void clear_pubkey();
  static const int kPubkeyFieldNumber = 3;
  inline const ::std::string& pubkey() const;
  inline void set_pubkey(const ::std::string& value);
  inline void set_pubkey(const char* value);
  inline void set_pubkey(const void* value, size_t size);
  inline ::std::string* mutable_pubkey();
  inline ::std::string* release_pubkey();
  inline void set_allocated_pubkey(::std::string* pubkey);

  // @@protoc_insertion_point(class_scope:zjchain.dht.protobuf.NodeInfo)
 private:
  inline void set_has_public_ip();
  inline void clear_has_public_ip();
  inline void set_has_public_port();
  inline void clear_has_public_port();
  inline void set_has_pubkey();
  inline void clear_has_pubkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* public_ip_;
  ::std::string* pubkey_;
  ::google::protobuf::int32 public_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fdht_2eproto();
  friend void protobuf_AssignDesc_protos_2fdht_2eproto();
  friend void protobuf_ShutdownFile_protos_2fdht_2eproto();

  void InitAsDefaultInstance();
  static NodeInfo* default_instance_;
};
// -------------------------------------------------------------------

class RefreshNeighborsRequest : public ::google::protobuf::Message {
 public:
  RefreshNeighborsRequest();
  virtual ~RefreshNeighborsRequest();

  RefreshNeighborsRequest(const RefreshNeighborsRequest& from);

  inline RefreshNeighborsRequest& operator=(const RefreshNeighborsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RefreshNeighborsRequest& default_instance();

  void Swap(RefreshNeighborsRequest* other);

  // implements Message ----------------------------------------------

  RefreshNeighborsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RefreshNeighborsRequest& from);
  void MergeFrom(const RefreshNeighborsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated uint64 bloomfilter = 2;
  inline int bloomfilter_size() const;
  inline void clear_bloomfilter();
  static const int kBloomfilterFieldNumber = 2;
  inline ::google::protobuf::uint64 bloomfilter(int index) const;
  inline void set_bloomfilter(int index, ::google::protobuf::uint64 value);
  inline void add_bloomfilter(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      bloomfilter() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_bloomfilter();

  // optional bytes pubkey = 3;
  inline bool has_pubkey() const;
  inline void clear_pubkey();
  static const int kPubkeyFieldNumber = 3;
  inline const ::std::string& pubkey() const;
  inline void set_pubkey(const ::std::string& value);
  inline void set_pubkey(const char* value);
  inline void set_pubkey(const void* value, size_t size);
  inline ::std::string* mutable_pubkey();
  inline ::std::string* release_pubkey();
  inline void set_allocated_pubkey(::std::string* pubkey);

  // optional string public_ip = 4;
  inline bool has_public_ip() const;
  inline void clear_public_ip();
  static const int kPublicIpFieldNumber = 4;
  inline const ::std::string& public_ip() const;
  inline void set_public_ip(const ::std::string& value);
  inline void set_public_ip(const char* value);
  inline void set_public_ip(const char* value, size_t size);
  inline ::std::string* mutable_public_ip();
  inline ::std::string* release_public_ip();
  inline void set_allocated_public_ip(::std::string* public_ip);

  // optional int32 public_port = 5;
  inline bool has_public_port() const;
  inline void clear_public_port();
  static const int kPublicPortFieldNumber = 5;
  inline ::google::protobuf::int32 public_port() const;
  inline void set_public_port(::google::protobuf::int32 value);

  // repeated bytes ids = 6;
  inline int ids_size() const;
  inline void clear_ids();
  static const int kIdsFieldNumber = 6;
  inline const ::std::string& ids(int index) const;
  inline ::std::string* mutable_ids(int index);
  inline void set_ids(int index, const ::std::string& value);
  inline void set_ids(int index, const char* value);
  inline void set_ids(int index, const void* value, size_t size);
  inline ::std::string* add_ids();
  inline void add_ids(const ::std::string& value);
  inline void add_ids(const char* value);
  inline void add_ids(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ids();

  // @@protoc_insertion_point(class_scope:zjchain.dht.protobuf.RefreshNeighborsRequest)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_pubkey();
  inline void clear_has_pubkey();
  inline void set_has_public_ip();
  inline void clear_has_public_ip();
  inline void set_has_public_port();
  inline void clear_has_public_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > bloomfilter_;
  ::std::string* pubkey_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::int32 public_port_;
  ::std::string* public_ip_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fdht_2eproto();
  friend void protobuf_AssignDesc_protos_2fdht_2eproto();
  friend void protobuf_ShutdownFile_protos_2fdht_2eproto();

  void InitAsDefaultInstance();
  static RefreshNeighborsRequest* default_instance_;
};
// -------------------------------------------------------------------

class RefreshNeighborsResponse : public ::google::protobuf::Message {
 public:
  RefreshNeighborsResponse();
  virtual ~RefreshNeighborsResponse();

  RefreshNeighborsResponse(const RefreshNeighborsResponse& from);

  inline RefreshNeighborsResponse& operator=(const RefreshNeighborsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RefreshNeighborsResponse& default_instance();

  void Swap(RefreshNeighborsResponse* other);

  // implements Message ----------------------------------------------

  RefreshNeighborsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RefreshNeighborsResponse& from);
  void MergeFrom(const RefreshNeighborsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zjchain.dht.protobuf.NodeInfo nodes = 1;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 1;
  inline const ::zjchain::dht::protobuf::NodeInfo& nodes(int index) const;
  inline ::zjchain::dht::protobuf::NodeInfo* mutable_nodes(int index);
  inline ::zjchain::dht::protobuf::NodeInfo* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::zjchain::dht::protobuf::NodeInfo >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::zjchain::dht::protobuf::NodeInfo >*
      mutable_nodes();

  // @@protoc_insertion_point(class_scope:zjchain.dht.protobuf.RefreshNeighborsResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::zjchain::dht::protobuf::NodeInfo > nodes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fdht_2eproto();
  friend void protobuf_AssignDesc_protos_2fdht_2eproto();
  friend void protobuf_ShutdownFile_protos_2fdht_2eproto();

  void InitAsDefaultInstance();
  static RefreshNeighborsResponse* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatRequest : public ::google::protobuf::Message {
 public:
  HeartbeatRequest();
  virtual ~HeartbeatRequest();

  HeartbeatRequest(const HeartbeatRequest& from);

  inline HeartbeatRequest& operator=(const HeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatRequest& default_instance();

  void Swap(HeartbeatRequest* other);

  // implements Message ----------------------------------------------

  HeartbeatRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartbeatRequest& from);
  void MergeFrom(const HeartbeatRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 dht_key_hash = 1;
  inline bool has_dht_key_hash() const;
  inline void clear_dht_key_hash();
  static const int kDhtKeyHashFieldNumber = 1;
  inline ::google::protobuf::uint64 dht_key_hash() const;
  inline void set_dht_key_hash(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:zjchain.dht.protobuf.HeartbeatRequest)
 private:
  inline void set_has_dht_key_hash();
  inline void clear_has_dht_key_hash();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 dht_key_hash_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fdht_2eproto();
  friend void protobuf_AssignDesc_protos_2fdht_2eproto();
  friend void protobuf_ShutdownFile_protos_2fdht_2eproto();

  void InitAsDefaultInstance();
  static HeartbeatRequest* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatResponse : public ::google::protobuf::Message {
 public:
  HeartbeatResponse();
  virtual ~HeartbeatResponse();

  HeartbeatResponse(const HeartbeatResponse& from);

  inline HeartbeatResponse& operator=(const HeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatResponse& default_instance();

  void Swap(HeartbeatResponse* other);

  // implements Message ----------------------------------------------

  HeartbeatResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartbeatResponse& from);
  void MergeFrom(const HeartbeatResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 dht_key_hash = 1;
  inline bool has_dht_key_hash() const;
  inline void clear_dht_key_hash();
  static const int kDhtKeyHashFieldNumber = 1;
  inline ::google::protobuf::uint64 dht_key_hash() const;
  inline void set_dht_key_hash(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:zjchain.dht.protobuf.HeartbeatResponse)
 private:
  inline void set_has_dht_key_hash();
  inline void clear_has_dht_key_hash();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 dht_key_hash_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fdht_2eproto();
  friend void protobuf_AssignDesc_protos_2fdht_2eproto();
  friend void protobuf_ShutdownFile_protos_2fdht_2eproto();

  void InitAsDefaultInstance();
  static HeartbeatResponse* default_instance_;
};
// -------------------------------------------------------------------

class ConnectReqeust : public ::google::protobuf::Message {
 public:
  ConnectReqeust();
  virtual ~ConnectReqeust();

  ConnectReqeust(const ConnectReqeust& from);

  inline ConnectReqeust& operator=(const ConnectReqeust& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectReqeust& default_instance();

  void Swap(ConnectReqeust* other);

  // implements Message ----------------------------------------------

  ConnectReqeust* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectReqeust& from);
  void MergeFrom(const ConnectReqeust& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes pubkey = 1;
  inline bool has_pubkey() const;
  inline void clear_pubkey();
  static const int kPubkeyFieldNumber = 1;
  inline const ::std::string& pubkey() const;
  inline void set_pubkey(const ::std::string& value);
  inline void set_pubkey(const char* value);
  inline void set_pubkey(const void* value, size_t size);
  inline ::std::string* mutable_pubkey();
  inline ::std::string* release_pubkey();
  inline void set_allocated_pubkey(::std::string* pubkey);

  // optional bool is_response = 2;
  inline bool has_is_response() const;
  inline void clear_is_response();
  static const int kIsResponseFieldNumber = 2;
  inline bool is_response() const;
  inline void set_is_response(bool value);

  // optional string public_ip = 3;
  inline bool has_public_ip() const;
  inline void clear_public_ip();
  static const int kPublicIpFieldNumber = 3;
  inline const ::std::string& public_ip() const;
  inline void set_public_ip(const ::std::string& value);
  inline void set_public_ip(const char* value);
  inline void set_public_ip(const char* value, size_t size);
  inline ::std::string* mutable_public_ip();
  inline ::std::string* release_public_ip();
  inline void set_allocated_public_ip(::std::string* public_ip);

  // optional int32 public_port = 4;
  inline bool has_public_port() const;
  inline void clear_public_port();
  static const int kPublicPortFieldNumber = 4;
  inline ::google::protobuf::int32 public_port() const;
  inline void set_public_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zjchain.dht.protobuf.ConnectReqeust)
 private:
  inline void set_has_pubkey();
  inline void clear_has_pubkey();
  inline void set_has_is_response();
  inline void clear_has_is_response();
  inline void set_has_public_ip();
  inline void clear_has_public_ip();
  inline void set_has_public_port();
  inline void clear_has_public_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pubkey_;
  ::std::string* public_ip_;
  bool is_response_;
  ::google::protobuf::int32 public_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fdht_2eproto();
  friend void protobuf_AssignDesc_protos_2fdht_2eproto();
  friend void protobuf_ShutdownFile_protos_2fdht_2eproto();

  void InitAsDefaultInstance();
  static ConnectReqeust* default_instance_;
};
// -------------------------------------------------------------------

class TimerRequest : public ::google::protobuf::Message {
 public:
  TimerRequest();
  virtual ~TimerRequest();

  TimerRequest(const TimerRequest& from);

  inline TimerRequest& operator=(const TimerRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimerRequest& default_instance();

  void Swap(TimerRequest* other);

  // implements Message ----------------------------------------------

  TimerRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimerRequest& from);
  void MergeFrom(const TimerRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 tm_milli = 1;
  inline bool has_tm_milli() const;
  inline void clear_tm_milli();
  static const int kTmMilliFieldNumber = 1;
  inline ::google::protobuf::uint64 tm_milli() const;
  inline void set_tm_milli(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:zjchain.dht.protobuf.TimerRequest)
 private:
  inline void set_has_tm_milli();
  inline void clear_has_tm_milli();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 tm_milli_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fdht_2eproto();
  friend void protobuf_AssignDesc_protos_2fdht_2eproto();
  friend void protobuf_ShutdownFile_protos_2fdht_2eproto();

  void InitAsDefaultInstance();
  static TimerRequest* default_instance_;
};
// -------------------------------------------------------------------

class DhtMessage : public ::google::protobuf::Message {
 public:
  DhtMessage();
  virtual ~DhtMessage();

  DhtMessage(const DhtMessage& from);

  inline DhtMessage& operator=(const DhtMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DhtMessage& default_instance();

  void Swap(DhtMessage* other);

  // implements Message ----------------------------------------------

  DhtMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DhtMessage& from);
  void MergeFrom(const DhtMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .zjchain.dht.protobuf.BootstrapRequest bootstrap_req = 1;
  inline bool has_bootstrap_req() const;
  inline void clear_bootstrap_req();
  static const int kBootstrapReqFieldNumber = 1;
  inline const ::zjchain::dht::protobuf::BootstrapRequest& bootstrap_req() const;
  inline ::zjchain::dht::protobuf::BootstrapRequest* mutable_bootstrap_req();
  inline ::zjchain::dht::protobuf::BootstrapRequest* release_bootstrap_req();
  inline void set_allocated_bootstrap_req(::zjchain::dht::protobuf::BootstrapRequest* bootstrap_req);

  // optional .zjchain.dht.protobuf.BootstrapResponse bootstrap_res = 2;
  inline bool has_bootstrap_res() const;
  inline void clear_bootstrap_res();
  static const int kBootstrapResFieldNumber = 2;
  inline const ::zjchain::dht::protobuf::BootstrapResponse& bootstrap_res() const;
  inline ::zjchain::dht::protobuf::BootstrapResponse* mutable_bootstrap_res();
  inline ::zjchain::dht::protobuf::BootstrapResponse* release_bootstrap_res();
  inline void set_allocated_bootstrap_res(::zjchain::dht::protobuf::BootstrapResponse* bootstrap_res);

  // optional .zjchain.dht.protobuf.RefreshNeighborsRequest refresh_neighbors_req = 3;
  inline bool has_refresh_neighbors_req() const;
  inline void clear_refresh_neighbors_req();
  static const int kRefreshNeighborsReqFieldNumber = 3;
  inline const ::zjchain::dht::protobuf::RefreshNeighborsRequest& refresh_neighbors_req() const;
  inline ::zjchain::dht::protobuf::RefreshNeighborsRequest* mutable_refresh_neighbors_req();
  inline ::zjchain::dht::protobuf::RefreshNeighborsRequest* release_refresh_neighbors_req();
  inline void set_allocated_refresh_neighbors_req(::zjchain::dht::protobuf::RefreshNeighborsRequest* refresh_neighbors_req);

  // optional .zjchain.dht.protobuf.RefreshNeighborsResponse refresh_neighbors_res = 4;
  inline bool has_refresh_neighbors_res() const;
  inline void clear_refresh_neighbors_res();
  static const int kRefreshNeighborsResFieldNumber = 4;
  inline const ::zjchain::dht::protobuf::RefreshNeighborsResponse& refresh_neighbors_res() const;
  inline ::zjchain::dht::protobuf::RefreshNeighborsResponse* mutable_refresh_neighbors_res();
  inline ::zjchain::dht::protobuf::RefreshNeighborsResponse* release_refresh_neighbors_res();
  inline void set_allocated_refresh_neighbors_res(::zjchain::dht::protobuf::RefreshNeighborsResponse* refresh_neighbors_res);

  // optional .zjchain.dht.protobuf.ConnectReqeust connect_req = 5;
  inline bool has_connect_req() const;
  inline void clear_connect_req();
  static const int kConnectReqFieldNumber = 5;
  inline const ::zjchain::dht::protobuf::ConnectReqeust& connect_req() const;
  inline ::zjchain::dht::protobuf::ConnectReqeust* mutable_connect_req();
  inline ::zjchain::dht::protobuf::ConnectReqeust* release_connect_req();
  inline void set_allocated_connect_req(::zjchain::dht::protobuf::ConnectReqeust* connect_req);

  // optional .zjchain.dht.protobuf.HeartbeatRequest heartbeat_req = 6;
  inline bool has_heartbeat_req() const;
  inline void clear_heartbeat_req();
  static const int kHeartbeatReqFieldNumber = 6;
  inline const ::zjchain::dht::protobuf::HeartbeatRequest& heartbeat_req() const;
  inline ::zjchain::dht::protobuf::HeartbeatRequest* mutable_heartbeat_req();
  inline ::zjchain::dht::protobuf::HeartbeatRequest* release_heartbeat_req();
  inline void set_allocated_heartbeat_req(::zjchain::dht::protobuf::HeartbeatRequest* heartbeat_req);

  // optional .zjchain.dht.protobuf.HeartbeatResponse heartbeat_res = 7;
  inline bool has_heartbeat_res() const;
  inline void clear_heartbeat_res();
  static const int kHeartbeatResFieldNumber = 7;
  inline const ::zjchain::dht::protobuf::HeartbeatResponse& heartbeat_res() const;
  inline ::zjchain::dht::protobuf::HeartbeatResponse* mutable_heartbeat_res();
  inline ::zjchain::dht::protobuf::HeartbeatResponse* release_heartbeat_res();
  inline void set_allocated_heartbeat_res(::zjchain::dht::protobuf::HeartbeatResponse* heartbeat_res);

  // optional .zjchain.dht.protobuf.TimerRequest timer = 8;
  inline bool has_timer() const;
  inline void clear_timer();
  static const int kTimerFieldNumber = 8;
  inline const ::zjchain::dht::protobuf::TimerRequest& timer() const;
  inline ::zjchain::dht::protobuf::TimerRequest* mutable_timer();
  inline ::zjchain::dht::protobuf::TimerRequest* release_timer();
  inline void set_allocated_timer(::zjchain::dht::protobuf::TimerRequest* timer);

  // @@protoc_insertion_point(class_scope:zjchain.dht.protobuf.DhtMessage)
 private:
  inline void set_has_bootstrap_req();
  inline void clear_has_bootstrap_req();
  inline void set_has_bootstrap_res();
  inline void clear_has_bootstrap_res();
  inline void set_has_refresh_neighbors_req();
  inline void clear_has_refresh_neighbors_req();
  inline void set_has_refresh_neighbors_res();
  inline void clear_has_refresh_neighbors_res();
  inline void set_has_connect_req();
  inline void clear_has_connect_req();
  inline void set_has_heartbeat_req();
  inline void clear_has_heartbeat_req();
  inline void set_has_heartbeat_res();
  inline void clear_has_heartbeat_res();
  inline void set_has_timer();
  inline void clear_has_timer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::zjchain::dht::protobuf::BootstrapRequest* bootstrap_req_;
  ::zjchain::dht::protobuf::BootstrapResponse* bootstrap_res_;
  ::zjchain::dht::protobuf::RefreshNeighborsRequest* refresh_neighbors_req_;
  ::zjchain::dht::protobuf::RefreshNeighborsResponse* refresh_neighbors_res_;
  ::zjchain::dht::protobuf::ConnectReqeust* connect_req_;
  ::zjchain::dht::protobuf::HeartbeatRequest* heartbeat_req_;
  ::zjchain::dht::protobuf::HeartbeatResponse* heartbeat_res_;
  ::zjchain::dht::protobuf::TimerRequest* timer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fdht_2eproto();
  friend void protobuf_AssignDesc_protos_2fdht_2eproto();
  friend void protobuf_ShutdownFile_protos_2fdht_2eproto();

  void InitAsDefaultInstance();
  static DhtMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// BootstrapRequest

// optional bytes pubkey = 1;
inline bool BootstrapRequest::has_pubkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BootstrapRequest::set_has_pubkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BootstrapRequest::clear_has_pubkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BootstrapRequest::clear_pubkey() {
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    pubkey_->clear();
  }
  clear_has_pubkey();
}
inline const ::std::string& BootstrapRequest::pubkey() const {
  return *pubkey_;
}
inline void BootstrapRequest::set_pubkey(const ::std::string& value) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(value);
}
inline void BootstrapRequest::set_pubkey(const char* value) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(value);
}
inline void BootstrapRequest::set_pubkey(const void* value, size_t size) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BootstrapRequest::mutable_pubkey() {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  return pubkey_;
}
inline ::std::string* BootstrapRequest::release_pubkey() {
  clear_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pubkey_;
    pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BootstrapRequest::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    delete pubkey_;
  }
  if (pubkey) {
    set_has_pubkey();
    pubkey_ = pubkey;
  } else {
    clear_has_pubkey();
    pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string public_ip = 2;
inline bool BootstrapRequest::has_public_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BootstrapRequest::set_has_public_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BootstrapRequest::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BootstrapRequest::clear_public_ip() {
  if (public_ip_ != &::google::protobuf::internal::kEmptyString) {
    public_ip_->clear();
  }
  clear_has_public_ip();
}
inline const ::std::string& BootstrapRequest::public_ip() const {
  return *public_ip_;
}
inline void BootstrapRequest::set_public_ip(const ::std::string& value) {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  public_ip_->assign(value);
}
inline void BootstrapRequest::set_public_ip(const char* value) {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  public_ip_->assign(value);
}
inline void BootstrapRequest::set_public_ip(const char* value, size_t size) {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  public_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BootstrapRequest::mutable_public_ip() {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  return public_ip_;
}
inline ::std::string* BootstrapRequest::release_public_ip() {
  clear_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_ip_;
    public_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BootstrapRequest::set_allocated_public_ip(::std::string* public_ip) {
  if (public_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete public_ip_;
  }
  if (public_ip) {
    set_has_public_ip();
    public_ip_ = public_ip;
  } else {
    clear_has_public_ip();
    public_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 public_port = 3;
inline bool BootstrapRequest::has_public_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BootstrapRequest::set_has_public_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BootstrapRequest::clear_has_public_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BootstrapRequest::clear_public_port() {
  public_port_ = 0;
  clear_has_public_port();
}
inline ::google::protobuf::int32 BootstrapRequest::public_port() const {
  return public_port_;
}
inline void BootstrapRequest::set_public_port(::google::protobuf::int32 value) {
  set_has_public_port();
  public_port_ = value;
}

// -------------------------------------------------------------------

// BootstrapResponse

// optional bytes pubkey = 1;
inline bool BootstrapResponse::has_pubkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BootstrapResponse::set_has_pubkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BootstrapResponse::clear_has_pubkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BootstrapResponse::clear_pubkey() {
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    pubkey_->clear();
  }
  clear_has_pubkey();
}
inline const ::std::string& BootstrapResponse::pubkey() const {
  return *pubkey_;
}
inline void BootstrapResponse::set_pubkey(const ::std::string& value) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(value);
}
inline void BootstrapResponse::set_pubkey(const char* value) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(value);
}
inline void BootstrapResponse::set_pubkey(const void* value, size_t size) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BootstrapResponse::mutable_pubkey() {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  return pubkey_;
}
inline ::std::string* BootstrapResponse::release_pubkey() {
  clear_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pubkey_;
    pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BootstrapResponse::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    delete pubkey_;
  }
  if (pubkey) {
    set_has_pubkey();
    pubkey_ = pubkey;
  } else {
    clear_has_pubkey();
    pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string public_ip = 2;
inline bool BootstrapResponse::has_public_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BootstrapResponse::set_has_public_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BootstrapResponse::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BootstrapResponse::clear_public_ip() {
  if (public_ip_ != &::google::protobuf::internal::kEmptyString) {
    public_ip_->clear();
  }
  clear_has_public_ip();
}
inline const ::std::string& BootstrapResponse::public_ip() const {
  return *public_ip_;
}
inline void BootstrapResponse::set_public_ip(const ::std::string& value) {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  public_ip_->assign(value);
}
inline void BootstrapResponse::set_public_ip(const char* value) {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  public_ip_->assign(value);
}
inline void BootstrapResponse::set_public_ip(const char* value, size_t size) {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  public_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BootstrapResponse::mutable_public_ip() {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  return public_ip_;
}
inline ::std::string* BootstrapResponse::release_public_ip() {
  clear_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_ip_;
    public_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BootstrapResponse::set_allocated_public_ip(::std::string* public_ip) {
  if (public_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete public_ip_;
  }
  if (public_ip) {
    set_has_public_ip();
    public_ip_ = public_ip;
  } else {
    clear_has_public_ip();
    public_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 public_port = 3;
inline bool BootstrapResponse::has_public_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BootstrapResponse::set_has_public_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BootstrapResponse::clear_has_public_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BootstrapResponse::clear_public_port() {
  public_port_ = 0;
  clear_has_public_port();
}
inline ::google::protobuf::int32 BootstrapResponse::public_port() const {
  return public_port_;
}
inline void BootstrapResponse::set_public_port(::google::protobuf::int32 value) {
  set_has_public_port();
  public_port_ = value;
}

// -------------------------------------------------------------------

// NodeInfo

// optional bytes public_ip = 1;
inline bool NodeInfo::has_public_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeInfo::set_has_public_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeInfo::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeInfo::clear_public_ip() {
  if (public_ip_ != &::google::protobuf::internal::kEmptyString) {
    public_ip_->clear();
  }
  clear_has_public_ip();
}
inline const ::std::string& NodeInfo::public_ip() const {
  return *public_ip_;
}
inline void NodeInfo::set_public_ip(const ::std::string& value) {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  public_ip_->assign(value);
}
inline void NodeInfo::set_public_ip(const char* value) {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  public_ip_->assign(value);
}
inline void NodeInfo::set_public_ip(const void* value, size_t size) {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  public_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeInfo::mutable_public_ip() {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  return public_ip_;
}
inline ::std::string* NodeInfo::release_public_ip() {
  clear_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_ip_;
    public_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeInfo::set_allocated_public_ip(::std::string* public_ip) {
  if (public_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete public_ip_;
  }
  if (public_ip) {
    set_has_public_ip();
    public_ip_ = public_ip;
  } else {
    clear_has_public_ip();
    public_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 public_port = 2;
inline bool NodeInfo::has_public_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeInfo::set_has_public_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeInfo::clear_has_public_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeInfo::clear_public_port() {
  public_port_ = 0;
  clear_has_public_port();
}
inline ::google::protobuf::int32 NodeInfo::public_port() const {
  return public_port_;
}
inline void NodeInfo::set_public_port(::google::protobuf::int32 value) {
  set_has_public_port();
  public_port_ = value;
}

// optional bytes pubkey = 3;
inline bool NodeInfo::has_pubkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeInfo::set_has_pubkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeInfo::clear_has_pubkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeInfo::clear_pubkey() {
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    pubkey_->clear();
  }
  clear_has_pubkey();
}
inline const ::std::string& NodeInfo::pubkey() const {
  return *pubkey_;
}
inline void NodeInfo::set_pubkey(const ::std::string& value) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(value);
}
inline void NodeInfo::set_pubkey(const char* value) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(value);
}
inline void NodeInfo::set_pubkey(const void* value, size_t size) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeInfo::mutable_pubkey() {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  return pubkey_;
}
inline ::std::string* NodeInfo::release_pubkey() {
  clear_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pubkey_;
    pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeInfo::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    delete pubkey_;
  }
  if (pubkey) {
    set_has_pubkey();
    pubkey_ = pubkey;
  } else {
    clear_has_pubkey();
    pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RefreshNeighborsRequest

// optional uint32 count = 1;
inline bool RefreshNeighborsRequest::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RefreshNeighborsRequest::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RefreshNeighborsRequest::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RefreshNeighborsRequest::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 RefreshNeighborsRequest::count() const {
  return count_;
}
inline void RefreshNeighborsRequest::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated uint64 bloomfilter = 2;
inline int RefreshNeighborsRequest::bloomfilter_size() const {
  return bloomfilter_.size();
}
inline void RefreshNeighborsRequest::clear_bloomfilter() {
  bloomfilter_.Clear();
}
inline ::google::protobuf::uint64 RefreshNeighborsRequest::bloomfilter(int index) const {
  return bloomfilter_.Get(index);
}
inline void RefreshNeighborsRequest::set_bloomfilter(int index, ::google::protobuf::uint64 value) {
  bloomfilter_.Set(index, value);
}
inline void RefreshNeighborsRequest::add_bloomfilter(::google::protobuf::uint64 value) {
  bloomfilter_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
RefreshNeighborsRequest::bloomfilter() const {
  return bloomfilter_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
RefreshNeighborsRequest::mutable_bloomfilter() {
  return &bloomfilter_;
}

// optional bytes pubkey = 3;
inline bool RefreshNeighborsRequest::has_pubkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RefreshNeighborsRequest::set_has_pubkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RefreshNeighborsRequest::clear_has_pubkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RefreshNeighborsRequest::clear_pubkey() {
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    pubkey_->clear();
  }
  clear_has_pubkey();
}
inline const ::std::string& RefreshNeighborsRequest::pubkey() const {
  return *pubkey_;
}
inline void RefreshNeighborsRequest::set_pubkey(const ::std::string& value) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(value);
}
inline void RefreshNeighborsRequest::set_pubkey(const char* value) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(value);
}
inline void RefreshNeighborsRequest::set_pubkey(const void* value, size_t size) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RefreshNeighborsRequest::mutable_pubkey() {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  return pubkey_;
}
inline ::std::string* RefreshNeighborsRequest::release_pubkey() {
  clear_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pubkey_;
    pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RefreshNeighborsRequest::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    delete pubkey_;
  }
  if (pubkey) {
    set_has_pubkey();
    pubkey_ = pubkey;
  } else {
    clear_has_pubkey();
    pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string public_ip = 4;
inline bool RefreshNeighborsRequest::has_public_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RefreshNeighborsRequest::set_has_public_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RefreshNeighborsRequest::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RefreshNeighborsRequest::clear_public_ip() {
  if (public_ip_ != &::google::protobuf::internal::kEmptyString) {
    public_ip_->clear();
  }
  clear_has_public_ip();
}
inline const ::std::string& RefreshNeighborsRequest::public_ip() const {
  return *public_ip_;
}
inline void RefreshNeighborsRequest::set_public_ip(const ::std::string& value) {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  public_ip_->assign(value);
}
inline void RefreshNeighborsRequest::set_public_ip(const char* value) {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  public_ip_->assign(value);
}
inline void RefreshNeighborsRequest::set_public_ip(const char* value, size_t size) {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  public_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RefreshNeighborsRequest::mutable_public_ip() {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  return public_ip_;
}
inline ::std::string* RefreshNeighborsRequest::release_public_ip() {
  clear_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_ip_;
    public_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RefreshNeighborsRequest::set_allocated_public_ip(::std::string* public_ip) {
  if (public_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete public_ip_;
  }
  if (public_ip) {
    set_has_public_ip();
    public_ip_ = public_ip;
  } else {
    clear_has_public_ip();
    public_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 public_port = 5;
inline bool RefreshNeighborsRequest::has_public_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RefreshNeighborsRequest::set_has_public_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RefreshNeighborsRequest::clear_has_public_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RefreshNeighborsRequest::clear_public_port() {
  public_port_ = 0;
  clear_has_public_port();
}
inline ::google::protobuf::int32 RefreshNeighborsRequest::public_port() const {
  return public_port_;
}
inline void RefreshNeighborsRequest::set_public_port(::google::protobuf::int32 value) {
  set_has_public_port();
  public_port_ = value;
}

// repeated bytes ids = 6;
inline int RefreshNeighborsRequest::ids_size() const {
  return ids_.size();
}
inline void RefreshNeighborsRequest::clear_ids() {
  ids_.Clear();
}
inline const ::std::string& RefreshNeighborsRequest::ids(int index) const {
  return ids_.Get(index);
}
inline ::std::string* RefreshNeighborsRequest::mutable_ids(int index) {
  return ids_.Mutable(index);
}
inline void RefreshNeighborsRequest::set_ids(int index, const ::std::string& value) {
  ids_.Mutable(index)->assign(value);
}
inline void RefreshNeighborsRequest::set_ids(int index, const char* value) {
  ids_.Mutable(index)->assign(value);
}
inline void RefreshNeighborsRequest::set_ids(int index, const void* value, size_t size) {
  ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RefreshNeighborsRequest::add_ids() {
  return ids_.Add();
}
inline void RefreshNeighborsRequest::add_ids(const ::std::string& value) {
  ids_.Add()->assign(value);
}
inline void RefreshNeighborsRequest::add_ids(const char* value) {
  ids_.Add()->assign(value);
}
inline void RefreshNeighborsRequest::add_ids(const void* value, size_t size) {
  ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RefreshNeighborsRequest::ids() const {
  return ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RefreshNeighborsRequest::mutable_ids() {
  return &ids_;
}

// -------------------------------------------------------------------

// RefreshNeighborsResponse

// repeated .zjchain.dht.protobuf.NodeInfo nodes = 1;
inline int RefreshNeighborsResponse::nodes_size() const {
  return nodes_.size();
}
inline void RefreshNeighborsResponse::clear_nodes() {
  nodes_.Clear();
}
inline const ::zjchain::dht::protobuf::NodeInfo& RefreshNeighborsResponse::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::zjchain::dht::protobuf::NodeInfo* RefreshNeighborsResponse::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::zjchain::dht::protobuf::NodeInfo* RefreshNeighborsResponse::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zjchain::dht::protobuf::NodeInfo >&
RefreshNeighborsResponse::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::zjchain::dht::protobuf::NodeInfo >*
RefreshNeighborsResponse::mutable_nodes() {
  return &nodes_;
}

// -------------------------------------------------------------------

// HeartbeatRequest

// optional uint64 dht_key_hash = 1;
inline bool HeartbeatRequest::has_dht_key_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatRequest::set_has_dht_key_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatRequest::clear_has_dht_key_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatRequest::clear_dht_key_hash() {
  dht_key_hash_ = GOOGLE_ULONGLONG(0);
  clear_has_dht_key_hash();
}
inline ::google::protobuf::uint64 HeartbeatRequest::dht_key_hash() const {
  return dht_key_hash_;
}
inline void HeartbeatRequest::set_dht_key_hash(::google::protobuf::uint64 value) {
  set_has_dht_key_hash();
  dht_key_hash_ = value;
}

// -------------------------------------------------------------------

// HeartbeatResponse

// optional uint64 dht_key_hash = 1;
inline bool HeartbeatResponse::has_dht_key_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatResponse::set_has_dht_key_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatResponse::clear_has_dht_key_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatResponse::clear_dht_key_hash() {
  dht_key_hash_ = GOOGLE_ULONGLONG(0);
  clear_has_dht_key_hash();
}
inline ::google::protobuf::uint64 HeartbeatResponse::dht_key_hash() const {
  return dht_key_hash_;
}
inline void HeartbeatResponse::set_dht_key_hash(::google::protobuf::uint64 value) {
  set_has_dht_key_hash();
  dht_key_hash_ = value;
}

// -------------------------------------------------------------------

// ConnectReqeust

// optional bytes pubkey = 1;
inline bool ConnectReqeust::has_pubkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectReqeust::set_has_pubkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectReqeust::clear_has_pubkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectReqeust::clear_pubkey() {
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    pubkey_->clear();
  }
  clear_has_pubkey();
}
inline const ::std::string& ConnectReqeust::pubkey() const {
  return *pubkey_;
}
inline void ConnectReqeust::set_pubkey(const ::std::string& value) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(value);
}
inline void ConnectReqeust::set_pubkey(const char* value) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(value);
}
inline void ConnectReqeust::set_pubkey(const void* value, size_t size) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectReqeust::mutable_pubkey() {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  return pubkey_;
}
inline ::std::string* ConnectReqeust::release_pubkey() {
  clear_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pubkey_;
    pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConnectReqeust::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    delete pubkey_;
  }
  if (pubkey) {
    set_has_pubkey();
    pubkey_ = pubkey;
  } else {
    clear_has_pubkey();
    pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_response = 2;
inline bool ConnectReqeust::has_is_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectReqeust::set_has_is_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectReqeust::clear_has_is_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectReqeust::clear_is_response() {
  is_response_ = false;
  clear_has_is_response();
}
inline bool ConnectReqeust::is_response() const {
  return is_response_;
}
inline void ConnectReqeust::set_is_response(bool value) {
  set_has_is_response();
  is_response_ = value;
}

// optional string public_ip = 3;
inline bool ConnectReqeust::has_public_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectReqeust::set_has_public_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectReqeust::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectReqeust::clear_public_ip() {
  if (public_ip_ != &::google::protobuf::internal::kEmptyString) {
    public_ip_->clear();
  }
  clear_has_public_ip();
}
inline const ::std::string& ConnectReqeust::public_ip() const {
  return *public_ip_;
}
inline void ConnectReqeust::set_public_ip(const ::std::string& value) {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  public_ip_->assign(value);
}
inline void ConnectReqeust::set_public_ip(const char* value) {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  public_ip_->assign(value);
}
inline void ConnectReqeust::set_public_ip(const char* value, size_t size) {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  public_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectReqeust::mutable_public_ip() {
  set_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    public_ip_ = new ::std::string;
  }
  return public_ip_;
}
inline ::std::string* ConnectReqeust::release_public_ip() {
  clear_has_public_ip();
  if (public_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_ip_;
    public_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConnectReqeust::set_allocated_public_ip(::std::string* public_ip) {
  if (public_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete public_ip_;
  }
  if (public_ip) {
    set_has_public_ip();
    public_ip_ = public_ip;
  } else {
    clear_has_public_ip();
    public_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 public_port = 4;
inline bool ConnectReqeust::has_public_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConnectReqeust::set_has_public_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConnectReqeust::clear_has_public_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConnectReqeust::clear_public_port() {
  public_port_ = 0;
  clear_has_public_port();
}
inline ::google::protobuf::int32 ConnectReqeust::public_port() const {
  return public_port_;
}
inline void ConnectReqeust::set_public_port(::google::protobuf::int32 value) {
  set_has_public_port();
  public_port_ = value;
}

// -------------------------------------------------------------------

// TimerRequest

// optional uint64 tm_milli = 1;
inline bool TimerRequest::has_tm_milli() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimerRequest::set_has_tm_milli() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimerRequest::clear_has_tm_milli() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimerRequest::clear_tm_milli() {
  tm_milli_ = GOOGLE_ULONGLONG(0);
  clear_has_tm_milli();
}
inline ::google::protobuf::uint64 TimerRequest::tm_milli() const {
  return tm_milli_;
}
inline void TimerRequest::set_tm_milli(::google::protobuf::uint64 value) {
  set_has_tm_milli();
  tm_milli_ = value;
}

// -------------------------------------------------------------------

// DhtMessage

// optional .zjchain.dht.protobuf.BootstrapRequest bootstrap_req = 1;
inline bool DhtMessage::has_bootstrap_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DhtMessage::set_has_bootstrap_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DhtMessage::clear_has_bootstrap_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DhtMessage::clear_bootstrap_req() {
  if (bootstrap_req_ != NULL) bootstrap_req_->::zjchain::dht::protobuf::BootstrapRequest::Clear();
  clear_has_bootstrap_req();
}
inline const ::zjchain::dht::protobuf::BootstrapRequest& DhtMessage::bootstrap_req() const {
  return bootstrap_req_ != NULL ? *bootstrap_req_ : *default_instance_->bootstrap_req_;
}
inline ::zjchain::dht::protobuf::BootstrapRequest* DhtMessage::mutable_bootstrap_req() {
  set_has_bootstrap_req();
  if (bootstrap_req_ == NULL) bootstrap_req_ = new ::zjchain::dht::protobuf::BootstrapRequest;
  return bootstrap_req_;
}
inline ::zjchain::dht::protobuf::BootstrapRequest* DhtMessage::release_bootstrap_req() {
  clear_has_bootstrap_req();
  ::zjchain::dht::protobuf::BootstrapRequest* temp = bootstrap_req_;
  bootstrap_req_ = NULL;
  return temp;
}
inline void DhtMessage::set_allocated_bootstrap_req(::zjchain::dht::protobuf::BootstrapRequest* bootstrap_req) {
  delete bootstrap_req_;
  bootstrap_req_ = bootstrap_req;
  if (bootstrap_req) {
    set_has_bootstrap_req();
  } else {
    clear_has_bootstrap_req();
  }
}

// optional .zjchain.dht.protobuf.BootstrapResponse bootstrap_res = 2;
inline bool DhtMessage::has_bootstrap_res() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DhtMessage::set_has_bootstrap_res() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DhtMessage::clear_has_bootstrap_res() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DhtMessage::clear_bootstrap_res() {
  if (bootstrap_res_ != NULL) bootstrap_res_->::zjchain::dht::protobuf::BootstrapResponse::Clear();
  clear_has_bootstrap_res();
}
inline const ::zjchain::dht::protobuf::BootstrapResponse& DhtMessage::bootstrap_res() const {
  return bootstrap_res_ != NULL ? *bootstrap_res_ : *default_instance_->bootstrap_res_;
}
inline ::zjchain::dht::protobuf::BootstrapResponse* DhtMessage::mutable_bootstrap_res() {
  set_has_bootstrap_res();
  if (bootstrap_res_ == NULL) bootstrap_res_ = new ::zjchain::dht::protobuf::BootstrapResponse;
  return bootstrap_res_;
}
inline ::zjchain::dht::protobuf::BootstrapResponse* DhtMessage::release_bootstrap_res() {
  clear_has_bootstrap_res();
  ::zjchain::dht::protobuf::BootstrapResponse* temp = bootstrap_res_;
  bootstrap_res_ = NULL;
  return temp;
}
inline void DhtMessage::set_allocated_bootstrap_res(::zjchain::dht::protobuf::BootstrapResponse* bootstrap_res) {
  delete bootstrap_res_;
  bootstrap_res_ = bootstrap_res;
  if (bootstrap_res) {
    set_has_bootstrap_res();
  } else {
    clear_has_bootstrap_res();
  }
}

// optional .zjchain.dht.protobuf.RefreshNeighborsRequest refresh_neighbors_req = 3;
inline bool DhtMessage::has_refresh_neighbors_req() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DhtMessage::set_has_refresh_neighbors_req() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DhtMessage::clear_has_refresh_neighbors_req() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DhtMessage::clear_refresh_neighbors_req() {
  if (refresh_neighbors_req_ != NULL) refresh_neighbors_req_->::zjchain::dht::protobuf::RefreshNeighborsRequest::Clear();
  clear_has_refresh_neighbors_req();
}
inline const ::zjchain::dht::protobuf::RefreshNeighborsRequest& DhtMessage::refresh_neighbors_req() const {
  return refresh_neighbors_req_ != NULL ? *refresh_neighbors_req_ : *default_instance_->refresh_neighbors_req_;
}
inline ::zjchain::dht::protobuf::RefreshNeighborsRequest* DhtMessage::mutable_refresh_neighbors_req() {
  set_has_refresh_neighbors_req();
  if (refresh_neighbors_req_ == NULL) refresh_neighbors_req_ = new ::zjchain::dht::protobuf::RefreshNeighborsRequest;
  return refresh_neighbors_req_;
}
inline ::zjchain::dht::protobuf::RefreshNeighborsRequest* DhtMessage::release_refresh_neighbors_req() {
  clear_has_refresh_neighbors_req();
  ::zjchain::dht::protobuf::RefreshNeighborsRequest* temp = refresh_neighbors_req_;
  refresh_neighbors_req_ = NULL;
  return temp;
}
inline void DhtMessage::set_allocated_refresh_neighbors_req(::zjchain::dht::protobuf::RefreshNeighborsRequest* refresh_neighbors_req) {
  delete refresh_neighbors_req_;
  refresh_neighbors_req_ = refresh_neighbors_req;
  if (refresh_neighbors_req) {
    set_has_refresh_neighbors_req();
  } else {
    clear_has_refresh_neighbors_req();
  }
}

// optional .zjchain.dht.protobuf.RefreshNeighborsResponse refresh_neighbors_res = 4;
inline bool DhtMessage::has_refresh_neighbors_res() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DhtMessage::set_has_refresh_neighbors_res() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DhtMessage::clear_has_refresh_neighbors_res() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DhtMessage::clear_refresh_neighbors_res() {
  if (refresh_neighbors_res_ != NULL) refresh_neighbors_res_->::zjchain::dht::protobuf::RefreshNeighborsResponse::Clear();
  clear_has_refresh_neighbors_res();
}
inline const ::zjchain::dht::protobuf::RefreshNeighborsResponse& DhtMessage::refresh_neighbors_res() const {
  return refresh_neighbors_res_ != NULL ? *refresh_neighbors_res_ : *default_instance_->refresh_neighbors_res_;
}
inline ::zjchain::dht::protobuf::RefreshNeighborsResponse* DhtMessage::mutable_refresh_neighbors_res() {
  set_has_refresh_neighbors_res();
  if (refresh_neighbors_res_ == NULL) refresh_neighbors_res_ = new ::zjchain::dht::protobuf::RefreshNeighborsResponse;
  return refresh_neighbors_res_;
}
inline ::zjchain::dht::protobuf::RefreshNeighborsResponse* DhtMessage::release_refresh_neighbors_res() {
  clear_has_refresh_neighbors_res();
  ::zjchain::dht::protobuf::RefreshNeighborsResponse* temp = refresh_neighbors_res_;
  refresh_neighbors_res_ = NULL;
  return temp;
}
inline void DhtMessage::set_allocated_refresh_neighbors_res(::zjchain::dht::protobuf::RefreshNeighborsResponse* refresh_neighbors_res) {
  delete refresh_neighbors_res_;
  refresh_neighbors_res_ = refresh_neighbors_res;
  if (refresh_neighbors_res) {
    set_has_refresh_neighbors_res();
  } else {
    clear_has_refresh_neighbors_res();
  }
}

// optional .zjchain.dht.protobuf.ConnectReqeust connect_req = 5;
inline bool DhtMessage::has_connect_req() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DhtMessage::set_has_connect_req() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DhtMessage::clear_has_connect_req() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DhtMessage::clear_connect_req() {
  if (connect_req_ != NULL) connect_req_->::zjchain::dht::protobuf::ConnectReqeust::Clear();
  clear_has_connect_req();
}
inline const ::zjchain::dht::protobuf::ConnectReqeust& DhtMessage::connect_req() const {
  return connect_req_ != NULL ? *connect_req_ : *default_instance_->connect_req_;
}
inline ::zjchain::dht::protobuf::ConnectReqeust* DhtMessage::mutable_connect_req() {
  set_has_connect_req();
  if (connect_req_ == NULL) connect_req_ = new ::zjchain::dht::protobuf::ConnectReqeust;
  return connect_req_;
}
inline ::zjchain::dht::protobuf::ConnectReqeust* DhtMessage::release_connect_req() {
  clear_has_connect_req();
  ::zjchain::dht::protobuf::ConnectReqeust* temp = connect_req_;
  connect_req_ = NULL;
  return temp;
}
inline void DhtMessage::set_allocated_connect_req(::zjchain::dht::protobuf::ConnectReqeust* connect_req) {
  delete connect_req_;
  connect_req_ = connect_req;
  if (connect_req) {
    set_has_connect_req();
  } else {
    clear_has_connect_req();
  }
}

// optional .zjchain.dht.protobuf.HeartbeatRequest heartbeat_req = 6;
inline bool DhtMessage::has_heartbeat_req() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DhtMessage::set_has_heartbeat_req() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DhtMessage::clear_has_heartbeat_req() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DhtMessage::clear_heartbeat_req() {
  if (heartbeat_req_ != NULL) heartbeat_req_->::zjchain::dht::protobuf::HeartbeatRequest::Clear();
  clear_has_heartbeat_req();
}
inline const ::zjchain::dht::protobuf::HeartbeatRequest& DhtMessage::heartbeat_req() const {
  return heartbeat_req_ != NULL ? *heartbeat_req_ : *default_instance_->heartbeat_req_;
}
inline ::zjchain::dht::protobuf::HeartbeatRequest* DhtMessage::mutable_heartbeat_req() {
  set_has_heartbeat_req();
  if (heartbeat_req_ == NULL) heartbeat_req_ = new ::zjchain::dht::protobuf::HeartbeatRequest;
  return heartbeat_req_;
}
inline ::zjchain::dht::protobuf::HeartbeatRequest* DhtMessage::release_heartbeat_req() {
  clear_has_heartbeat_req();
  ::zjchain::dht::protobuf::HeartbeatRequest* temp = heartbeat_req_;
  heartbeat_req_ = NULL;
  return temp;
}
inline void DhtMessage::set_allocated_heartbeat_req(::zjchain::dht::protobuf::HeartbeatRequest* heartbeat_req) {
  delete heartbeat_req_;
  heartbeat_req_ = heartbeat_req;
  if (heartbeat_req) {
    set_has_heartbeat_req();
  } else {
    clear_has_heartbeat_req();
  }
}

// optional .zjchain.dht.protobuf.HeartbeatResponse heartbeat_res = 7;
inline bool DhtMessage::has_heartbeat_res() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DhtMessage::set_has_heartbeat_res() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DhtMessage::clear_has_heartbeat_res() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DhtMessage::clear_heartbeat_res() {
  if (heartbeat_res_ != NULL) heartbeat_res_->::zjchain::dht::protobuf::HeartbeatResponse::Clear();
  clear_has_heartbeat_res();
}
inline const ::zjchain::dht::protobuf::HeartbeatResponse& DhtMessage::heartbeat_res() const {
  return heartbeat_res_ != NULL ? *heartbeat_res_ : *default_instance_->heartbeat_res_;
}
inline ::zjchain::dht::protobuf::HeartbeatResponse* DhtMessage::mutable_heartbeat_res() {
  set_has_heartbeat_res();
  if (heartbeat_res_ == NULL) heartbeat_res_ = new ::zjchain::dht::protobuf::HeartbeatResponse;
  return heartbeat_res_;
}
inline ::zjchain::dht::protobuf::HeartbeatResponse* DhtMessage::release_heartbeat_res() {
  clear_has_heartbeat_res();
  ::zjchain::dht::protobuf::HeartbeatResponse* temp = heartbeat_res_;
  heartbeat_res_ = NULL;
  return temp;
}
inline void DhtMessage::set_allocated_heartbeat_res(::zjchain::dht::protobuf::HeartbeatResponse* heartbeat_res) {
  delete heartbeat_res_;
  heartbeat_res_ = heartbeat_res;
  if (heartbeat_res) {
    set_has_heartbeat_res();
  } else {
    clear_has_heartbeat_res();
  }
}

// optional .zjchain.dht.protobuf.TimerRequest timer = 8;
inline bool DhtMessage::has_timer() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DhtMessage::set_has_timer() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DhtMessage::clear_has_timer() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DhtMessage::clear_timer() {
  if (timer_ != NULL) timer_->::zjchain::dht::protobuf::TimerRequest::Clear();
  clear_has_timer();
}
inline const ::zjchain::dht::protobuf::TimerRequest& DhtMessage::timer() const {
  return timer_ != NULL ? *timer_ : *default_instance_->timer_;
}
inline ::zjchain::dht::protobuf::TimerRequest* DhtMessage::mutable_timer() {
  set_has_timer();
  if (timer_ == NULL) timer_ = new ::zjchain::dht::protobuf::TimerRequest;
  return timer_;
}
inline ::zjchain::dht::protobuf::TimerRequest* DhtMessage::release_timer() {
  clear_has_timer();
  ::zjchain::dht::protobuf::TimerRequest* temp = timer_;
  timer_ = NULL;
  return temp;
}
inline void DhtMessage::set_allocated_timer(::zjchain::dht::protobuf::TimerRequest* timer) {
  delete timer_;
  timer_ = timer;
  if (timer) {
    set_has_timer();
  } else {
    clear_has_timer();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace dht
}  // namespace zjchain

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fdht_2eproto__INCLUDED
