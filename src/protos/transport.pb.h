// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/transport.proto

#ifndef PROTOBUF_protos_2ftransport_2eproto__INCLUDED
#define PROTOBUF_protos_2ftransport_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "protos/network.pb.h"
#include "protos/dht.pb.h"
#include "protos/block.pb.h"
#include "protos/bls.pb.h"
#include "protos/pools.pb.h"
#include "protos/contract.pb.h"
#include "protos/elect.pb.h"
#include "protos/zbft.pb.h"
#include "protos/sync.pb.h"
#include "protos/vss.pb.h"
#include "protos/init.pb.h"
#include "protos/c2c.pb.h"
// @@protoc_insertion_point(includes)

namespace zjchain {
namespace transport {
namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_protos_2ftransport_2eproto();
void protobuf_AssignDesc_protos_2ftransport_2eproto();
void protobuf_ShutdownFile_protos_2ftransport_2eproto();

class BroadcastParam;
class Header;

// ===================================================================

class BroadcastParam : public ::google::protobuf::Message {
 public:
  BroadcastParam();
  virtual ~BroadcastParam();

  BroadcastParam(const BroadcastParam& from);

  inline BroadcastParam& operator=(const BroadcastParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BroadcastParam& default_instance();

  void Swap(BroadcastParam* other);

  // implements Message ----------------------------------------------

  BroadcastParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BroadcastParam& from);
  void MergeFrom(const BroadcastParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 neighbor_count = 2 [default = 7];
  inline bool has_neighbor_count() const;
  inline void clear_neighbor_count();
  static const int kNeighborCountFieldNumber = 2;
  inline ::google::protobuf::uint32 neighbor_count() const;
  inline void set_neighbor_count(::google::protobuf::uint32 value);

  // optional uint32 stop_times = 3;
  inline bool has_stop_times() const;
  inline void clear_stop_times();
  static const int kStopTimesFieldNumber = 3;
  inline ::google::protobuf::uint32 stop_times() const;
  inline void set_stop_times(::google::protobuf::uint32 value);

  // optional uint32 hop_limit = 4 [default = 10];
  inline bool has_hop_limit() const;
  inline void clear_hop_limit();
  static const int kHopLimitFieldNumber = 4;
  inline ::google::protobuf::uint32 hop_limit() const;
  inline void set_hop_limit(::google::protobuf::uint32 value);

  // optional uint64 layer_left = 5;
  inline bool has_layer_left() const;
  inline void clear_layer_left();
  static const int kLayerLeftFieldNumber = 5;
  inline ::google::protobuf::uint64 layer_left() const;
  inline void set_layer_left(::google::protobuf::uint64 value);

  // optional uint64 layer_right = 6;
  inline bool has_layer_right() const;
  inline void clear_layer_right();
  static const int kLayerRightFieldNumber = 6;
  inline ::google::protobuf::uint64 layer_right() const;
  inline void set_layer_right(::google::protobuf::uint64 value);

  // optional float overlap = 7;
  inline bool has_overlap() const;
  inline void clear_overlap();
  static const int kOverlapFieldNumber = 7;
  inline float overlap() const;
  inline void set_overlap(float value);

  // optional uint32 hop_to_layer = 8 [default = 1];
  inline bool has_hop_to_layer() const;
  inline void clear_hop_to_layer();
  static const int kHopToLayerFieldNumber = 8;
  inline ::google::protobuf::uint32 hop_to_layer() const;
  inline void set_hop_to_layer(::google::protobuf::uint32 value);

  // optional bytes header = 9;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 9;
  inline const ::std::string& header() const;
  inline void set_header(const ::std::string& value);
  inline void set_header(const char* value);
  inline void set_header(const void* value, size_t size);
  inline ::std::string* mutable_header();
  inline ::std::string* release_header();
  inline void set_allocated_header(::std::string* header);

  // optional bytes body = 10;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 10;
  inline const ::std::string& body() const;
  inline void set_body(const ::std::string& value);
  inline void set_body(const char* value);
  inline void set_body(const void* value, size_t size);
  inline ::std::string* mutable_body();
  inline ::std::string* release_body();
  inline void set_allocated_body(::std::string* body);

  // optional bool net_crossed = 11;
  inline bool has_net_crossed() const;
  inline void clear_net_crossed();
  static const int kNetCrossedFieldNumber = 11;
  inline bool net_crossed() const;
  inline void set_net_crossed(bool value);

  // repeated uint64 bloomfilter = 12;
  inline int bloomfilter_size() const;
  inline void clear_bloomfilter();
  static const int kBloomfilterFieldNumber = 12;
  inline ::google::protobuf::uint64 bloomfilter(int index) const;
  inline void set_bloomfilter(int index, ::google::protobuf::uint64 value);
  inline void add_bloomfilter(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      bloomfilter() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_bloomfilter();

  // optional float evil_rate = 13 [default = 0];
  inline bool has_evil_rate() const;
  inline void clear_evil_rate();
  static const int kEvilRateFieldNumber = 13;
  inline float evil_rate() const;
  inline void set_evil_rate(float value);

  // optional uint32 ign_bloomfilter_hop = 14 [default = 1];
  inline bool has_ign_bloomfilter_hop() const;
  inline void clear_ign_bloomfilter_hop();
  static const int kIgnBloomfilterHopFieldNumber = 14;
  inline ::google::protobuf::uint32 ign_bloomfilter_hop() const;
  inline void set_ign_bloomfilter_hop(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zjchain.transport.protobuf.BroadcastParam)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_neighbor_count();
  inline void clear_has_neighbor_count();
  inline void set_has_stop_times();
  inline void clear_has_stop_times();
  inline void set_has_hop_limit();
  inline void clear_has_hop_limit();
  inline void set_has_layer_left();
  inline void clear_has_layer_left();
  inline void set_has_layer_right();
  inline void clear_has_layer_right();
  inline void set_has_overlap();
  inline void clear_has_overlap();
  inline void set_has_hop_to_layer();
  inline void clear_has_hop_to_layer();
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_body();
  inline void clear_has_body();
  inline void set_has_net_crossed();
  inline void clear_has_net_crossed();
  inline void set_has_evil_rate();
  inline void clear_has_evil_rate();
  inline void set_has_ign_bloomfilter_hop();
  inline void clear_has_ign_bloomfilter_hop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 neighbor_count_;
  ::google::protobuf::uint32 stop_times_;
  ::google::protobuf::uint32 hop_limit_;
  ::google::protobuf::uint64 layer_left_;
  ::google::protobuf::uint64 layer_right_;
  float overlap_;
  ::google::protobuf::uint32 hop_to_layer_;
  ::std::string* header_;
  ::std::string* body_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > bloomfilter_;
  bool net_crossed_;
  float evil_rate_;
  ::google::protobuf::uint32 ign_bloomfilter_hop_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2ftransport_2eproto();
  friend void protobuf_AssignDesc_protos_2ftransport_2eproto();
  friend void protobuf_ShutdownFile_protos_2ftransport_2eproto();

  void InitAsDefaultInstance();
  static BroadcastParam* default_instance_;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  void Swap(Header* other);

  // implements Message ----------------------------------------------

  Header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 src_sharding_id = 1;
  inline bool has_src_sharding_id() const;
  inline void clear_src_sharding_id();
  static const int kSrcShardingIdFieldNumber = 1;
  inline ::google::protobuf::int32 src_sharding_id() const;
  inline void set_src_sharding_id(::google::protobuf::int32 value);

  // optional bytes des_dht_key = 2;
  inline bool has_des_dht_key() const;
  inline void clear_des_dht_key();
  static const int kDesDhtKeyFieldNumber = 2;
  inline const ::std::string& des_dht_key() const;
  inline void set_des_dht_key(const ::std::string& value);
  inline void set_des_dht_key(const char* value);
  inline void set_des_dht_key(const void* value, size_t size);
  inline ::std::string* mutable_des_dht_key();
  inline ::std::string* release_des_dht_key();
  inline void set_allocated_des_dht_key(::std::string* des_dht_key);

  // optional uint32 hop_count = 3 [default = 0];
  inline bool has_hop_count() const;
  inline void clear_hop_count();
  static const int kHopCountFieldNumber = 3;
  inline ::google::protobuf::uint32 hop_count() const;
  inline void set_hop_count(::google::protobuf::uint32 value);

  // optional bytes debug = 4;
  inline bool has_debug() const;
  inline void clear_debug();
  static const int kDebugFieldNumber = 4;
  inline const ::std::string& debug() const;
  inline void set_debug(const ::std::string& value);
  inline void set_debug(const char* value);
  inline void set_debug(const void* value, size_t size);
  inline ::std::string* mutable_debug();
  inline ::std::string* release_debug();
  inline void set_allocated_debug(::std::string* debug);

  // optional uint64 hash64 = 5;
  inline bool has_hash64() const;
  inline void clear_hash64();
  static const int kHash64FieldNumber = 5;
  inline ::google::protobuf::uint64 hash64() const;
  inline void set_hash64(::google::protobuf::uint64 value);

  // optional uint32 type = 6;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional .zjchain.transport.protobuf.BroadcastParam broadcast = 7;
  inline bool has_broadcast() const;
  inline void clear_broadcast();
  static const int kBroadcastFieldNumber = 7;
  inline const ::zjchain::transport::protobuf::BroadcastParam& broadcast() const;
  inline ::zjchain::transport::protobuf::BroadcastParam* mutable_broadcast();
  inline ::zjchain::transport::protobuf::BroadcastParam* release_broadcast();
  inline void set_allocated_broadcast(::zjchain::transport::protobuf::BroadcastParam* broadcast);

  // optional bytes sign = 8;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 8;
  inline const ::std::string& sign() const;
  inline void set_sign(const ::std::string& value);
  inline void set_sign(const char* value);
  inline void set_sign(const void* value, size_t size);
  inline ::std::string* mutable_sign();
  inline ::std::string* release_sign();
  inline void set_allocated_sign(::std::string* sign);

  // optional int32 version = 9 [default = 0];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 9;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // optional .zjchain.network.protobuf.NetworkMessage network_proto = 10;
  inline bool has_network_proto() const;
  inline void clear_network_proto();
  static const int kNetworkProtoFieldNumber = 10;
  inline const ::zjchain::network::protobuf::NetworkMessage& network_proto() const;
  inline ::zjchain::network::protobuf::NetworkMessage* mutable_network_proto();
  inline ::zjchain::network::protobuf::NetworkMessage* release_network_proto();
  inline void set_allocated_network_proto(::zjchain::network::protobuf::NetworkMessage* network_proto);

  // optional .zjchain.dht.protobuf.DhtMessage dht_proto = 11;
  inline bool has_dht_proto() const;
  inline void clear_dht_proto();
  static const int kDhtProtoFieldNumber = 11;
  inline const ::zjchain::dht::protobuf::DhtMessage& dht_proto() const;
  inline ::zjchain::dht::protobuf::DhtMessage* mutable_dht_proto();
  inline ::zjchain::dht::protobuf::DhtMessage* release_dht_proto();
  inline void set_allocated_dht_proto(::zjchain::dht::protobuf::DhtMessage* dht_proto);

  // optional .zjchain.bls.protobuf.BlsMessage bls_proto = 12;
  inline bool has_bls_proto() const;
  inline void clear_bls_proto();
  static const int kBlsProtoFieldNumber = 12;
  inline const ::zjchain::bls::protobuf::BlsMessage& bls_proto() const;
  inline ::zjchain::bls::protobuf::BlsMessage* mutable_bls_proto();
  inline ::zjchain::bls::protobuf::BlsMessage* release_bls_proto();
  inline void set_allocated_bls_proto(::zjchain::bls::protobuf::BlsMessage* bls_proto);

  // optional .zjchain.pools.protobuf.TxMessage tx_proto = 13;
  inline bool has_tx_proto() const;
  inline void clear_tx_proto();
  static const int kTxProtoFieldNumber = 13;
  inline const ::zjchain::pools::protobuf::TxMessage& tx_proto() const;
  inline ::zjchain::pools::protobuf::TxMessage* mutable_tx_proto();
  inline ::zjchain::pools::protobuf::TxMessage* release_tx_proto();
  inline void set_allocated_tx_proto(::zjchain::pools::protobuf::TxMessage* tx_proto);

  // optional .zjchain.contract.protobuf.ContractMessage contract_proto = 14;
  inline bool has_contract_proto() const;
  inline void clear_contract_proto();
  static const int kContractProtoFieldNumber = 14;
  inline const ::zjchain::contract::protobuf::ContractMessage& contract_proto() const;
  inline ::zjchain::contract::protobuf::ContractMessage* mutable_contract_proto();
  inline ::zjchain::contract::protobuf::ContractMessage* release_contract_proto();
  inline void set_allocated_contract_proto(::zjchain::contract::protobuf::ContractMessage* contract_proto);

  // optional .zjchain.elect.protobuf.ElectMessage elect_proto = 15;
  inline bool has_elect_proto() const;
  inline void clear_elect_proto();
  static const int kElectProtoFieldNumber = 15;
  inline const ::zjchain::elect::protobuf::ElectMessage& elect_proto() const;
  inline ::zjchain::elect::protobuf::ElectMessage* mutable_elect_proto();
  inline ::zjchain::elect::protobuf::ElectMessage* release_elect_proto();
  inline void set_allocated_elect_proto(::zjchain::elect::protobuf::ElectMessage* elect_proto);

  // optional .zjchain.zbft.protobuf.ZbftMessage zbft = 16;
  inline bool has_zbft() const;
  inline void clear_zbft();
  static const int kZbftFieldNumber = 16;
  inline const ::zjchain::zbft::protobuf::ZbftMessage& zbft() const;
  inline ::zjchain::zbft::protobuf::ZbftMessage* mutable_zbft();
  inline ::zjchain::zbft::protobuf::ZbftMessage* release_zbft();
  inline void set_allocated_zbft(::zjchain::zbft::protobuf::ZbftMessage* zbft);

  // optional .zjchain.block.protobuf.BlockMessage block_proto = 17;
  inline bool has_block_proto() const;
  inline void clear_block_proto();
  static const int kBlockProtoFieldNumber = 17;
  inline const ::zjchain::block::protobuf::BlockMessage& block_proto() const;
  inline ::zjchain::block::protobuf::BlockMessage* mutable_block_proto();
  inline ::zjchain::block::protobuf::BlockMessage* release_block_proto();
  inline void set_allocated_block_proto(::zjchain::block::protobuf::BlockMessage* block_proto);

  // optional .zjchain.pools.protobuf.ToTxHeights to_tx_heights = 18;
  inline bool has_to_tx_heights() const;
  inline void clear_to_tx_heights();
  static const int kToTxHeightsFieldNumber = 18;
  inline const ::zjchain::pools::protobuf::ToTxHeights& to_tx_heights() const;
  inline ::zjchain::pools::protobuf::ToTxHeights* mutable_to_tx_heights();
  inline ::zjchain::pools::protobuf::ToTxHeights* release_to_tx_heights();
  inline void set_allocated_to_tx_heights(::zjchain::pools::protobuf::ToTxHeights* to_tx_heights);

  // optional .zjchain.sync.protobuf.SyncInfo sync = 19;
  inline bool has_sync() const;
  inline void clear_sync();
  static const int kSyncFieldNumber = 19;
  inline const ::zjchain::sync::protobuf::SyncInfo& sync() const;
  inline ::zjchain::sync::protobuf::SyncInfo* mutable_sync();
  inline ::zjchain::sync::protobuf::SyncInfo* release_sync();
  inline void set_allocated_sync(::zjchain::sync::protobuf::SyncInfo* sync);

  // optional .zjchain.sync.protobuf.SyncMessage sync_proto = 20;
  inline bool has_sync_proto() const;
  inline void clear_sync_proto();
  static const int kSyncProtoFieldNumber = 20;
  inline const ::zjchain::sync::protobuf::SyncMessage& sync_proto() const;
  inline ::zjchain::sync::protobuf::SyncMessage* mutable_sync_proto();
  inline ::zjchain::sync::protobuf::SyncMessage* release_sync_proto();
  inline void set_allocated_sync_proto(::zjchain::sync::protobuf::SyncMessage* sync_proto);

  // optional .zjchain.vss.protobuf.VssMessage vss_proto = 21;
  inline bool has_vss_proto() const;
  inline void clear_vss_proto();
  static const int kVssProtoFieldNumber = 21;
  inline const ::zjchain::vss::protobuf::VssMessage& vss_proto() const;
  inline ::zjchain::vss::protobuf::VssMessage* mutable_vss_proto();
  inline ::zjchain::vss::protobuf::VssMessage* release_vss_proto();
  inline void set_allocated_vss_proto(::zjchain::vss::protobuf::VssMessage* vss_proto);

  // optional .zjchain.block.protobuf.CrossShardingTosMessage cross_tos = 22;
  inline bool has_cross_tos() const;
  inline void clear_cross_tos();
  static const int kCrossTosFieldNumber = 22;
  inline const ::zjchain::block::protobuf::CrossShardingTosMessage& cross_tos() const;
  inline ::zjchain::block::protobuf::CrossShardingTosMessage* mutable_cross_tos();
  inline ::zjchain::block::protobuf::CrossShardingTosMessage* release_cross_tos();
  inline void set_allocated_cross_tos(::zjchain::block::protobuf::CrossShardingTosMessage* cross_tos);

  // optional .zjchain.block.protobuf.CrossShardingStatisticMessage cross_statistic = 23;
  inline bool has_cross_statistic() const;
  inline void clear_cross_statistic();
  static const int kCrossStatisticFieldNumber = 23;
  inline const ::zjchain::block::protobuf::CrossShardingStatisticMessage& cross_statistic() const;
  inline ::zjchain::block::protobuf::CrossShardingStatisticMessage* mutable_cross_statistic();
  inline ::zjchain::block::protobuf::CrossShardingStatisticMessage* release_cross_statistic();
  inline void set_allocated_cross_statistic(::zjchain::block::protobuf::CrossShardingStatisticMessage* cross_statistic);

  // optional .zjchain.block.protobuf.ElectBlockMessage elect_block = 24;
  inline bool has_elect_block() const;
  inline void clear_elect_block();
  static const int kElectBlockFieldNumber = 24;
  inline const ::zjchain::block::protobuf::ElectBlockMessage& elect_block() const;
  inline ::zjchain::block::protobuf::ElectBlockMessage* mutable_elect_block();
  inline ::zjchain::block::protobuf::ElectBlockMessage* release_elect_block();
  inline void set_allocated_elect_block(::zjchain::block::protobuf::ElectBlockMessage* elect_block);

  // optional .zjchain.init.protobuf.InitMessage init_proto = 25;
  inline bool has_init_proto() const;
  inline void clear_init_proto();
  static const int kInitProtoFieldNumber = 25;
  inline const ::zjchain::init::protobuf::InitMessage& init_proto() const;
  inline ::zjchain::init::protobuf::InitMessage* mutable_init_proto();
  inline ::zjchain::init::protobuf::InitMessage* release_init_proto();
  inline void set_allocated_init_proto(::zjchain::init::protobuf::InitMessage* init_proto);

  // optional .zjchain.pools.protobuf.SyncPoolsMaxHeight sync_heights = 26;
  inline bool has_sync_heights() const;
  inline void clear_sync_heights();
  static const int kSyncHeightsFieldNumber = 26;
  inline const ::zjchain::pools::protobuf::SyncPoolsMaxHeight& sync_heights() const;
  inline ::zjchain::pools::protobuf::SyncPoolsMaxHeight* mutable_sync_heights();
  inline ::zjchain::pools::protobuf::SyncPoolsMaxHeight* release_sync_heights();
  inline void set_allocated_sync_heights(::zjchain::pools::protobuf::SyncPoolsMaxHeight* sync_heights);

  // optional .zjchain.block.protobuf.Block block = 27;
  inline bool has_block() const;
  inline void clear_block();
  static const int kBlockFieldNumber = 27;
  inline const ::zjchain::block::protobuf::Block& block() const;
  inline ::zjchain::block::protobuf::Block* mutable_block();
  inline ::zjchain::block::protobuf::Block* release_block();
  inline void set_allocated_block(::zjchain::block::protobuf::Block* block);

  // repeated .zjchain.pools.protobuf.InvalidBftMessage invalid_bfts = 28;
  inline int invalid_bfts_size() const;
  inline void clear_invalid_bfts();
  static const int kInvalidBftsFieldNumber = 28;
  inline const ::zjchain::pools::protobuf::InvalidBftMessage& invalid_bfts(int index) const;
  inline ::zjchain::pools::protobuf::InvalidBftMessage* mutable_invalid_bfts(int index);
  inline ::zjchain::pools::protobuf::InvalidBftMessage* add_invalid_bfts();
  inline const ::google::protobuf::RepeatedPtrField< ::zjchain::pools::protobuf::InvalidBftMessage >&
      invalid_bfts() const;
  inline ::google::protobuf::RepeatedPtrField< ::zjchain::pools::protobuf::InvalidBftMessage >*
      mutable_invalid_bfts();

  // optional uint32 from_public_port = 29;
  inline bool has_from_public_port() const;
  inline void clear_from_public_port();
  static const int kFromPublicPortFieldNumber = 29;
  inline ::google::protobuf::uint32 from_public_port() const;
  inline void set_from_public_port(::google::protobuf::uint32 value);

  // optional .zjchain.c2c.protobuf.C2cMessage c2c = 30;
  inline bool has_c2c() const;
  inline void clear_c2c();
  static const int kC2CFieldNumber = 30;
  inline const ::zjchain::c2c::protobuf::C2cMessage& c2c() const;
  inline ::zjchain::c2c::protobuf::C2cMessage* mutable_c2c();
  inline ::zjchain::c2c::protobuf::C2cMessage* release_c2c();
  inline void set_allocated_c2c(::zjchain::c2c::protobuf::C2cMessage* c2c);

  // @@protoc_insertion_point(class_scope:zjchain.transport.protobuf.Header)
 private:
  inline void set_has_src_sharding_id();
  inline void clear_has_src_sharding_id();
  inline void set_has_des_dht_key();
  inline void clear_has_des_dht_key();
  inline void set_has_hop_count();
  inline void clear_has_hop_count();
  inline void set_has_debug();
  inline void clear_has_debug();
  inline void set_has_hash64();
  inline void clear_has_hash64();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_broadcast();
  inline void clear_has_broadcast();
  inline void set_has_sign();
  inline void clear_has_sign();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_network_proto();
  inline void clear_has_network_proto();
  inline void set_has_dht_proto();
  inline void clear_has_dht_proto();
  inline void set_has_bls_proto();
  inline void clear_has_bls_proto();
  inline void set_has_tx_proto();
  inline void clear_has_tx_proto();
  inline void set_has_contract_proto();
  inline void clear_has_contract_proto();
  inline void set_has_elect_proto();
  inline void clear_has_elect_proto();
  inline void set_has_zbft();
  inline void clear_has_zbft();
  inline void set_has_block_proto();
  inline void clear_has_block_proto();
  inline void set_has_to_tx_heights();
  inline void clear_has_to_tx_heights();
  inline void set_has_sync();
  inline void clear_has_sync();
  inline void set_has_sync_proto();
  inline void clear_has_sync_proto();
  inline void set_has_vss_proto();
  inline void clear_has_vss_proto();
  inline void set_has_cross_tos();
  inline void clear_has_cross_tos();
  inline void set_has_cross_statistic();
  inline void clear_has_cross_statistic();
  inline void set_has_elect_block();
  inline void clear_has_elect_block();
  inline void set_has_init_proto();
  inline void clear_has_init_proto();
  inline void set_has_sync_heights();
  inline void clear_has_sync_heights();
  inline void set_has_block();
  inline void clear_has_block();
  inline void set_has_from_public_port();
  inline void clear_has_from_public_port();
  inline void set_has_c2c();
  inline void clear_has_c2c();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* des_dht_key_;
  ::google::protobuf::int32 src_sharding_id_;
  ::google::protobuf::uint32 hop_count_;
  ::std::string* debug_;
  ::google::protobuf::uint64 hash64_;
  ::zjchain::transport::protobuf::BroadcastParam* broadcast_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::int32 version_;
  ::std::string* sign_;
  ::zjchain::network::protobuf::NetworkMessage* network_proto_;
  ::zjchain::dht::protobuf::DhtMessage* dht_proto_;
  ::zjchain::bls::protobuf::BlsMessage* bls_proto_;
  ::zjchain::pools::protobuf::TxMessage* tx_proto_;
  ::zjchain::contract::protobuf::ContractMessage* contract_proto_;
  ::zjchain::elect::protobuf::ElectMessage* elect_proto_;
  ::zjchain::zbft::protobuf::ZbftMessage* zbft_;
  ::zjchain::block::protobuf::BlockMessage* block_proto_;
  ::zjchain::pools::protobuf::ToTxHeights* to_tx_heights_;
  ::zjchain::sync::protobuf::SyncInfo* sync_;
  ::zjchain::sync::protobuf::SyncMessage* sync_proto_;
  ::zjchain::vss::protobuf::VssMessage* vss_proto_;
  ::zjchain::block::protobuf::CrossShardingTosMessage* cross_tos_;
  ::zjchain::block::protobuf::CrossShardingStatisticMessage* cross_statistic_;
  ::zjchain::block::protobuf::ElectBlockMessage* elect_block_;
  ::zjchain::init::protobuf::InitMessage* init_proto_;
  ::zjchain::pools::protobuf::SyncPoolsMaxHeight* sync_heights_;
  ::zjchain::block::protobuf::Block* block_;
  ::google::protobuf::RepeatedPtrField< ::zjchain::pools::protobuf::InvalidBftMessage > invalid_bfts_;
  ::zjchain::c2c::protobuf::C2cMessage* c2c_;
  ::google::protobuf::uint32 from_public_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(30 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2ftransport_2eproto();
  friend void protobuf_AssignDesc_protos_2ftransport_2eproto();
  friend void protobuf_ShutdownFile_protos_2ftransport_2eproto();

  void InitAsDefaultInstance();
  static Header* default_instance_;
};
// ===================================================================


// ===================================================================

// BroadcastParam

// optional uint32 type = 1;
inline bool BroadcastParam::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BroadcastParam::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BroadcastParam::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BroadcastParam::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 BroadcastParam::type() const {
  return type_;
}
inline void BroadcastParam::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 neighbor_count = 2 [default = 7];
inline bool BroadcastParam::has_neighbor_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BroadcastParam::set_has_neighbor_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BroadcastParam::clear_has_neighbor_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BroadcastParam::clear_neighbor_count() {
  neighbor_count_ = 7u;
  clear_has_neighbor_count();
}
inline ::google::protobuf::uint32 BroadcastParam::neighbor_count() const {
  return neighbor_count_;
}
inline void BroadcastParam::set_neighbor_count(::google::protobuf::uint32 value) {
  set_has_neighbor_count();
  neighbor_count_ = value;
}

// optional uint32 stop_times = 3;
inline bool BroadcastParam::has_stop_times() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BroadcastParam::set_has_stop_times() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BroadcastParam::clear_has_stop_times() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BroadcastParam::clear_stop_times() {
  stop_times_ = 0u;
  clear_has_stop_times();
}
inline ::google::protobuf::uint32 BroadcastParam::stop_times() const {
  return stop_times_;
}
inline void BroadcastParam::set_stop_times(::google::protobuf::uint32 value) {
  set_has_stop_times();
  stop_times_ = value;
}

// optional uint32 hop_limit = 4 [default = 10];
inline bool BroadcastParam::has_hop_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BroadcastParam::set_has_hop_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BroadcastParam::clear_has_hop_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BroadcastParam::clear_hop_limit() {
  hop_limit_ = 10u;
  clear_has_hop_limit();
}
inline ::google::protobuf::uint32 BroadcastParam::hop_limit() const {
  return hop_limit_;
}
inline void BroadcastParam::set_hop_limit(::google::protobuf::uint32 value) {
  set_has_hop_limit();
  hop_limit_ = value;
}

// optional uint64 layer_left = 5;
inline bool BroadcastParam::has_layer_left() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BroadcastParam::set_has_layer_left() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BroadcastParam::clear_has_layer_left() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BroadcastParam::clear_layer_left() {
  layer_left_ = GOOGLE_ULONGLONG(0);
  clear_has_layer_left();
}
inline ::google::protobuf::uint64 BroadcastParam::layer_left() const {
  return layer_left_;
}
inline void BroadcastParam::set_layer_left(::google::protobuf::uint64 value) {
  set_has_layer_left();
  layer_left_ = value;
}

// optional uint64 layer_right = 6;
inline bool BroadcastParam::has_layer_right() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BroadcastParam::set_has_layer_right() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BroadcastParam::clear_has_layer_right() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BroadcastParam::clear_layer_right() {
  layer_right_ = GOOGLE_ULONGLONG(0);
  clear_has_layer_right();
}
inline ::google::protobuf::uint64 BroadcastParam::layer_right() const {
  return layer_right_;
}
inline void BroadcastParam::set_layer_right(::google::protobuf::uint64 value) {
  set_has_layer_right();
  layer_right_ = value;
}

// optional float overlap = 7;
inline bool BroadcastParam::has_overlap() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BroadcastParam::set_has_overlap() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BroadcastParam::clear_has_overlap() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BroadcastParam::clear_overlap() {
  overlap_ = 0;
  clear_has_overlap();
}
inline float BroadcastParam::overlap() const {
  return overlap_;
}
inline void BroadcastParam::set_overlap(float value) {
  set_has_overlap();
  overlap_ = value;
}

// optional uint32 hop_to_layer = 8 [default = 1];
inline bool BroadcastParam::has_hop_to_layer() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BroadcastParam::set_has_hop_to_layer() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BroadcastParam::clear_has_hop_to_layer() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BroadcastParam::clear_hop_to_layer() {
  hop_to_layer_ = 1u;
  clear_has_hop_to_layer();
}
inline ::google::protobuf::uint32 BroadcastParam::hop_to_layer() const {
  return hop_to_layer_;
}
inline void BroadcastParam::set_hop_to_layer(::google::protobuf::uint32 value) {
  set_has_hop_to_layer();
  hop_to_layer_ = value;
}

// optional bytes header = 9;
inline bool BroadcastParam::has_header() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BroadcastParam::set_has_header() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BroadcastParam::clear_has_header() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BroadcastParam::clear_header() {
  if (header_ != &::google::protobuf::internal::kEmptyString) {
    header_->clear();
  }
  clear_has_header();
}
inline const ::std::string& BroadcastParam::header() const {
  return *header_;
}
inline void BroadcastParam::set_header(const ::std::string& value) {
  set_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    header_ = new ::std::string;
  }
  header_->assign(value);
}
inline void BroadcastParam::set_header(const char* value) {
  set_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    header_ = new ::std::string;
  }
  header_->assign(value);
}
inline void BroadcastParam::set_header(const void* value, size_t size) {
  set_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    header_ = new ::std::string;
  }
  header_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BroadcastParam::mutable_header() {
  set_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    header_ = new ::std::string;
  }
  return header_;
}
inline ::std::string* BroadcastParam::release_header() {
  clear_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = header_;
    header_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BroadcastParam::set_allocated_header(::std::string* header) {
  if (header_ != &::google::protobuf::internal::kEmptyString) {
    delete header_;
  }
  if (header) {
    set_has_header();
    header_ = header;
  } else {
    clear_has_header();
    header_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes body = 10;
inline bool BroadcastParam::has_body() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BroadcastParam::set_has_body() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BroadcastParam::clear_has_body() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BroadcastParam::clear_body() {
  if (body_ != &::google::protobuf::internal::kEmptyString) {
    body_->clear();
  }
  clear_has_body();
}
inline const ::std::string& BroadcastParam::body() const {
  return *body_;
}
inline void BroadcastParam::set_body(const ::std::string& value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(value);
}
inline void BroadcastParam::set_body(const char* value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(value);
}
inline void BroadcastParam::set_body(const void* value, size_t size) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BroadcastParam::mutable_body() {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  return body_;
}
inline ::std::string* BroadcastParam::release_body() {
  clear_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = body_;
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BroadcastParam::set_allocated_body(::std::string* body) {
  if (body_ != &::google::protobuf::internal::kEmptyString) {
    delete body_;
  }
  if (body) {
    set_has_body();
    body_ = body;
  } else {
    clear_has_body();
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool net_crossed = 11;
inline bool BroadcastParam::has_net_crossed() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BroadcastParam::set_has_net_crossed() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BroadcastParam::clear_has_net_crossed() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BroadcastParam::clear_net_crossed() {
  net_crossed_ = false;
  clear_has_net_crossed();
}
inline bool BroadcastParam::net_crossed() const {
  return net_crossed_;
}
inline void BroadcastParam::set_net_crossed(bool value) {
  set_has_net_crossed();
  net_crossed_ = value;
}

// repeated uint64 bloomfilter = 12;
inline int BroadcastParam::bloomfilter_size() const {
  return bloomfilter_.size();
}
inline void BroadcastParam::clear_bloomfilter() {
  bloomfilter_.Clear();
}
inline ::google::protobuf::uint64 BroadcastParam::bloomfilter(int index) const {
  return bloomfilter_.Get(index);
}
inline void BroadcastParam::set_bloomfilter(int index, ::google::protobuf::uint64 value) {
  bloomfilter_.Set(index, value);
}
inline void BroadcastParam::add_bloomfilter(::google::protobuf::uint64 value) {
  bloomfilter_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
BroadcastParam::bloomfilter() const {
  return bloomfilter_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
BroadcastParam::mutable_bloomfilter() {
  return &bloomfilter_;
}

// optional float evil_rate = 13 [default = 0];
inline bool BroadcastParam::has_evil_rate() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BroadcastParam::set_has_evil_rate() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BroadcastParam::clear_has_evil_rate() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BroadcastParam::clear_evil_rate() {
  evil_rate_ = 0;
  clear_has_evil_rate();
}
inline float BroadcastParam::evil_rate() const {
  return evil_rate_;
}
inline void BroadcastParam::set_evil_rate(float value) {
  set_has_evil_rate();
  evil_rate_ = value;
}

// optional uint32 ign_bloomfilter_hop = 14 [default = 1];
inline bool BroadcastParam::has_ign_bloomfilter_hop() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BroadcastParam::set_has_ign_bloomfilter_hop() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BroadcastParam::clear_has_ign_bloomfilter_hop() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BroadcastParam::clear_ign_bloomfilter_hop() {
  ign_bloomfilter_hop_ = 1u;
  clear_has_ign_bloomfilter_hop();
}
inline ::google::protobuf::uint32 BroadcastParam::ign_bloomfilter_hop() const {
  return ign_bloomfilter_hop_;
}
inline void BroadcastParam::set_ign_bloomfilter_hop(::google::protobuf::uint32 value) {
  set_has_ign_bloomfilter_hop();
  ign_bloomfilter_hop_ = value;
}

// -------------------------------------------------------------------

// Header

// optional int32 src_sharding_id = 1;
inline bool Header::has_src_sharding_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_src_sharding_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_src_sharding_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_src_sharding_id() {
  src_sharding_id_ = 0;
  clear_has_src_sharding_id();
}
inline ::google::protobuf::int32 Header::src_sharding_id() const {
  return src_sharding_id_;
}
inline void Header::set_src_sharding_id(::google::protobuf::int32 value) {
  set_has_src_sharding_id();
  src_sharding_id_ = value;
}

// optional bytes des_dht_key = 2;
inline bool Header::has_des_dht_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_des_dht_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_des_dht_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_des_dht_key() {
  if (des_dht_key_ != &::google::protobuf::internal::kEmptyString) {
    des_dht_key_->clear();
  }
  clear_has_des_dht_key();
}
inline const ::std::string& Header::des_dht_key() const {
  return *des_dht_key_;
}
inline void Header::set_des_dht_key(const ::std::string& value) {
  set_has_des_dht_key();
  if (des_dht_key_ == &::google::protobuf::internal::kEmptyString) {
    des_dht_key_ = new ::std::string;
  }
  des_dht_key_->assign(value);
}
inline void Header::set_des_dht_key(const char* value) {
  set_has_des_dht_key();
  if (des_dht_key_ == &::google::protobuf::internal::kEmptyString) {
    des_dht_key_ = new ::std::string;
  }
  des_dht_key_->assign(value);
}
inline void Header::set_des_dht_key(const void* value, size_t size) {
  set_has_des_dht_key();
  if (des_dht_key_ == &::google::protobuf::internal::kEmptyString) {
    des_dht_key_ = new ::std::string;
  }
  des_dht_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header::mutable_des_dht_key() {
  set_has_des_dht_key();
  if (des_dht_key_ == &::google::protobuf::internal::kEmptyString) {
    des_dht_key_ = new ::std::string;
  }
  return des_dht_key_;
}
inline ::std::string* Header::release_des_dht_key() {
  clear_has_des_dht_key();
  if (des_dht_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = des_dht_key_;
    des_dht_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Header::set_allocated_des_dht_key(::std::string* des_dht_key) {
  if (des_dht_key_ != &::google::protobuf::internal::kEmptyString) {
    delete des_dht_key_;
  }
  if (des_dht_key) {
    set_has_des_dht_key();
    des_dht_key_ = des_dht_key;
  } else {
    clear_has_des_dht_key();
    des_dht_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 hop_count = 3 [default = 0];
inline bool Header::has_hop_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_hop_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_hop_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_hop_count() {
  hop_count_ = 0u;
  clear_has_hop_count();
}
inline ::google::protobuf::uint32 Header::hop_count() const {
  return hop_count_;
}
inline void Header::set_hop_count(::google::protobuf::uint32 value) {
  set_has_hop_count();
  hop_count_ = value;
}

// optional bytes debug = 4;
inline bool Header::has_debug() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Header::set_has_debug() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Header::clear_has_debug() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Header::clear_debug() {
  if (debug_ != &::google::protobuf::internal::kEmptyString) {
    debug_->clear();
  }
  clear_has_debug();
}
inline const ::std::string& Header::debug() const {
  return *debug_;
}
inline void Header::set_debug(const ::std::string& value) {
  set_has_debug();
  if (debug_ == &::google::protobuf::internal::kEmptyString) {
    debug_ = new ::std::string;
  }
  debug_->assign(value);
}
inline void Header::set_debug(const char* value) {
  set_has_debug();
  if (debug_ == &::google::protobuf::internal::kEmptyString) {
    debug_ = new ::std::string;
  }
  debug_->assign(value);
}
inline void Header::set_debug(const void* value, size_t size) {
  set_has_debug();
  if (debug_ == &::google::protobuf::internal::kEmptyString) {
    debug_ = new ::std::string;
  }
  debug_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header::mutable_debug() {
  set_has_debug();
  if (debug_ == &::google::protobuf::internal::kEmptyString) {
    debug_ = new ::std::string;
  }
  return debug_;
}
inline ::std::string* Header::release_debug() {
  clear_has_debug();
  if (debug_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_;
    debug_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Header::set_allocated_debug(::std::string* debug) {
  if (debug_ != &::google::protobuf::internal::kEmptyString) {
    delete debug_;
  }
  if (debug) {
    set_has_debug();
    debug_ = debug;
  } else {
    clear_has_debug();
    debug_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 hash64 = 5;
inline bool Header::has_hash64() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Header::set_has_hash64() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Header::clear_has_hash64() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Header::clear_hash64() {
  hash64_ = GOOGLE_ULONGLONG(0);
  clear_has_hash64();
}
inline ::google::protobuf::uint64 Header::hash64() const {
  return hash64_;
}
inline void Header::set_hash64(::google::protobuf::uint64 value) {
  set_has_hash64();
  hash64_ = value;
}

// optional uint32 type = 6;
inline bool Header::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Header::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Header::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Header::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Header::type() const {
  return type_;
}
inline void Header::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional .zjchain.transport.protobuf.BroadcastParam broadcast = 7;
inline bool Header::has_broadcast() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Header::set_has_broadcast() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Header::clear_has_broadcast() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Header::clear_broadcast() {
  if (broadcast_ != NULL) broadcast_->::zjchain::transport::protobuf::BroadcastParam::Clear();
  clear_has_broadcast();
}
inline const ::zjchain::transport::protobuf::BroadcastParam& Header::broadcast() const {
  return broadcast_ != NULL ? *broadcast_ : *default_instance_->broadcast_;
}
inline ::zjchain::transport::protobuf::BroadcastParam* Header::mutable_broadcast() {
  set_has_broadcast();
  if (broadcast_ == NULL) broadcast_ = new ::zjchain::transport::protobuf::BroadcastParam;
  return broadcast_;
}
inline ::zjchain::transport::protobuf::BroadcastParam* Header::release_broadcast() {
  clear_has_broadcast();
  ::zjchain::transport::protobuf::BroadcastParam* temp = broadcast_;
  broadcast_ = NULL;
  return temp;
}
inline void Header::set_allocated_broadcast(::zjchain::transport::protobuf::BroadcastParam* broadcast) {
  delete broadcast_;
  broadcast_ = broadcast;
  if (broadcast) {
    set_has_broadcast();
  } else {
    clear_has_broadcast();
  }
}

// optional bytes sign = 8;
inline bool Header::has_sign() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Header::set_has_sign() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Header::clear_has_sign() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Header::clear_sign() {
  if (sign_ != &::google::protobuf::internal::kEmptyString) {
    sign_->clear();
  }
  clear_has_sign();
}
inline const ::std::string& Header::sign() const {
  return *sign_;
}
inline void Header::set_sign(const ::std::string& value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void Header::set_sign(const char* value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void Header::set_sign(const void* value, size_t size) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header::mutable_sign() {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  return sign_;
}
inline ::std::string* Header::release_sign() {
  clear_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sign_;
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Header::set_allocated_sign(::std::string* sign) {
  if (sign_ != &::google::protobuf::internal::kEmptyString) {
    delete sign_;
  }
  if (sign) {
    set_has_sign();
    sign_ = sign;
  } else {
    clear_has_sign();
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 version = 9 [default = 0];
inline bool Header::has_version() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Header::set_has_version() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Header::clear_has_version() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Header::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 Header::version() const {
  return version_;
}
inline void Header::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// optional .zjchain.network.protobuf.NetworkMessage network_proto = 10;
inline bool Header::has_network_proto() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Header::set_has_network_proto() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Header::clear_has_network_proto() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Header::clear_network_proto() {
  if (network_proto_ != NULL) network_proto_->::zjchain::network::protobuf::NetworkMessage::Clear();
  clear_has_network_proto();
}
inline const ::zjchain::network::protobuf::NetworkMessage& Header::network_proto() const {
  return network_proto_ != NULL ? *network_proto_ : *default_instance_->network_proto_;
}
inline ::zjchain::network::protobuf::NetworkMessage* Header::mutable_network_proto() {
  set_has_network_proto();
  if (network_proto_ == NULL) network_proto_ = new ::zjchain::network::protobuf::NetworkMessage;
  return network_proto_;
}
inline ::zjchain::network::protobuf::NetworkMessage* Header::release_network_proto() {
  clear_has_network_proto();
  ::zjchain::network::protobuf::NetworkMessage* temp = network_proto_;
  network_proto_ = NULL;
  return temp;
}
inline void Header::set_allocated_network_proto(::zjchain::network::protobuf::NetworkMessage* network_proto) {
  delete network_proto_;
  network_proto_ = network_proto;
  if (network_proto) {
    set_has_network_proto();
  } else {
    clear_has_network_proto();
  }
}

// optional .zjchain.dht.protobuf.DhtMessage dht_proto = 11;
inline bool Header::has_dht_proto() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Header::set_has_dht_proto() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Header::clear_has_dht_proto() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Header::clear_dht_proto() {
  if (dht_proto_ != NULL) dht_proto_->::zjchain::dht::protobuf::DhtMessage::Clear();
  clear_has_dht_proto();
}
inline const ::zjchain::dht::protobuf::DhtMessage& Header::dht_proto() const {
  return dht_proto_ != NULL ? *dht_proto_ : *default_instance_->dht_proto_;
}
inline ::zjchain::dht::protobuf::DhtMessage* Header::mutable_dht_proto() {
  set_has_dht_proto();
  if (dht_proto_ == NULL) dht_proto_ = new ::zjchain::dht::protobuf::DhtMessage;
  return dht_proto_;
}
inline ::zjchain::dht::protobuf::DhtMessage* Header::release_dht_proto() {
  clear_has_dht_proto();
  ::zjchain::dht::protobuf::DhtMessage* temp = dht_proto_;
  dht_proto_ = NULL;
  return temp;
}
inline void Header::set_allocated_dht_proto(::zjchain::dht::protobuf::DhtMessage* dht_proto) {
  delete dht_proto_;
  dht_proto_ = dht_proto;
  if (dht_proto) {
    set_has_dht_proto();
  } else {
    clear_has_dht_proto();
  }
}

// optional .zjchain.bls.protobuf.BlsMessage bls_proto = 12;
inline bool Header::has_bls_proto() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Header::set_has_bls_proto() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Header::clear_has_bls_proto() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Header::clear_bls_proto() {
  if (bls_proto_ != NULL) bls_proto_->::zjchain::bls::protobuf::BlsMessage::Clear();
  clear_has_bls_proto();
}
inline const ::zjchain::bls::protobuf::BlsMessage& Header::bls_proto() const {
  return bls_proto_ != NULL ? *bls_proto_ : *default_instance_->bls_proto_;
}
inline ::zjchain::bls::protobuf::BlsMessage* Header::mutable_bls_proto() {
  set_has_bls_proto();
  if (bls_proto_ == NULL) bls_proto_ = new ::zjchain::bls::protobuf::BlsMessage;
  return bls_proto_;
}
inline ::zjchain::bls::protobuf::BlsMessage* Header::release_bls_proto() {
  clear_has_bls_proto();
  ::zjchain::bls::protobuf::BlsMessage* temp = bls_proto_;
  bls_proto_ = NULL;
  return temp;
}
inline void Header::set_allocated_bls_proto(::zjchain::bls::protobuf::BlsMessage* bls_proto) {
  delete bls_proto_;
  bls_proto_ = bls_proto;
  if (bls_proto) {
    set_has_bls_proto();
  } else {
    clear_has_bls_proto();
  }
}

// optional .zjchain.pools.protobuf.TxMessage tx_proto = 13;
inline bool Header::has_tx_proto() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Header::set_has_tx_proto() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Header::clear_has_tx_proto() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Header::clear_tx_proto() {
  if (tx_proto_ != NULL) tx_proto_->::zjchain::pools::protobuf::TxMessage::Clear();
  clear_has_tx_proto();
}
inline const ::zjchain::pools::protobuf::TxMessage& Header::tx_proto() const {
  return tx_proto_ != NULL ? *tx_proto_ : *default_instance_->tx_proto_;
}
inline ::zjchain::pools::protobuf::TxMessage* Header::mutable_tx_proto() {
  set_has_tx_proto();
  if (tx_proto_ == NULL) tx_proto_ = new ::zjchain::pools::protobuf::TxMessage;
  return tx_proto_;
}
inline ::zjchain::pools::protobuf::TxMessage* Header::release_tx_proto() {
  clear_has_tx_proto();
  ::zjchain::pools::protobuf::TxMessage* temp = tx_proto_;
  tx_proto_ = NULL;
  return temp;
}
inline void Header::set_allocated_tx_proto(::zjchain::pools::protobuf::TxMessage* tx_proto) {
  delete tx_proto_;
  tx_proto_ = tx_proto;
  if (tx_proto) {
    set_has_tx_proto();
  } else {
    clear_has_tx_proto();
  }
}

// optional .zjchain.contract.protobuf.ContractMessage contract_proto = 14;
inline bool Header::has_contract_proto() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Header::set_has_contract_proto() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Header::clear_has_contract_proto() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Header::clear_contract_proto() {
  if (contract_proto_ != NULL) contract_proto_->::zjchain::contract::protobuf::ContractMessage::Clear();
  clear_has_contract_proto();
}
inline const ::zjchain::contract::protobuf::ContractMessage& Header::contract_proto() const {
  return contract_proto_ != NULL ? *contract_proto_ : *default_instance_->contract_proto_;
}
inline ::zjchain::contract::protobuf::ContractMessage* Header::mutable_contract_proto() {
  set_has_contract_proto();
  if (contract_proto_ == NULL) contract_proto_ = new ::zjchain::contract::protobuf::ContractMessage;
  return contract_proto_;
}
inline ::zjchain::contract::protobuf::ContractMessage* Header::release_contract_proto() {
  clear_has_contract_proto();
  ::zjchain::contract::protobuf::ContractMessage* temp = contract_proto_;
  contract_proto_ = NULL;
  return temp;
}
inline void Header::set_allocated_contract_proto(::zjchain::contract::protobuf::ContractMessage* contract_proto) {
  delete contract_proto_;
  contract_proto_ = contract_proto;
  if (contract_proto) {
    set_has_contract_proto();
  } else {
    clear_has_contract_proto();
  }
}

// optional .zjchain.elect.protobuf.ElectMessage elect_proto = 15;
inline bool Header::has_elect_proto() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Header::set_has_elect_proto() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Header::clear_has_elect_proto() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Header::clear_elect_proto() {
  if (elect_proto_ != NULL) elect_proto_->::zjchain::elect::protobuf::ElectMessage::Clear();
  clear_has_elect_proto();
}
inline const ::zjchain::elect::protobuf::ElectMessage& Header::elect_proto() const {
  return elect_proto_ != NULL ? *elect_proto_ : *default_instance_->elect_proto_;
}
inline ::zjchain::elect::protobuf::ElectMessage* Header::mutable_elect_proto() {
  set_has_elect_proto();
  if (elect_proto_ == NULL) elect_proto_ = new ::zjchain::elect::protobuf::ElectMessage;
  return elect_proto_;
}
inline ::zjchain::elect::protobuf::ElectMessage* Header::release_elect_proto() {
  clear_has_elect_proto();
  ::zjchain::elect::protobuf::ElectMessage* temp = elect_proto_;
  elect_proto_ = NULL;
  return temp;
}
inline void Header::set_allocated_elect_proto(::zjchain::elect::protobuf::ElectMessage* elect_proto) {
  delete elect_proto_;
  elect_proto_ = elect_proto;
  if (elect_proto) {
    set_has_elect_proto();
  } else {
    clear_has_elect_proto();
  }
}

// optional .zjchain.zbft.protobuf.ZbftMessage zbft = 16;
inline bool Header::has_zbft() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Header::set_has_zbft() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Header::clear_has_zbft() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Header::clear_zbft() {
  if (zbft_ != NULL) zbft_->::zjchain::zbft::protobuf::ZbftMessage::Clear();
  clear_has_zbft();
}
inline const ::zjchain::zbft::protobuf::ZbftMessage& Header::zbft() const {
  return zbft_ != NULL ? *zbft_ : *default_instance_->zbft_;
}
inline ::zjchain::zbft::protobuf::ZbftMessage* Header::mutable_zbft() {
  set_has_zbft();
  if (zbft_ == NULL) zbft_ = new ::zjchain::zbft::protobuf::ZbftMessage;
  return zbft_;
}
inline ::zjchain::zbft::protobuf::ZbftMessage* Header::release_zbft() {
  clear_has_zbft();
  ::zjchain::zbft::protobuf::ZbftMessage* temp = zbft_;
  zbft_ = NULL;
  return temp;
}
inline void Header::set_allocated_zbft(::zjchain::zbft::protobuf::ZbftMessage* zbft) {
  delete zbft_;
  zbft_ = zbft;
  if (zbft) {
    set_has_zbft();
  } else {
    clear_has_zbft();
  }
}

// optional .zjchain.block.protobuf.BlockMessage block_proto = 17;
inline bool Header::has_block_proto() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Header::set_has_block_proto() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Header::clear_has_block_proto() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Header::clear_block_proto() {
  if (block_proto_ != NULL) block_proto_->::zjchain::block::protobuf::BlockMessage::Clear();
  clear_has_block_proto();
}
inline const ::zjchain::block::protobuf::BlockMessage& Header::block_proto() const {
  return block_proto_ != NULL ? *block_proto_ : *default_instance_->block_proto_;
}
inline ::zjchain::block::protobuf::BlockMessage* Header::mutable_block_proto() {
  set_has_block_proto();
  if (block_proto_ == NULL) block_proto_ = new ::zjchain::block::protobuf::BlockMessage;
  return block_proto_;
}
inline ::zjchain::block::protobuf::BlockMessage* Header::release_block_proto() {
  clear_has_block_proto();
  ::zjchain::block::protobuf::BlockMessage* temp = block_proto_;
  block_proto_ = NULL;
  return temp;
}
inline void Header::set_allocated_block_proto(::zjchain::block::protobuf::BlockMessage* block_proto) {
  delete block_proto_;
  block_proto_ = block_proto;
  if (block_proto) {
    set_has_block_proto();
  } else {
    clear_has_block_proto();
  }
}

// optional .zjchain.pools.protobuf.ToTxHeights to_tx_heights = 18;
inline bool Header::has_to_tx_heights() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Header::set_has_to_tx_heights() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Header::clear_has_to_tx_heights() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Header::clear_to_tx_heights() {
  if (to_tx_heights_ != NULL) to_tx_heights_->::zjchain::pools::protobuf::ToTxHeights::Clear();
  clear_has_to_tx_heights();
}
inline const ::zjchain::pools::protobuf::ToTxHeights& Header::to_tx_heights() const {
  return to_tx_heights_ != NULL ? *to_tx_heights_ : *default_instance_->to_tx_heights_;
}
inline ::zjchain::pools::protobuf::ToTxHeights* Header::mutable_to_tx_heights() {
  set_has_to_tx_heights();
  if (to_tx_heights_ == NULL) to_tx_heights_ = new ::zjchain::pools::protobuf::ToTxHeights;
  return to_tx_heights_;
}
inline ::zjchain::pools::protobuf::ToTxHeights* Header::release_to_tx_heights() {
  clear_has_to_tx_heights();
  ::zjchain::pools::protobuf::ToTxHeights* temp = to_tx_heights_;
  to_tx_heights_ = NULL;
  return temp;
}
inline void Header::set_allocated_to_tx_heights(::zjchain::pools::protobuf::ToTxHeights* to_tx_heights) {
  delete to_tx_heights_;
  to_tx_heights_ = to_tx_heights;
  if (to_tx_heights) {
    set_has_to_tx_heights();
  } else {
    clear_has_to_tx_heights();
  }
}

// optional .zjchain.sync.protobuf.SyncInfo sync = 19;
inline bool Header::has_sync() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Header::set_has_sync() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Header::clear_has_sync() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Header::clear_sync() {
  if (sync_ != NULL) sync_->::zjchain::sync::protobuf::SyncInfo::Clear();
  clear_has_sync();
}
inline const ::zjchain::sync::protobuf::SyncInfo& Header::sync() const {
  return sync_ != NULL ? *sync_ : *default_instance_->sync_;
}
inline ::zjchain::sync::protobuf::SyncInfo* Header::mutable_sync() {
  set_has_sync();
  if (sync_ == NULL) sync_ = new ::zjchain::sync::protobuf::SyncInfo;
  return sync_;
}
inline ::zjchain::sync::protobuf::SyncInfo* Header::release_sync() {
  clear_has_sync();
  ::zjchain::sync::protobuf::SyncInfo* temp = sync_;
  sync_ = NULL;
  return temp;
}
inline void Header::set_allocated_sync(::zjchain::sync::protobuf::SyncInfo* sync) {
  delete sync_;
  sync_ = sync;
  if (sync) {
    set_has_sync();
  } else {
    clear_has_sync();
  }
}

// optional .zjchain.sync.protobuf.SyncMessage sync_proto = 20;
inline bool Header::has_sync_proto() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Header::set_has_sync_proto() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Header::clear_has_sync_proto() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Header::clear_sync_proto() {
  if (sync_proto_ != NULL) sync_proto_->::zjchain::sync::protobuf::SyncMessage::Clear();
  clear_has_sync_proto();
}
inline const ::zjchain::sync::protobuf::SyncMessage& Header::sync_proto() const {
  return sync_proto_ != NULL ? *sync_proto_ : *default_instance_->sync_proto_;
}
inline ::zjchain::sync::protobuf::SyncMessage* Header::mutable_sync_proto() {
  set_has_sync_proto();
  if (sync_proto_ == NULL) sync_proto_ = new ::zjchain::sync::protobuf::SyncMessage;
  return sync_proto_;
}
inline ::zjchain::sync::protobuf::SyncMessage* Header::release_sync_proto() {
  clear_has_sync_proto();
  ::zjchain::sync::protobuf::SyncMessage* temp = sync_proto_;
  sync_proto_ = NULL;
  return temp;
}
inline void Header::set_allocated_sync_proto(::zjchain::sync::protobuf::SyncMessage* sync_proto) {
  delete sync_proto_;
  sync_proto_ = sync_proto;
  if (sync_proto) {
    set_has_sync_proto();
  } else {
    clear_has_sync_proto();
  }
}

// optional .zjchain.vss.protobuf.VssMessage vss_proto = 21;
inline bool Header::has_vss_proto() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Header::set_has_vss_proto() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Header::clear_has_vss_proto() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Header::clear_vss_proto() {
  if (vss_proto_ != NULL) vss_proto_->::zjchain::vss::protobuf::VssMessage::Clear();
  clear_has_vss_proto();
}
inline const ::zjchain::vss::protobuf::VssMessage& Header::vss_proto() const {
  return vss_proto_ != NULL ? *vss_proto_ : *default_instance_->vss_proto_;
}
inline ::zjchain::vss::protobuf::VssMessage* Header::mutable_vss_proto() {
  set_has_vss_proto();
  if (vss_proto_ == NULL) vss_proto_ = new ::zjchain::vss::protobuf::VssMessage;
  return vss_proto_;
}
inline ::zjchain::vss::protobuf::VssMessage* Header::release_vss_proto() {
  clear_has_vss_proto();
  ::zjchain::vss::protobuf::VssMessage* temp = vss_proto_;
  vss_proto_ = NULL;
  return temp;
}
inline void Header::set_allocated_vss_proto(::zjchain::vss::protobuf::VssMessage* vss_proto) {
  delete vss_proto_;
  vss_proto_ = vss_proto;
  if (vss_proto) {
    set_has_vss_proto();
  } else {
    clear_has_vss_proto();
  }
}

// optional .zjchain.block.protobuf.CrossShardingTosMessage cross_tos = 22;
inline bool Header::has_cross_tos() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Header::set_has_cross_tos() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Header::clear_has_cross_tos() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Header::clear_cross_tos() {
  if (cross_tos_ != NULL) cross_tos_->::zjchain::block::protobuf::CrossShardingTosMessage::Clear();
  clear_has_cross_tos();
}
inline const ::zjchain::block::protobuf::CrossShardingTosMessage& Header::cross_tos() const {
  return cross_tos_ != NULL ? *cross_tos_ : *default_instance_->cross_tos_;
}
inline ::zjchain::block::protobuf::CrossShardingTosMessage* Header::mutable_cross_tos() {
  set_has_cross_tos();
  if (cross_tos_ == NULL) cross_tos_ = new ::zjchain::block::protobuf::CrossShardingTosMessage;
  return cross_tos_;
}
inline ::zjchain::block::protobuf::CrossShardingTosMessage* Header::release_cross_tos() {
  clear_has_cross_tos();
  ::zjchain::block::protobuf::CrossShardingTosMessage* temp = cross_tos_;
  cross_tos_ = NULL;
  return temp;
}
inline void Header::set_allocated_cross_tos(::zjchain::block::protobuf::CrossShardingTosMessage* cross_tos) {
  delete cross_tos_;
  cross_tos_ = cross_tos;
  if (cross_tos) {
    set_has_cross_tos();
  } else {
    clear_has_cross_tos();
  }
}

// optional .zjchain.block.protobuf.CrossShardingStatisticMessage cross_statistic = 23;
inline bool Header::has_cross_statistic() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Header::set_has_cross_statistic() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Header::clear_has_cross_statistic() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Header::clear_cross_statistic() {
  if (cross_statistic_ != NULL) cross_statistic_->::zjchain::block::protobuf::CrossShardingStatisticMessage::Clear();
  clear_has_cross_statistic();
}
inline const ::zjchain::block::protobuf::CrossShardingStatisticMessage& Header::cross_statistic() const {
  return cross_statistic_ != NULL ? *cross_statistic_ : *default_instance_->cross_statistic_;
}
inline ::zjchain::block::protobuf::CrossShardingStatisticMessage* Header::mutable_cross_statistic() {
  set_has_cross_statistic();
  if (cross_statistic_ == NULL) cross_statistic_ = new ::zjchain::block::protobuf::CrossShardingStatisticMessage;
  return cross_statistic_;
}
inline ::zjchain::block::protobuf::CrossShardingStatisticMessage* Header::release_cross_statistic() {
  clear_has_cross_statistic();
  ::zjchain::block::protobuf::CrossShardingStatisticMessage* temp = cross_statistic_;
  cross_statistic_ = NULL;
  return temp;
}
inline void Header::set_allocated_cross_statistic(::zjchain::block::protobuf::CrossShardingStatisticMessage* cross_statistic) {
  delete cross_statistic_;
  cross_statistic_ = cross_statistic;
  if (cross_statistic) {
    set_has_cross_statistic();
  } else {
    clear_has_cross_statistic();
  }
}

// optional .zjchain.block.protobuf.ElectBlockMessage elect_block = 24;
inline bool Header::has_elect_block() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Header::set_has_elect_block() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Header::clear_has_elect_block() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Header::clear_elect_block() {
  if (elect_block_ != NULL) elect_block_->::zjchain::block::protobuf::ElectBlockMessage::Clear();
  clear_has_elect_block();
}
inline const ::zjchain::block::protobuf::ElectBlockMessage& Header::elect_block() const {
  return elect_block_ != NULL ? *elect_block_ : *default_instance_->elect_block_;
}
inline ::zjchain::block::protobuf::ElectBlockMessage* Header::mutable_elect_block() {
  set_has_elect_block();
  if (elect_block_ == NULL) elect_block_ = new ::zjchain::block::protobuf::ElectBlockMessage;
  return elect_block_;
}
inline ::zjchain::block::protobuf::ElectBlockMessage* Header::release_elect_block() {
  clear_has_elect_block();
  ::zjchain::block::protobuf::ElectBlockMessage* temp = elect_block_;
  elect_block_ = NULL;
  return temp;
}
inline void Header::set_allocated_elect_block(::zjchain::block::protobuf::ElectBlockMessage* elect_block) {
  delete elect_block_;
  elect_block_ = elect_block;
  if (elect_block) {
    set_has_elect_block();
  } else {
    clear_has_elect_block();
  }
}

// optional .zjchain.init.protobuf.InitMessage init_proto = 25;
inline bool Header::has_init_proto() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Header::set_has_init_proto() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Header::clear_has_init_proto() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Header::clear_init_proto() {
  if (init_proto_ != NULL) init_proto_->::zjchain::init::protobuf::InitMessage::Clear();
  clear_has_init_proto();
}
inline const ::zjchain::init::protobuf::InitMessage& Header::init_proto() const {
  return init_proto_ != NULL ? *init_proto_ : *default_instance_->init_proto_;
}
inline ::zjchain::init::protobuf::InitMessage* Header::mutable_init_proto() {
  set_has_init_proto();
  if (init_proto_ == NULL) init_proto_ = new ::zjchain::init::protobuf::InitMessage;
  return init_proto_;
}
inline ::zjchain::init::protobuf::InitMessage* Header::release_init_proto() {
  clear_has_init_proto();
  ::zjchain::init::protobuf::InitMessage* temp = init_proto_;
  init_proto_ = NULL;
  return temp;
}
inline void Header::set_allocated_init_proto(::zjchain::init::protobuf::InitMessage* init_proto) {
  delete init_proto_;
  init_proto_ = init_proto;
  if (init_proto) {
    set_has_init_proto();
  } else {
    clear_has_init_proto();
  }
}

// optional .zjchain.pools.protobuf.SyncPoolsMaxHeight sync_heights = 26;
inline bool Header::has_sync_heights() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Header::set_has_sync_heights() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Header::clear_has_sync_heights() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Header::clear_sync_heights() {
  if (sync_heights_ != NULL) sync_heights_->::zjchain::pools::protobuf::SyncPoolsMaxHeight::Clear();
  clear_has_sync_heights();
}
inline const ::zjchain::pools::protobuf::SyncPoolsMaxHeight& Header::sync_heights() const {
  return sync_heights_ != NULL ? *sync_heights_ : *default_instance_->sync_heights_;
}
inline ::zjchain::pools::protobuf::SyncPoolsMaxHeight* Header::mutable_sync_heights() {
  set_has_sync_heights();
  if (sync_heights_ == NULL) sync_heights_ = new ::zjchain::pools::protobuf::SyncPoolsMaxHeight;
  return sync_heights_;
}
inline ::zjchain::pools::protobuf::SyncPoolsMaxHeight* Header::release_sync_heights() {
  clear_has_sync_heights();
  ::zjchain::pools::protobuf::SyncPoolsMaxHeight* temp = sync_heights_;
  sync_heights_ = NULL;
  return temp;
}
inline void Header::set_allocated_sync_heights(::zjchain::pools::protobuf::SyncPoolsMaxHeight* sync_heights) {
  delete sync_heights_;
  sync_heights_ = sync_heights;
  if (sync_heights) {
    set_has_sync_heights();
  } else {
    clear_has_sync_heights();
  }
}

// optional .zjchain.block.protobuf.Block block = 27;
inline bool Header::has_block() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Header::set_has_block() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Header::clear_has_block() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Header::clear_block() {
  if (block_ != NULL) block_->::zjchain::block::protobuf::Block::Clear();
  clear_has_block();
}
inline const ::zjchain::block::protobuf::Block& Header::block() const {
  return block_ != NULL ? *block_ : *default_instance_->block_;
}
inline ::zjchain::block::protobuf::Block* Header::mutable_block() {
  set_has_block();
  if (block_ == NULL) block_ = new ::zjchain::block::protobuf::Block;
  return block_;
}
inline ::zjchain::block::protobuf::Block* Header::release_block() {
  clear_has_block();
  ::zjchain::block::protobuf::Block* temp = block_;
  block_ = NULL;
  return temp;
}
inline void Header::set_allocated_block(::zjchain::block::protobuf::Block* block) {
  delete block_;
  block_ = block;
  if (block) {
    set_has_block();
  } else {
    clear_has_block();
  }
}

// repeated .zjchain.pools.protobuf.InvalidBftMessage invalid_bfts = 28;
inline int Header::invalid_bfts_size() const {
  return invalid_bfts_.size();
}
inline void Header::clear_invalid_bfts() {
  invalid_bfts_.Clear();
}
inline const ::zjchain::pools::protobuf::InvalidBftMessage& Header::invalid_bfts(int index) const {
  return invalid_bfts_.Get(index);
}
inline ::zjchain::pools::protobuf::InvalidBftMessage* Header::mutable_invalid_bfts(int index) {
  return invalid_bfts_.Mutable(index);
}
inline ::zjchain::pools::protobuf::InvalidBftMessage* Header::add_invalid_bfts() {
  return invalid_bfts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zjchain::pools::protobuf::InvalidBftMessage >&
Header::invalid_bfts() const {
  return invalid_bfts_;
}
inline ::google::protobuf::RepeatedPtrField< ::zjchain::pools::protobuf::InvalidBftMessage >*
Header::mutable_invalid_bfts() {
  return &invalid_bfts_;
}

// optional uint32 from_public_port = 29;
inline bool Header::has_from_public_port() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Header::set_has_from_public_port() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Header::clear_has_from_public_port() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Header::clear_from_public_port() {
  from_public_port_ = 0u;
  clear_has_from_public_port();
}
inline ::google::protobuf::uint32 Header::from_public_port() const {
  return from_public_port_;
}
inline void Header::set_from_public_port(::google::protobuf::uint32 value) {
  set_has_from_public_port();
  from_public_port_ = value;
}

// optional .zjchain.c2c.protobuf.C2cMessage c2c = 30;
inline bool Header::has_c2c() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Header::set_has_c2c() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Header::clear_has_c2c() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Header::clear_c2c() {
  if (c2c_ != NULL) c2c_->::zjchain::c2c::protobuf::C2cMessage::Clear();
  clear_has_c2c();
}
inline const ::zjchain::c2c::protobuf::C2cMessage& Header::c2c() const {
  return c2c_ != NULL ? *c2c_ : *default_instance_->c2c_;
}
inline ::zjchain::c2c::protobuf::C2cMessage* Header::mutable_c2c() {
  set_has_c2c();
  if (c2c_ == NULL) c2c_ = new ::zjchain::c2c::protobuf::C2cMessage;
  return c2c_;
}
inline ::zjchain::c2c::protobuf::C2cMessage* Header::release_c2c() {
  clear_has_c2c();
  ::zjchain::c2c::protobuf::C2cMessage* temp = c2c_;
  c2c_ = NULL;
  return temp;
}
inline void Header::set_allocated_c2c(::zjchain::c2c::protobuf::C2cMessage* c2c) {
  delete c2c_;
  c2c_ = c2c;
  if (c2c) {
    set_has_c2c();
  } else {
    clear_has_c2c();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace transport
}  // namespace zjchain

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2ftransport_2eproto__INCLUDED
