// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/ws.proto

#ifndef PROTOBUF_INCLUDED_protos_2fws_2eproto
#define PROTOBUF_INCLUDED_protos_2fws_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_protos_2fws_2eproto 

namespace protobuf_protos_2fws_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[18];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_protos_2fws_2eproto
namespace zjchain {
namespace ws {
namespace protobuf {
class Appeal;
class AppealDefaultTypeInternal;
extern AppealDefaultTypeInternal _Appeal_default_instance_;
class BandwidthInfo;
class BandwidthInfoDefaultTypeInternal;
extern BandwidthInfoDefaultTypeInternal _BandwidthInfo_default_instance_;
class BandwidthItem;
class BandwidthItemDefaultTypeInternal;
extern BandwidthItemDefaultTypeInternal _BandwidthItem_default_instance_;
class BuyerReport;
class BuyerReportDefaultTypeInternal;
extern BuyerReportDefaultTypeInternal _BuyerReport_default_instance_;
class C2cMessage;
class C2cMessageDefaultTypeInternal;
extern C2cMessageDefaultTypeInternal _C2cMessage_default_instance_;
class GetSell;
class GetSellDefaultTypeInternal;
extern GetSellDefaultTypeInternal _GetSell_default_instance_;
class InitInfo;
class InitInfoDefaultTypeInternal;
extern InitInfoDefaultTypeInternal _InitInfo_default_instance_;
class NewOrder;
class NewOrderDefaultTypeInternal;
extern NewOrderDefaultTypeInternal _NewOrder_default_instance_;
class NewSell;
class NewSellDefaultTypeInternal;
extern NewSellDefaultTypeInternal _NewSell_default_instance_;
class OrderInfo;
class OrderInfoDefaultTypeInternal;
extern OrderInfoDefaultTypeInternal _OrderInfo_default_instance_;
class ReceivableArray;
class ReceivableArrayDefaultTypeInternal;
extern ReceivableArrayDefaultTypeInternal _ReceivableArray_default_instance_;
class ReceivableInfo;
class ReceivableInfoDefaultTypeInternal;
extern ReceivableInfoDefaultTypeInternal _ReceivableInfo_default_instance_;
class SellInfo;
class SellInfoDefaultTypeInternal;
extern SellInfoDefaultTypeInternal _SellInfo_default_instance_;
class StatusInfo;
class StatusInfoDefaultTypeInternal;
extern StatusInfoDefaultTypeInternal _StatusInfo_default_instance_;
class TxMessage;
class TxMessageDefaultTypeInternal;
extern TxMessageDefaultTypeInternal _TxMessage_default_instance_;
class WsMessage;
class WsMessageDefaultTypeInternal;
extern WsMessageDefaultTypeInternal _WsMessage_default_instance_;
class WsTxItem;
class WsTxItemDefaultTypeInternal;
extern WsTxItemDefaultTypeInternal _WsTxItem_default_instance_;
class WsTxItemResponse;
class WsTxItemResponseDefaultTypeInternal;
extern WsTxItemResponseDefaultTypeInternal _WsTxItemResponse_default_instance_;
}  // namespace protobuf
}  // namespace ws
}  // namespace zjchain
namespace google {
namespace protobuf {
template<> ::zjchain::ws::protobuf::Appeal* Arena::CreateMaybeMessage<::zjchain::ws::protobuf::Appeal>(Arena*);
template<> ::zjchain::ws::protobuf::BandwidthInfo* Arena::CreateMaybeMessage<::zjchain::ws::protobuf::BandwidthInfo>(Arena*);
template<> ::zjchain::ws::protobuf::BandwidthItem* Arena::CreateMaybeMessage<::zjchain::ws::protobuf::BandwidthItem>(Arena*);
template<> ::zjchain::ws::protobuf::BuyerReport* Arena::CreateMaybeMessage<::zjchain::ws::protobuf::BuyerReport>(Arena*);
template<> ::zjchain::ws::protobuf::C2cMessage* Arena::CreateMaybeMessage<::zjchain::ws::protobuf::C2cMessage>(Arena*);
template<> ::zjchain::ws::protobuf::GetSell* Arena::CreateMaybeMessage<::zjchain::ws::protobuf::GetSell>(Arena*);
template<> ::zjchain::ws::protobuf::InitInfo* Arena::CreateMaybeMessage<::zjchain::ws::protobuf::InitInfo>(Arena*);
template<> ::zjchain::ws::protobuf::NewOrder* Arena::CreateMaybeMessage<::zjchain::ws::protobuf::NewOrder>(Arena*);
template<> ::zjchain::ws::protobuf::NewSell* Arena::CreateMaybeMessage<::zjchain::ws::protobuf::NewSell>(Arena*);
template<> ::zjchain::ws::protobuf::OrderInfo* Arena::CreateMaybeMessage<::zjchain::ws::protobuf::OrderInfo>(Arena*);
template<> ::zjchain::ws::protobuf::ReceivableArray* Arena::CreateMaybeMessage<::zjchain::ws::protobuf::ReceivableArray>(Arena*);
template<> ::zjchain::ws::protobuf::ReceivableInfo* Arena::CreateMaybeMessage<::zjchain::ws::protobuf::ReceivableInfo>(Arena*);
template<> ::zjchain::ws::protobuf::SellInfo* Arena::CreateMaybeMessage<::zjchain::ws::protobuf::SellInfo>(Arena*);
template<> ::zjchain::ws::protobuf::StatusInfo* Arena::CreateMaybeMessage<::zjchain::ws::protobuf::StatusInfo>(Arena*);
template<> ::zjchain::ws::protobuf::TxMessage* Arena::CreateMaybeMessage<::zjchain::ws::protobuf::TxMessage>(Arena*);
template<> ::zjchain::ws::protobuf::WsMessage* Arena::CreateMaybeMessage<::zjchain::ws::protobuf::WsMessage>(Arena*);
template<> ::zjchain::ws::protobuf::WsTxItem* Arena::CreateMaybeMessage<::zjchain::ws::protobuf::WsTxItem>(Arena*);
template<> ::zjchain::ws::protobuf::WsTxItemResponse* Arena::CreateMaybeMessage<::zjchain::ws::protobuf::WsTxItemResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace zjchain {
namespace ws {
namespace protobuf {

enum StepType {
  kNormalFrom = 0,
  kNormalTo = 1,
  kConsensusRootElectShard = 2,
  kConsensusRootTimeBlock = 3,
  kConsensusCreateGenesisAcount = 4,
  kConsensusLocalTos = 5,
  kContractCreate = 6,
  kContractGasPrepayment = 7,
  kContractExcute = 8,
  kRootCreateAddress = 9,
  kRootCreateAddressCrossSharding = 11,
  kStatistic = 12,
  kJoinElect = 13,
  kCreateLibrary = 14,
  kCross = 15,
  kRootCross = 16
};
bool StepType_IsValid(int value);
const StepType StepType_MIN = kNormalFrom;
const StepType StepType_MAX = kRootCross;
const int StepType_ARRAYSIZE = StepType_MAX + 1;

const ::google::protobuf::EnumDescriptor* StepType_descriptor();
inline const ::std::string& StepType_Name(StepType value) {
  return ::google::protobuf::internal::NameOfEnum(
    StepType_descriptor(), value);
}
inline bool StepType_Parse(
    const ::std::string& name, StepType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StepType>(
    StepType_descriptor(), name, value);
}
enum InitInfoTagType {
  kNoneResponse = 0,
  kResponseNodes = 1,
  kResponseBalance = 2,
  kResponseTxList = 3,
  kResponseOutOfBindwidth = 4,
  kTransaction = 5,
  kC2cTxList = 6,
  kC2cUserSellInfo = 7,
  kC2cNewSell = 8,
  kC2cNewOrder = 9,
  kC2cConfirm = 10,
  kC2cPrepayment = 11,
  kC2cRefreshLocal = 12,
  kC2cCancelOrder = 13,
  kC2cCancelSell = 14,
  kC2cManagerRecover = 15,
  kC2cManagerCancelSell = 16
};
bool InitInfoTagType_IsValid(int value);
const InitInfoTagType InitInfoTagType_MIN = kNoneResponse;
const InitInfoTagType InitInfoTagType_MAX = kC2cManagerCancelSell;
const int InitInfoTagType_ARRAYSIZE = InitInfoTagType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InitInfoTagType_descriptor();
inline const ::std::string& InitInfoTagType_Name(InitInfoTagType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InitInfoTagType_descriptor(), value);
}
inline bool InitInfoTagType_Parse(
    const ::std::string& name, InitInfoTagType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InitInfoTagType>(
    InitInfoTagType_descriptor(), name, value);
}
enum ReceiveType {
  kAlipay = 0,
  kWeChatPay = 1,
  kPaypal = 2,
  kBandCard = 3,
  kCreditCard = 4,
  kBitcoin = 5,
  kEth = 6,
  kUsdt = 7,
  kUsdc = 8,
  kUnkown = 9
};
bool ReceiveType_IsValid(int value);
const ReceiveType ReceiveType_MIN = kAlipay;
const ReceiveType ReceiveType_MAX = kUnkown;
const int ReceiveType_ARRAYSIZE = ReceiveType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReceiveType_descriptor();
inline const ::std::string& ReceiveType_Name(ReceiveType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReceiveType_descriptor(), value);
}
inline bool ReceiveType_Parse(
    const ::std::string& name, ReceiveType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReceiveType>(
    ReceiveType_descriptor(), name, value);
}
enum Status {
  kDefault = 0,
  kConfirmed = 1,
  kReported = 2,
  kSellWaiting = 3,
  kSellReleased = 4,
  kSellWaitingCreate = 5,
  kSellCreated = 6,
  kSellWaitingConfirm = 7,
  kSellTimeout = 8,
  kOrderCanceled = 9,
  kSellUserWaitingRelease = 10,
  kSellUserReleased = 11,
  kSellManagerWaitingRelease = 12,
  kSellManagerReleased = 13,
  kSellPrepayment = 14,
  kSellWaitingPrepayment = 15,
  kSellWaitingConfirmTx = 16,
  kSellForceReleaseWaitingTx = 17,
  kSellForceReleased = 18,
  kReportedByOrder = 19,
  kSellTxPrepaymentError = 125,
  kSellTxCreateError = 126,
  kSellTxUserReleaseError = 127,
  kSellTxManagerReleaseError = 128,
  kSellWaitingConfirmTxError = 129,
  kSellForceReleaseWaitingTxError = 130
};
bool Status_IsValid(int value);
const Status Status_MIN = kDefault;
const Status Status_MAX = kSellForceReleaseWaitingTxError;
const int Status_ARRAYSIZE = Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_descriptor();
inline const ::std::string& Status_Name(Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_descriptor(), value);
}
inline bool Status_Parse(
    const ::std::string& name, Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
// ===================================================================

class TxMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.ws.protobuf.TxMessage) */ {
 public:
  TxMessage();
  virtual ~TxMessage();

  TxMessage(const TxMessage& from);

  inline TxMessage& operator=(const TxMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxMessage(TxMessage&& from) noexcept
    : TxMessage() {
    *this = ::std::move(from);
  }

  inline TxMessage& operator=(TxMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxMessage* internal_default_instance() {
    return reinterpret_cast<const TxMessage*>(
               &_TxMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(TxMessage* other);
  friend void swap(TxMessage& a, TxMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxMessage* New() const final {
    return CreateMaybeMessage<TxMessage>(NULL);
  }

  TxMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TxMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TxMessage& from);
  void MergeFrom(const TxMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes gid = 2;
  bool has_gid() const;
  void clear_gid();
  static const int kGidFieldNumber = 2;
  const ::std::string& gid() const;
  void set_gid(const ::std::string& value);
  #if LANG_CXX11
  void set_gid(::std::string&& value);
  #endif
  void set_gid(const char* value);
  void set_gid(const void* value, size_t size);
  ::std::string* mutable_gid();
  ::std::string* release_gid();
  void set_allocated_gid(::std::string* gid);

  // optional bytes pubkey = 3;
  bool has_pubkey() const;
  void clear_pubkey();
  static const int kPubkeyFieldNumber = 3;
  const ::std::string& pubkey() const;
  void set_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_pubkey(::std::string&& value);
  #endif
  void set_pubkey(const char* value);
  void set_pubkey(const void* value, size_t size);
  ::std::string* mutable_pubkey();
  ::std::string* release_pubkey();
  void set_allocated_pubkey(::std::string* pubkey);

  // optional bytes key = 6;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 6;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional bytes value = 7;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 7;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional bytes to = 8;
  bool has_to() const;
  void clear_to();
  static const int kToFieldNumber = 8;
  const ::std::string& to() const;
  void set_to(const ::std::string& value);
  #if LANG_CXX11
  void set_to(::std::string&& value);
  #endif
  void set_to(const char* value);
  void set_to(const void* value, size_t size);
  ::std::string* mutable_to();
  ::std::string* release_to();
  void set_allocated_to(::std::string* to);

  // optional bytes contract_code = 12;
  bool has_contract_code() const;
  void clear_contract_code();
  static const int kContractCodeFieldNumber = 12;
  const ::std::string& contract_code() const;
  void set_contract_code(const ::std::string& value);
  #if LANG_CXX11
  void set_contract_code(::std::string&& value);
  #endif
  void set_contract_code(const char* value);
  void set_contract_code(const void* value, size_t size);
  ::std::string* mutable_contract_code();
  ::std::string* release_contract_code();
  void set_allocated_contract_code(::std::string* contract_code);

  // optional bytes contract_input = 13;
  bool has_contract_input() const;
  void clear_contract_input();
  static const int kContractInputFieldNumber = 13;
  const ::std::string& contract_input() const;
  void set_contract_input(const ::std::string& value);
  #if LANG_CXX11
  void set_contract_input(::std::string&& value);
  #endif
  void set_contract_input(const char* value);
  void set_contract_input(const void* value, size_t size);
  ::std::string* mutable_contract_input();
  ::std::string* release_contract_input();
  void set_allocated_contract_input(::std::string* contract_input);

  // optional bytes signr = 14;
  bool has_signr() const;
  void clear_signr();
  static const int kSignrFieldNumber = 14;
  const ::std::string& signr() const;
  void set_signr(const ::std::string& value);
  #if LANG_CXX11
  void set_signr(::std::string&& value);
  #endif
  void set_signr(const char* value);
  void set_signr(const void* value, size_t size);
  ::std::string* mutable_signr();
  ::std::string* release_signr();
  void set_allocated_signr(::std::string* signr);

  // optional bytes signs = 15;
  bool has_signs() const;
  void clear_signs();
  static const int kSignsFieldNumber = 15;
  const ::std::string& signs() const;
  void set_signs(const ::std::string& value);
  #if LANG_CXX11
  void set_signs(::std::string&& value);
  #endif
  void set_signs(const char* value);
  void set_signs(const void* value, size_t size);
  ::std::string* mutable_signs();
  ::std::string* release_signs();
  void set_allocated_signs(::std::string* signs);

  // optional bytes signv = 16;
  bool has_signv() const;
  void clear_signv();
  static const int kSignvFieldNumber = 16;
  const ::std::string& signv() const;
  void set_signv(const ::std::string& value);
  #if LANG_CXX11
  void set_signv(::std::string&& value);
  #endif
  void set_signv(const char* value);
  void set_signv(const void* value, size_t size);
  ::std::string* mutable_signv();
  ::std::string* release_signv();
  void set_allocated_signv(::std::string* signv);

  // optional uint64 gas_limit = 4;
  bool has_gas_limit() const;
  void clear_gas_limit();
  static const int kGasLimitFieldNumber = 4;
  ::google::protobuf::uint64 gas_limit() const;
  void set_gas_limit(::google::protobuf::uint64 value);

  // optional uint64 gas_price = 5;
  bool has_gas_price() const;
  void clear_gas_price();
  static const int kGasPriceFieldNumber = 5;
  ::google::protobuf::uint64 gas_price() const;
  void set_gas_price(::google::protobuf::uint64 value);

  // optional uint32 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // optional .zjchain.ws.protobuf.StepType step = 10 [default = kNormalFrom];
  bool has_step() const;
  void clear_step();
  static const int kStepFieldNumber = 10;
  ::zjchain::ws::protobuf::StepType step() const;
  void set_step(::zjchain::ws::protobuf::StepType value);

  // optional uint64 amount = 9;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 9;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // optional uint64 contract_prepayment = 11;
  bool has_contract_prepayment() const;
  void clear_contract_prepayment();
  static const int kContractPrepaymentFieldNumber = 11;
  ::google::protobuf::uint64 contract_prepayment() const;
  void set_contract_prepayment(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:zjchain.ws.protobuf.TxMessage)
 private:
  void set_has_version();
  void clear_has_version();
  void set_has_gid();
  void clear_has_gid();
  void set_has_pubkey();
  void clear_has_pubkey();
  void set_has_gas_limit();
  void clear_has_gas_limit();
  void set_has_gas_price();
  void clear_has_gas_price();
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();
  void set_has_to();
  void clear_has_to();
  void set_has_amount();
  void clear_has_amount();
  void set_has_step();
  void clear_has_step();
  void set_has_contract_prepayment();
  void clear_has_contract_prepayment();
  void set_has_contract_code();
  void clear_has_contract_code();
  void set_has_contract_input();
  void clear_has_contract_input();
  void set_has_signr();
  void clear_has_signr();
  void set_has_signs();
  void clear_has_signs();
  void set_has_signv();
  void clear_has_signv();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr gid_;
  ::google::protobuf::internal::ArenaStringPtr pubkey_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr to_;
  ::google::protobuf::internal::ArenaStringPtr contract_code_;
  ::google::protobuf::internal::ArenaStringPtr contract_input_;
  ::google::protobuf::internal::ArenaStringPtr signr_;
  ::google::protobuf::internal::ArenaStringPtr signs_;
  ::google::protobuf::internal::ArenaStringPtr signv_;
  ::google::protobuf::uint64 gas_limit_;
  ::google::protobuf::uint64 gas_price_;
  ::google::protobuf::uint32 version_;
  int step_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint64 contract_prepayment_;
  friend struct ::protobuf_protos_2fws_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OrderInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.ws.protobuf.OrderInfo) */ {
 public:
  OrderInfo();
  virtual ~OrderInfo();

  OrderInfo(const OrderInfo& from);

  inline OrderInfo& operator=(const OrderInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OrderInfo(OrderInfo&& from) noexcept
    : OrderInfo() {
    *this = ::std::move(from);
  }

  inline OrderInfo& operator=(OrderInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrderInfo* internal_default_instance() {
    return reinterpret_cast<const OrderInfo*>(
               &_OrderInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(OrderInfo* other);
  friend void swap(OrderInfo& a, OrderInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OrderInfo* New() const final {
    return CreateMaybeMessage<OrderInfo>(NULL);
  }

  OrderInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OrderInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OrderInfo& from);
  void MergeFrom(const OrderInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes buyer = 1;
  bool has_buyer() const;
  void clear_buyer();
  static const int kBuyerFieldNumber = 1;
  const ::std::string& buyer() const;
  void set_buyer(const ::std::string& value);
  #if LANG_CXX11
  void set_buyer(::std::string&& value);
  #endif
  void set_buyer(const char* value);
  void set_buyer(const void* value, size_t size);
  ::std::string* mutable_buyer();
  ::std::string* release_buyer();
  void set_allocated_buyer(::std::string* buyer);

  // optional bytes seller = 4;
  bool has_seller() const;
  void clear_seller();
  static const int kSellerFieldNumber = 4;
  const ::std::string& seller() const;
  void set_seller(const ::std::string& value);
  #if LANG_CXX11
  void set_seller(::std::string&& value);
  #endif
  void set_seller(const char* value);
  void set_seller(const void* value, size_t size);
  ::std::string* mutable_seller();
  ::std::string* release_seller();
  void set_allocated_seller(::std::string* seller);

  // optional uint64 amount = 3;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // optional uint64 create_tm_ms = 5;
  bool has_create_tm_ms() const;
  void clear_create_tm_ms();
  static const int kCreateTmMsFieldNumber = 5;
  ::google::protobuf::uint64 create_tm_ms() const;
  void set_create_tm_ms(::google::protobuf::uint64 value);

  // optional .zjchain.ws.protobuf.Status status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::zjchain::ws::protobuf::Status status() const;
  void set_status(::zjchain::ws::protobuf::Status value);

  // @@protoc_insertion_point(class_scope:zjchain.ws.protobuf.OrderInfo)
 private:
  void set_has_buyer();
  void clear_has_buyer();
  void set_has_status();
  void clear_has_status();
  void set_has_amount();
  void clear_has_amount();
  void set_has_seller();
  void clear_has_seller();
  void set_has_create_tm_ms();
  void clear_has_create_tm_ms();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr buyer_;
  ::google::protobuf::internal::ArenaStringPtr seller_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint64 create_tm_ms_;
  int status_;
  friend struct ::protobuf_protos_2fws_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReceivableInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.ws.protobuf.ReceivableInfo) */ {
 public:
  ReceivableInfo();
  virtual ~ReceivableInfo();

  ReceivableInfo(const ReceivableInfo& from);

  inline ReceivableInfo& operator=(const ReceivableInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReceivableInfo(ReceivableInfo&& from) noexcept
    : ReceivableInfo() {
    *this = ::std::move(from);
  }

  inline ReceivableInfo& operator=(ReceivableInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceivableInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReceivableInfo* internal_default_instance() {
    return reinterpret_cast<const ReceivableInfo*>(
               &_ReceivableInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ReceivableInfo* other);
  friend void swap(ReceivableInfo& a, ReceivableInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReceivableInfo* New() const final {
    return CreateMaybeMessage<ReceivableInfo>(NULL);
  }

  ReceivableInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReceivableInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReceivableInfo& from);
  void MergeFrom(const ReceivableInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceivableInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bytes id = 3;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 3;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional bytes user_name = 4;
  bool has_user_name() const;
  void clear_user_name();
  static const int kUserNameFieldNumber = 4;
  const ::std::string& user_name() const;
  void set_user_name(const ::std::string& value);
  #if LANG_CXX11
  void set_user_name(::std::string&& value);
  #endif
  void set_user_name(const char* value);
  void set_user_name(const void* value, size_t size);
  ::std::string* mutable_user_name();
  ::std::string* release_user_name();
  void set_allocated_user_name(::std::string* user_name);

  // optional bytes other = 5;
  bool has_other() const;
  void clear_other();
  static const int kOtherFieldNumber = 5;
  const ::std::string& other() const;
  void set_other(const ::std::string& value);
  #if LANG_CXX11
  void set_other(::std::string&& value);
  #endif
  void set_other(const char* value);
  void set_other(const void* value, size_t size);
  ::std::string* mutable_other();
  ::std::string* release_other();
  void set_allocated_other(::std::string* other);

  // optional bytes qrcode = 6;
  bool has_qrcode() const;
  void clear_qrcode();
  static const int kQrcodeFieldNumber = 6;
  const ::std::string& qrcode() const;
  void set_qrcode(const ::std::string& value);
  #if LANG_CXX11
  void set_qrcode(::std::string&& value);
  #endif
  void set_qrcode(const char* value);
  void set_qrcode(const void* value, size_t size);
  ::std::string* mutable_qrcode();
  ::std::string* release_qrcode();
  void set_allocated_qrcode(::std::string* qrcode);

  // optional .zjchain.ws.protobuf.ReceiveType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::zjchain::ws::protobuf::ReceiveType type() const;
  void set_type(::zjchain::ws::protobuf::ReceiveType value);

  // @@protoc_insertion_point(class_scope:zjchain.ws.protobuf.ReceivableInfo)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_name();
  void clear_has_name();
  void set_has_id();
  void clear_has_id();
  void set_has_user_name();
  void clear_has_user_name();
  void set_has_other();
  void clear_has_other();
  void set_has_qrcode();
  void clear_has_qrcode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr user_name_;
  ::google::protobuf::internal::ArenaStringPtr other_;
  ::google::protobuf::internal::ArenaStringPtr qrcode_;
  int type_;
  friend struct ::protobuf_protos_2fws_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReceivableArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.ws.protobuf.ReceivableArray) */ {
 public:
  ReceivableArray();
  virtual ~ReceivableArray();

  ReceivableArray(const ReceivableArray& from);

  inline ReceivableArray& operator=(const ReceivableArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReceivableArray(ReceivableArray&& from) noexcept
    : ReceivableArray() {
    *this = ::std::move(from);
  }

  inline ReceivableArray& operator=(ReceivableArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceivableArray& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReceivableArray* internal_default_instance() {
    return reinterpret_cast<const ReceivableArray*>(
               &_ReceivableArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ReceivableArray* other);
  friend void swap(ReceivableArray& a, ReceivableArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReceivableArray* New() const final {
    return CreateMaybeMessage<ReceivableArray>(NULL);
  }

  ReceivableArray* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReceivableArray>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReceivableArray& from);
  void MergeFrom(const ReceivableArray& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceivableArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zjchain.ws.protobuf.ReceivableInfo receivable = 1;
  int receivable_size() const;
  void clear_receivable();
  static const int kReceivableFieldNumber = 1;
  ::zjchain::ws::protobuf::ReceivableInfo* mutable_receivable(int index);
  ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::ReceivableInfo >*
      mutable_receivable();
  const ::zjchain::ws::protobuf::ReceivableInfo& receivable(int index) const;
  ::zjchain::ws::protobuf::ReceivableInfo* add_receivable();
  const ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::ReceivableInfo >&
      receivable() const;

  // @@protoc_insertion_point(class_scope:zjchain.ws.protobuf.ReceivableArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::ReceivableInfo > receivable_;
  friend struct ::protobuf_protos_2fws_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SellInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.ws.protobuf.SellInfo) */ {
 public:
  SellInfo();
  virtual ~SellInfo();

  SellInfo(const SellInfo& from);

  inline SellInfo& operator=(const SellInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SellInfo(SellInfo&& from) noexcept
    : SellInfo() {
    *this = ::std::move(from);
  }

  inline SellInfo& operator=(SellInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SellInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SellInfo* internal_default_instance() {
    return reinterpret_cast<const SellInfo*>(
               &_SellInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SellInfo* other);
  friend void swap(SellInfo& a, SellInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SellInfo* New() const final {
    return CreateMaybeMessage<SellInfo>(NULL);
  }

  SellInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SellInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SellInfo& from);
  void MergeFrom(const SellInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SellInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes seller = 1;
  bool has_seller() const;
  void clear_seller();
  static const int kSellerFieldNumber = 1;
  const ::std::string& seller() const;
  void set_seller(const ::std::string& value);
  #if LANG_CXX11
  void set_seller(::std::string&& value);
  #endif
  void set_seller(const char* value);
  void set_seller(const void* value, size_t size);
  ::std::string* mutable_seller();
  ::std::string* release_seller();
  void set_allocated_seller(::std::string* seller);

  // optional bytes buyer = 2;
  bool has_buyer() const;
  void clear_buyer();
  static const int kBuyerFieldNumber = 2;
  const ::std::string& buyer() const;
  void set_buyer(const ::std::string& value);
  #if LANG_CXX11
  void set_buyer(::std::string&& value);
  #endif
  void set_buyer(const char* value);
  void set_buyer(const void* value, size_t size);
  ::std::string* mutable_buyer();
  ::std::string* release_buyer();
  void set_allocated_buyer(::std::string* buyer);

  // optional bytes contract = 3;
  bool has_contract() const;
  void clear_contract();
  static const int kContractFieldNumber = 3;
  const ::std::string& contract() const;
  void set_contract(const ::std::string& value);
  #if LANG_CXX11
  void set_contract(::std::string&& value);
  #endif
  void set_contract(const char* value);
  void set_contract(const void* value, size_t size);
  ::std::string* mutable_contract();
  ::std::string* release_contract();
  void set_allocated_contract(::std::string* contract);

  // optional bytes username = 14;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 14;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const void* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional .zjchain.ws.protobuf.ReceivableArray receivable = 5;
  bool has_receivable() const;
  void clear_receivable();
  static const int kReceivableFieldNumber = 5;
  private:
  const ::zjchain::ws::protobuf::ReceivableArray& _internal_receivable() const;
  public:
  const ::zjchain::ws::protobuf::ReceivableArray& receivable() const;
  ::zjchain::ws::protobuf::ReceivableArray* release_receivable();
  ::zjchain::ws::protobuf::ReceivableArray* mutable_receivable();
  void set_allocated_receivable(::zjchain::ws::protobuf::ReceivableArray* receivable);

  // optional .zjchain.ws.protobuf.Appeal appeal = 22;
  bool has_appeal() const;
  void clear_appeal();
  static const int kAppealFieldNumber = 22;
  private:
  const ::zjchain::ws::protobuf::Appeal& _internal_appeal() const;
  public:
  const ::zjchain::ws::protobuf::Appeal& appeal() const;
  ::zjchain::ws::protobuf::Appeal* release_appeal();
  ::zjchain::ws::protobuf::Appeal* mutable_appeal();
  void set_allocated_appeal(::zjchain::ws::protobuf::Appeal* appeal);

  // optional .zjchain.ws.protobuf.Appeal peer_appeal = 24;
  bool has_peer_appeal() const;
  void clear_peer_appeal();
  static const int kPeerAppealFieldNumber = 24;
  private:
  const ::zjchain::ws::protobuf::Appeal& _internal_peer_appeal() const;
  public:
  const ::zjchain::ws::protobuf::Appeal& peer_appeal() const;
  ::zjchain::ws::protobuf::Appeal* release_peer_appeal();
  ::zjchain::ws::protobuf::Appeal* mutable_peer_appeal();
  void set_allocated_peer_appeal(::zjchain::ws::protobuf::Appeal* peer_appeal);

  // optional uint64 amount = 4;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 4;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // optional uint64 all = 6;
  bool has_all() const;
  void clear_all();
  static const int kAllFieldNumber = 6;
  ::google::protobuf::uint64 all() const;
  void set_all(::google::protobuf::uint64 value);

  // optional uint64 price = 7;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 7;
  ::google::protobuf::uint64 price() const;
  void set_price(::google::protobuf::uint64 value);

  // optional uint32 mchecked = 8;
  bool has_mchecked() const;
  void clear_mchecked();
  static const int kMcheckedFieldNumber = 8;
  ::google::protobuf::uint32 mchecked() const;
  void set_mchecked(::google::protobuf::uint32 value);

  // optional uint32 schecked = 9;
  bool has_schecked() const;
  void clear_schecked();
  static const int kScheckedFieldNumber = 9;
  ::google::protobuf::uint32 schecked() const;
  void set_schecked(::google::protobuf::uint32 value);

  // optional uint64 orderId = 11;
  bool has_orderid() const;
  void clear_orderid();
  static const int kOrderIdFieldNumber = 11;
  ::google::protobuf::uint64 orderid() const;
  void set_orderid(::google::protobuf::uint64 value);

  // optional uint64 height = 12;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 12;
  ::google::protobuf::uint64 height() const;
  void set_height(::google::protobuf::uint64 value);

  // optional uint32 reported = 10;
  bool has_reported() const;
  void clear_reported();
  static const int kReportedFieldNumber = 10;
  ::google::protobuf::uint32 reported() const;
  void set_reported(::google::protobuf::uint32 value);

  // optional int32 status = 15;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 15;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // optional uint64 timestamp = 13;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 13;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // optional uint64 purchase_amount = 16;
  bool has_purchase_amount() const;
  void clear_purchase_amount();
  static const int kPurchaseAmountFieldNumber = 16;
  ::google::protobuf::uint64 purchase_amount() const;
  void set_purchase_amount(::google::protobuf::uint64 value);

  // optional uint64 create_timestamp = 17;
  bool has_create_timestamp() const;
  void clear_create_timestamp();
  static const int kCreateTimestampFieldNumber = 17;
  ::google::protobuf::uint64 create_timestamp() const;
  void set_create_timestamp(::google::protobuf::uint64 value);

  // optional uint64 min_amount = 18;
  bool has_min_amount() const;
  void clear_min_amount();
  static const int kMinAmountFieldNumber = 18;
  ::google::protobuf::uint64 min_amount() const;
  void set_min_amount(::google::protobuf::uint64 value);

  // optional uint64 max_amount = 19;
  bool has_max_amount() const;
  void clear_max_amount();
  static const int kMaxAmountFieldNumber = 19;
  ::google::protobuf::uint64 max_amount() const;
  void set_max_amount(::google::protobuf::uint64 value);

  // optional uint64 now = 20;
  bool has_now() const;
  void clear_now();
  static const int kNowFieldNumber = 20;
  ::google::protobuf::uint64 now() const;
  void set_now(::google::protobuf::uint64 value);

  // optional bool is_order = 21;
  bool has_is_order() const;
  void clear_is_order();
  static const int kIsOrderFieldNumber = 21;
  bool is_order() const;
  void set_is_order(bool value);

  // optional int32 credit = 23;
  bool has_credit() const;
  void clear_credit();
  static const int kCreditFieldNumber = 23;
  ::google::protobuf::int32 credit() const;
  void set_credit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zjchain.ws.protobuf.SellInfo)
 private:
  void set_has_seller();
  void clear_has_seller();
  void set_has_buyer();
  void clear_has_buyer();
  void set_has_contract();
  void clear_has_contract();
  void set_has_amount();
  void clear_has_amount();
  void set_has_receivable();
  void clear_has_receivable();
  void set_has_all();
  void clear_has_all();
  void set_has_price();
  void clear_has_price();
  void set_has_mchecked();
  void clear_has_mchecked();
  void set_has_schecked();
  void clear_has_schecked();
  void set_has_reported();
  void clear_has_reported();
  void set_has_orderid();
  void clear_has_orderid();
  void set_has_height();
  void clear_has_height();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_username();
  void clear_has_username();
  void set_has_status();
  void clear_has_status();
  void set_has_purchase_amount();
  void clear_has_purchase_amount();
  void set_has_create_timestamp();
  void clear_has_create_timestamp();
  void set_has_min_amount();
  void clear_has_min_amount();
  void set_has_max_amount();
  void clear_has_max_amount();
  void set_has_now();
  void clear_has_now();
  void set_has_is_order();
  void clear_has_is_order();
  void set_has_appeal();
  void clear_has_appeal();
  void set_has_credit();
  void clear_has_credit();
  void set_has_peer_appeal();
  void clear_has_peer_appeal();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr seller_;
  ::google::protobuf::internal::ArenaStringPtr buyer_;
  ::google::protobuf::internal::ArenaStringPtr contract_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::zjchain::ws::protobuf::ReceivableArray* receivable_;
  ::zjchain::ws::protobuf::Appeal* appeal_;
  ::zjchain::ws::protobuf::Appeal* peer_appeal_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint64 all_;
  ::google::protobuf::uint64 price_;
  ::google::protobuf::uint32 mchecked_;
  ::google::protobuf::uint32 schecked_;
  ::google::protobuf::uint64 orderid_;
  ::google::protobuf::uint64 height_;
  ::google::protobuf::uint32 reported_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint64 purchase_amount_;
  ::google::protobuf::uint64 create_timestamp_;
  ::google::protobuf::uint64 min_amount_;
  ::google::protobuf::uint64 max_amount_;
  ::google::protobuf::uint64 now_;
  bool is_order_;
  ::google::protobuf::int32 credit_;
  friend struct ::protobuf_protos_2fws_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewOrder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.ws.protobuf.NewOrder) */ {
 public:
  NewOrder();
  virtual ~NewOrder();

  NewOrder(const NewOrder& from);

  inline NewOrder& operator=(const NewOrder& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewOrder(NewOrder&& from) noexcept
    : NewOrder() {
    *this = ::std::move(from);
  }

  inline NewOrder& operator=(NewOrder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewOrder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewOrder* internal_default_instance() {
    return reinterpret_cast<const NewOrder*>(
               &_NewOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(NewOrder* other);
  friend void swap(NewOrder& a, NewOrder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewOrder* New() const final {
    return CreateMaybeMessage<NewOrder>(NULL);
  }

  NewOrder* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NewOrder>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NewOrder& from);
  void MergeFrom(const NewOrder& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewOrder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes seller = 1;
  bool has_seller() const;
  void clear_seller();
  static const int kSellerFieldNumber = 1;
  const ::std::string& seller() const;
  void set_seller(const ::std::string& value);
  #if LANG_CXX11
  void set_seller(::std::string&& value);
  #endif
  void set_seller(const char* value);
  void set_seller(const void* value, size_t size);
  ::std::string* mutable_seller();
  ::std::string* release_seller();
  void set_allocated_seller(::std::string* seller);

  // optional bytes buyer = 3;
  bool has_buyer() const;
  void clear_buyer();
  static const int kBuyerFieldNumber = 3;
  const ::std::string& buyer() const;
  void set_buyer(const ::std::string& value);
  #if LANG_CXX11
  void set_buyer(::std::string&& value);
  #endif
  void set_buyer(const char* value);
  void set_buyer(const void* value, size_t size);
  ::std::string* mutable_buyer();
  ::std::string* release_buyer();
  void set_allocated_buyer(::std::string* buyer);

  // optional uint64 amount = 2;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:zjchain.ws.protobuf.NewOrder)
 private:
  void set_has_seller();
  void clear_has_seller();
  void set_has_amount();
  void clear_has_amount();
  void set_has_buyer();
  void clear_has_buyer();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr seller_;
  ::google::protobuf::internal::ArenaStringPtr buyer_;
  ::google::protobuf::uint64 amount_;
  friend struct ::protobuf_protos_2fws_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Appeal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.ws.protobuf.Appeal) */ {
 public:
  Appeal();
  virtual ~Appeal();

  Appeal(const Appeal& from);

  inline Appeal& operator=(const Appeal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Appeal(Appeal&& from) noexcept
    : Appeal() {
    *this = ::std::move(from);
  }

  inline Appeal& operator=(Appeal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Appeal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Appeal* internal_default_instance() {
    return reinterpret_cast<const Appeal*>(
               &_Appeal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Appeal* other);
  friend void swap(Appeal& a, Appeal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Appeal* New() const final {
    return CreateMaybeMessage<Appeal>(NULL);
  }

  Appeal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Appeal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Appeal& from);
  void MergeFrom(const Appeal& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Appeal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes seller = 1;
  bool has_seller() const;
  void clear_seller();
  static const int kSellerFieldNumber = 1;
  const ::std::string& seller() const;
  void set_seller(const ::std::string& value);
  #if LANG_CXX11
  void set_seller(::std::string&& value);
  #endif
  void set_seller(const char* value);
  void set_seller(const void* value, size_t size);
  ::std::string* mutable_seller();
  ::std::string* release_seller();
  void set_allocated_seller(::std::string* seller);

  // optional bytes buyer = 2;
  bool has_buyer() const;
  void clear_buyer();
  static const int kBuyerFieldNumber = 2;
  const ::std::string& buyer() const;
  void set_buyer(const ::std::string& value);
  #if LANG_CXX11
  void set_buyer(::std::string&& value);
  #endif
  void set_buyer(const char* value);
  void set_buyer(const void* value, size_t size);
  ::std::string* mutable_buyer();
  ::std::string* release_buyer();
  void set_allocated_buyer(::std::string* buyer);

  // optional bytes content = 4;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 4;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // optional bytes pic = 5;
  bool has_pic() const;
  void clear_pic();
  static const int kPicFieldNumber = 5;
  const ::std::string& pic() const;
  void set_pic(const ::std::string& value);
  #if LANG_CXX11
  void set_pic(::std::string&& value);
  #endif
  void set_pic(const char* value);
  void set_pic(const void* value, size_t size);
  ::std::string* mutable_pic();
  ::std::string* release_pic();
  void set_allocated_pic(::std::string* pic);

  // optional int32 type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zjchain.ws.protobuf.Appeal)
 private:
  void set_has_seller();
  void clear_has_seller();
  void set_has_buyer();
  void clear_has_buyer();
  void set_has_type();
  void clear_has_type();
  void set_has_content();
  void clear_has_content();
  void set_has_pic();
  void clear_has_pic();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr seller_;
  ::google::protobuf::internal::ArenaStringPtr buyer_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::google::protobuf::internal::ArenaStringPtr pic_;
  ::google::protobuf::int32 type_;
  friend struct ::protobuf_protos_2fws_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewSell : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.ws.protobuf.NewSell) */ {
 public:
  NewSell();
  virtual ~NewSell();

  NewSell(const NewSell& from);

  inline NewSell& operator=(const NewSell& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewSell(NewSell&& from) noexcept
    : NewSell() {
    *this = ::std::move(from);
  }

  inline NewSell& operator=(NewSell&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewSell& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewSell* internal_default_instance() {
    return reinterpret_cast<const NewSell*>(
               &_NewSell_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(NewSell* other);
  friend void swap(NewSell& a, NewSell& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewSell* New() const final {
    return CreateMaybeMessage<NewSell>(NULL);
  }

  NewSell* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NewSell>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NewSell& from);
  void MergeFrom(const NewSell& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewSell* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zjchain.ws.protobuf.ReceivableInfo receivable = 5;
  int receivable_size() const;
  void clear_receivable();
  static const int kReceivableFieldNumber = 5;
  ::zjchain::ws::protobuf::ReceivableInfo* mutable_receivable(int index);
  ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::ReceivableInfo >*
      mutable_receivable();
  const ::zjchain::ws::protobuf::ReceivableInfo& receivable(int index) const;
  ::zjchain::ws::protobuf::ReceivableInfo* add_receivable();
  const ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::ReceivableInfo >&
      receivable() const;

  // optional bytes protocol_addr = 1;
  bool has_protocol_addr() const;
  void clear_protocol_addr();
  static const int kProtocolAddrFieldNumber = 1;
  const ::std::string& protocol_addr() const;
  void set_protocol_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_protocol_addr(::std::string&& value);
  #endif
  void set_protocol_addr(const char* value);
  void set_protocol_addr(const void* value, size_t size);
  ::std::string* mutable_protocol_addr();
  ::std::string* release_protocol_addr();
  void set_allocated_protocol_addr(::std::string* protocol_addr);

  // optional bytes seller = 2;
  bool has_seller() const;
  void clear_seller();
  static const int kSellerFieldNumber = 2;
  const ::std::string& seller() const;
  void set_seller(const ::std::string& value);
  #if LANG_CXX11
  void set_seller(::std::string&& value);
  #endif
  void set_seller(const char* value);
  void set_seller(const void* value, size_t size);
  ::std::string* mutable_seller();
  ::std::string* release_seller();
  void set_allocated_seller(::std::string* seller);

  // optional uint64 amount = 3;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // optional uint64 price = 4;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 4;
  ::google::protobuf::uint64 price() const;
  void set_price(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:zjchain.ws.protobuf.NewSell)
 private:
  void set_has_protocol_addr();
  void clear_has_protocol_addr();
  void set_has_seller();
  void clear_has_seller();
  void set_has_amount();
  void clear_has_amount();
  void set_has_price();
  void clear_has_price();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::ReceivableInfo > receivable_;
  ::google::protobuf::internal::ArenaStringPtr protocol_addr_;
  ::google::protobuf::internal::ArenaStringPtr seller_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint64 price_;
  friend struct ::protobuf_protos_2fws_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BuyerReport : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.ws.protobuf.BuyerReport) */ {
 public:
  BuyerReport();
  virtual ~BuyerReport();

  BuyerReport(const BuyerReport& from);

  inline BuyerReport& operator=(const BuyerReport& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BuyerReport(BuyerReport&& from) noexcept
    : BuyerReport() {
    *this = ::std::move(from);
  }

  inline BuyerReport& operator=(BuyerReport&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuyerReport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuyerReport* internal_default_instance() {
    return reinterpret_cast<const BuyerReport*>(
               &_BuyerReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(BuyerReport* other);
  friend void swap(BuyerReport& a, BuyerReport& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BuyerReport* New() const final {
    return CreateMaybeMessage<BuyerReport>(NULL);
  }

  BuyerReport* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BuyerReport>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BuyerReport& from);
  void MergeFrom(const BuyerReport& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuyerReport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes seller = 1;
  bool has_seller() const;
  void clear_seller();
  static const int kSellerFieldNumber = 1;
  const ::std::string& seller() const;
  void set_seller(const ::std::string& value);
  #if LANG_CXX11
  void set_seller(::std::string&& value);
  #endif
  void set_seller(const char* value);
  void set_seller(const void* value, size_t size);
  ::std::string* mutable_seller();
  ::std::string* release_seller();
  void set_allocated_seller(::std::string* seller);

  // optional bytes reports_info = 2;
  bool has_reports_info() const;
  void clear_reports_info();
  static const int kReportsInfoFieldNumber = 2;
  const ::std::string& reports_info() const;
  void set_reports_info(const ::std::string& value);
  #if LANG_CXX11
  void set_reports_info(::std::string&& value);
  #endif
  void set_reports_info(const char* value);
  void set_reports_info(const void* value, size_t size);
  ::std::string* mutable_reports_info();
  ::std::string* release_reports_info();
  void set_allocated_reports_info(::std::string* reports_info);

  // @@protoc_insertion_point(class_scope:zjchain.ws.protobuf.BuyerReport)
 private:
  void set_has_seller();
  void clear_has_seller();
  void set_has_reports_info();
  void clear_has_reports_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr seller_;
  ::google::protobuf::internal::ArenaStringPtr reports_info_;
  friend struct ::protobuf_protos_2fws_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetSell : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.ws.protobuf.GetSell) */ {
 public:
  GetSell();
  virtual ~GetSell();

  GetSell(const GetSell& from);

  inline GetSell& operator=(const GetSell& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetSell(GetSell&& from) noexcept
    : GetSell() {
    *this = ::std::move(from);
  }

  inline GetSell& operator=(GetSell&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSell& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetSell* internal_default_instance() {
    return reinterpret_cast<const GetSell*>(
               &_GetSell_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GetSell* other);
  friend void swap(GetSell& a, GetSell& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetSell* New() const final {
    return CreateMaybeMessage<GetSell>(NULL);
  }

  GetSell* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetSell>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetSell& from);
  void MergeFrom(const GetSell& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSell* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes seller = 1;
  bool has_seller() const;
  void clear_seller();
  static const int kSellerFieldNumber = 1;
  const ::std::string& seller() const;
  void set_seller(const ::std::string& value);
  #if LANG_CXX11
  void set_seller(::std::string&& value);
  #endif
  void set_seller(const char* value);
  void set_seller(const void* value, size_t size);
  ::std::string* mutable_seller();
  ::std::string* release_seller();
  void set_allocated_seller(::std::string* seller);

  // @@protoc_insertion_point(class_scope:zjchain.ws.protobuf.GetSell)
 private:
  void set_has_seller();
  void clear_has_seller();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr seller_;
  friend struct ::protobuf_protos_2fws_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class C2cMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.ws.protobuf.C2cMessage) */ {
 public:
  C2cMessage();
  virtual ~C2cMessage();

  C2cMessage(const C2cMessage& from);

  inline C2cMessage& operator=(const C2cMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  C2cMessage(C2cMessage&& from) noexcept
    : C2cMessage() {
    *this = ::std::move(from);
  }

  inline C2cMessage& operator=(C2cMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const C2cMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const C2cMessage* internal_default_instance() {
    return reinterpret_cast<const C2cMessage*>(
               &_C2cMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(C2cMessage* other);
  friend void swap(C2cMessage& a, C2cMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline C2cMessage* New() const final {
    return CreateMaybeMessage<C2cMessage>(NULL);
  }

  C2cMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<C2cMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const C2cMessage& from);
  void MergeFrom(const C2cMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C2cMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zjchain.ws.protobuf.SellInfo sells = 4;
  int sells_size() const;
  void clear_sells();
  static const int kSellsFieldNumber = 4;
  ::zjchain::ws::protobuf::SellInfo* mutable_sells(int index);
  ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::SellInfo >*
      mutable_sells();
  const ::zjchain::ws::protobuf::SellInfo& sells(int index) const;
  ::zjchain::ws::protobuf::SellInfo* add_sells();
  const ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::SellInfo >&
      sells() const;

  // optional bytes c2c_addr = 7;
  bool has_c2c_addr() const;
  void clear_c2c_addr();
  static const int kC2CAddrFieldNumber = 7;
  const ::std::string& c2c_addr() const;
  void set_c2c_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_c2c_addr(::std::string&& value);
  #endif
  void set_c2c_addr(const char* value);
  void set_c2c_addr(const void* value, size_t size);
  ::std::string* mutable_c2c_addr();
  ::std::string* release_c2c_addr();
  void set_allocated_c2c_addr(::std::string* c2c_addr);

  // optional .zjchain.ws.protobuf.NewSell sell = 1;
  bool has_sell() const;
  void clear_sell();
  static const int kSellFieldNumber = 1;
  private:
  const ::zjchain::ws::protobuf::NewSell& _internal_sell() const;
  public:
  const ::zjchain::ws::protobuf::NewSell& sell() const;
  ::zjchain::ws::protobuf::NewSell* release_sell();
  ::zjchain::ws::protobuf::NewSell* mutable_sell();
  void set_allocated_sell(::zjchain::ws::protobuf::NewSell* sell);

  // optional .zjchain.ws.protobuf.NewOrder order = 2;
  bool has_order() const;
  void clear_order();
  static const int kOrderFieldNumber = 2;
  private:
  const ::zjchain::ws::protobuf::NewOrder& _internal_order() const;
  public:
  const ::zjchain::ws::protobuf::NewOrder& order() const;
  ::zjchain::ws::protobuf::NewOrder* release_order();
  ::zjchain::ws::protobuf::NewOrder* mutable_order();
  void set_allocated_order(::zjchain::ws::protobuf::NewOrder* order);

  // optional .zjchain.ws.protobuf.BuyerReport report = 3;
  bool has_report() const;
  void clear_report();
  static const int kReportFieldNumber = 3;
  private:
  const ::zjchain::ws::protobuf::BuyerReport& _internal_report() const;
  public:
  const ::zjchain::ws::protobuf::BuyerReport& report() const;
  ::zjchain::ws::protobuf::BuyerReport* release_report();
  ::zjchain::ws::protobuf::BuyerReport* mutable_report();
  void set_allocated_report(::zjchain::ws::protobuf::BuyerReport* report);

  // optional .zjchain.ws.protobuf.GetSell get_sell = 5;
  bool has_get_sell() const;
  void clear_get_sell();
  static const int kGetSellFieldNumber = 5;
  private:
  const ::zjchain::ws::protobuf::GetSell& _internal_get_sell() const;
  public:
  const ::zjchain::ws::protobuf::GetSell& get_sell() const;
  ::zjchain::ws::protobuf::GetSell* release_get_sell();
  ::zjchain::ws::protobuf::GetSell* mutable_get_sell();
  void set_allocated_get_sell(::zjchain::ws::protobuf::GetSell* get_sell);

  // optional .zjchain.ws.protobuf.SellInfo user_order_info = 8;
  bool has_user_order_info() const;
  void clear_user_order_info();
  static const int kUserOrderInfoFieldNumber = 8;
  private:
  const ::zjchain::ws::protobuf::SellInfo& _internal_user_order_info() const;
  public:
  const ::zjchain::ws::protobuf::SellInfo& user_order_info() const;
  ::zjchain::ws::protobuf::SellInfo* release_user_order_info();
  ::zjchain::ws::protobuf::SellInfo* mutable_user_order_info();
  void set_allocated_user_order_info(::zjchain::ws::protobuf::SellInfo* user_order_info);

  // optional .zjchain.ws.protobuf.Appeal appeal = 9;
  bool has_appeal() const;
  void clear_appeal();
  static const int kAppealFieldNumber = 9;
  private:
  const ::zjchain::ws::protobuf::Appeal& _internal_appeal() const;
  public:
  const ::zjchain::ws::protobuf::Appeal& appeal() const;
  ::zjchain::ws::protobuf::Appeal* release_appeal();
  ::zjchain::ws::protobuf::Appeal* mutable_appeal();
  void set_allocated_appeal(::zjchain::ws::protobuf::Appeal* appeal);

  // optional uint64 prepayment = 6;
  bool has_prepayment() const;
  void clear_prepayment();
  static const int kPrepaymentFieldNumber = 6;
  ::google::protobuf::uint64 prepayment() const;
  void set_prepayment(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:zjchain.ws.protobuf.C2cMessage)
 private:
  void set_has_sell();
  void clear_has_sell();
  void set_has_order();
  void clear_has_order();
  void set_has_report();
  void clear_has_report();
  void set_has_get_sell();
  void clear_has_get_sell();
  void set_has_prepayment();
  void clear_has_prepayment();
  void set_has_c2c_addr();
  void clear_has_c2c_addr();
  void set_has_user_order_info();
  void clear_has_user_order_info();
  void set_has_appeal();
  void clear_has_appeal();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::SellInfo > sells_;
  ::google::protobuf::internal::ArenaStringPtr c2c_addr_;
  ::zjchain::ws::protobuf::NewSell* sell_;
  ::zjchain::ws::protobuf::NewOrder* order_;
  ::zjchain::ws::protobuf::BuyerReport* report_;
  ::zjchain::ws::protobuf::GetSell* get_sell_;
  ::zjchain::ws::protobuf::SellInfo* user_order_info_;
  ::zjchain::ws::protobuf::Appeal* appeal_;
  ::google::protobuf::uint64 prepayment_;
  friend struct ::protobuf_protos_2fws_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StatusInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.ws.protobuf.StatusInfo) */ {
 public:
  StatusInfo();
  virtual ~StatusInfo();

  StatusInfo(const StatusInfo& from);

  inline StatusInfo& operator=(const StatusInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusInfo(StatusInfo&& from) noexcept
    : StatusInfo() {
    *this = ::std::move(from);
  }

  inline StatusInfo& operator=(StatusInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusInfo* internal_default_instance() {
    return reinterpret_cast<const StatusInfo*>(
               &_StatusInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(StatusInfo* other);
  friend void swap(StatusInfo& a, StatusInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusInfo* New() const final {
    return CreateMaybeMessage<StatusInfo>(NULL);
  }

  StatusInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatusInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatusInfo& from);
  void MergeFrom(const StatusInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const void* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional uint64 msg_id = 3;
  bool has_msg_id() const;
  void clear_msg_id();
  static const int kMsgIdFieldNumber = 3;
  ::google::protobuf::uint64 msg_id() const;
  void set_msg_id(::google::protobuf::uint64 value);

  // optional int32 status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zjchain.ws.protobuf.StatusInfo)
 private:
  void set_has_status();
  void clear_has_status();
  void set_has_message();
  void clear_has_message();
  void set_has_msg_id();
  void clear_has_msg_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::uint64 msg_id_;
  ::google::protobuf::int32 status_;
  friend struct ::protobuf_protos_2fws_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InitInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.ws.protobuf.InitInfo) */ {
 public:
  InitInfo();
  virtual ~InitInfo();

  InitInfo(const InitInfo& from);

  inline InitInfo& operator=(const InitInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InitInfo(InitInfo&& from) noexcept
    : InitInfo() {
    *this = ::std::move(from);
  }

  inline InitInfo& operator=(InitInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitInfo* internal_default_instance() {
    return reinterpret_cast<const InitInfo*>(
               &_InitInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(InitInfo* other);
  friend void swap(InitInfo& a, InitInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InitInfo* New() const final {
    return CreateMaybeMessage<InitInfo>(NULL);
  }

  InitInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InitInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InitInfo& from);
  void MergeFrom(const InitInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes pubkey = 1;
  bool has_pubkey() const;
  void clear_pubkey();
  static const int kPubkeyFieldNumber = 1;
  const ::std::string& pubkey() const;
  void set_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_pubkey(::std::string&& value);
  #endif
  void set_pubkey(const char* value);
  void set_pubkey(const void* value, size_t size);
  ::std::string* mutable_pubkey();
  ::std::string* release_pubkey();
  void set_allocated_pubkey(::std::string* pubkey);

  // optional bytes platform = 2;
  bool has_platform() const;
  void clear_platform();
  static const int kPlatformFieldNumber = 2;
  const ::std::string& platform() const;
  void set_platform(const ::std::string& value);
  #if LANG_CXX11
  void set_platform(::std::string&& value);
  #endif
  void set_platform(const char* value);
  void set_platform(const void* value, size_t size);
  ::std::string* mutable_platform();
  ::std::string* release_platform();
  void set_allocated_platform(::std::string* platform);

  // optional bytes version = 3;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const void* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional bytes pk_hash = 4;
  bool has_pk_hash() const;
  void clear_pk_hash();
  static const int kPkHashFieldNumber = 4;
  const ::std::string& pk_hash() const;
  void set_pk_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_pk_hash(::std::string&& value);
  #endif
  void set_pk_hash(const char* value);
  void set_pk_hash(const void* value, size_t size);
  ::std::string* mutable_pk_hash();
  ::std::string* release_pk_hash();
  void set_allocated_pk_hash(::std::string* pk_hash);

  // optional .zjchain.ws.protobuf.TxMessage tx = 6;
  bool has_tx() const;
  void clear_tx();
  static const int kTxFieldNumber = 6;
  private:
  const ::zjchain::ws::protobuf::TxMessage& _internal_tx() const;
  public:
  const ::zjchain::ws::protobuf::TxMessage& tx() const;
  ::zjchain::ws::protobuf::TxMessage* release_tx();
  ::zjchain::ws::protobuf::TxMessage* mutable_tx();
  void set_allocated_tx(::zjchain::ws::protobuf::TxMessage* tx);

  // optional .zjchain.ws.protobuf.C2cMessage c2c = 8;
  bool has_c2c() const;
  void clear_c2c();
  static const int kC2CFieldNumber = 8;
  private:
  const ::zjchain::ws::protobuf::C2cMessage& _internal_c2c() const;
  public:
  const ::zjchain::ws::protobuf::C2cMessage& c2c() const;
  ::zjchain::ws::protobuf::C2cMessage* release_c2c();
  ::zjchain::ws::protobuf::C2cMessage* mutable_c2c();
  void set_allocated_c2c(::zjchain::ws::protobuf::C2cMessage* c2c);

  // optional .zjchain.ws.protobuf.StatusInfo status = 9;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 9;
  private:
  const ::zjchain::ws::protobuf::StatusInfo& _internal_status() const;
  public:
  const ::zjchain::ws::protobuf::StatusInfo& status() const;
  ::zjchain::ws::protobuf::StatusInfo* release_status();
  ::zjchain::ws::protobuf::StatusInfo* mutable_status();
  void set_allocated_status(::zjchain::ws::protobuf::StatusInfo* status);

  // optional uint64 tx_height = 7;
  bool has_tx_height() const;
  void clear_tx_height();
  static const int kTxHeightFieldNumber = 7;
  ::google::protobuf::uint64 tx_height() const;
  void set_tx_height(::google::protobuf::uint64 value);

  // optional uint64 msg_id = 10;
  bool has_msg_id() const;
  void clear_msg_id();
  static const int kMsgIdFieldNumber = 10;
  ::google::protobuf::uint64 msg_id() const;
  void set_msg_id(::google::protobuf::uint64 value);

  // optional .zjchain.ws.protobuf.InitInfoTagType tag = 5;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 5;
  ::zjchain::ws::protobuf::InitInfoTagType tag() const;
  void set_tag(::zjchain::ws::protobuf::InitInfoTagType value);

  // @@protoc_insertion_point(class_scope:zjchain.ws.protobuf.InitInfo)
 private:
  void set_has_pubkey();
  void clear_has_pubkey();
  void set_has_platform();
  void clear_has_platform();
  void set_has_version();
  void clear_has_version();
  void set_has_pk_hash();
  void clear_has_pk_hash();
  void set_has_tag();
  void clear_has_tag();
  void set_has_tx();
  void clear_has_tx();
  void set_has_tx_height();
  void clear_has_tx_height();
  void set_has_c2c();
  void clear_has_c2c();
  void set_has_status();
  void clear_has_status();
  void set_has_msg_id();
  void clear_has_msg_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr pubkey_;
  ::google::protobuf::internal::ArenaStringPtr platform_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr pk_hash_;
  ::zjchain::ws::protobuf::TxMessage* tx_;
  ::zjchain::ws::protobuf::C2cMessage* c2c_;
  ::zjchain::ws::protobuf::StatusInfo* status_;
  ::google::protobuf::uint64 tx_height_;
  ::google::protobuf::uint64 msg_id_;
  int tag_;
  friend struct ::protobuf_protos_2fws_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WsTxItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.ws.protobuf.WsTxItem) */ {
 public:
  WsTxItem();
  virtual ~WsTxItem();

  WsTxItem(const WsTxItem& from);

  inline WsTxItem& operator=(const WsTxItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WsTxItem(WsTxItem&& from) noexcept
    : WsTxItem() {
    *this = ::std::move(from);
  }

  inline WsTxItem& operator=(WsTxItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WsTxItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WsTxItem* internal_default_instance() {
    return reinterpret_cast<const WsTxItem*>(
               &_WsTxItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(WsTxItem* other);
  friend void swap(WsTxItem& a, WsTxItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WsTxItem* New() const final {
    return CreateMaybeMessage<WsTxItem>(NULL);
  }

  WsTxItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WsTxItem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WsTxItem& from);
  void MergeFrom(const WsTxItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WsTxItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes from = 1;
  bool has_from() const;
  void clear_from();
  static const int kFromFieldNumber = 1;
  const ::std::string& from() const;
  void set_from(const ::std::string& value);
  #if LANG_CXX11
  void set_from(::std::string&& value);
  #endif
  void set_from(const char* value);
  void set_from(const void* value, size_t size);
  ::std::string* mutable_from();
  ::std::string* release_from();
  void set_allocated_from(::std::string* from);

  // optional bytes to = 2;
  bool has_to() const;
  void clear_to();
  static const int kToFieldNumber = 2;
  const ::std::string& to() const;
  void set_to(const ::std::string& value);
  #if LANG_CXX11
  void set_to(::std::string&& value);
  #endif
  void set_to(const char* value);
  void set_to(const void* value, size_t size);
  ::std::string* mutable_to();
  ::std::string* release_to();
  void set_allocated_to(::std::string* to);

  // optional uint64 amount = 3;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // optional uint64 balance = 4;
  bool has_balance() const;
  void clear_balance();
  static const int kBalanceFieldNumber = 4;
  ::google::protobuf::uint64 balance() const;
  void set_balance(::google::protobuf::uint64 value);

  // optional uint64 height = 5;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 5;
  ::google::protobuf::uint64 height() const;
  void set_height(::google::protobuf::uint64 value);

  // optional uint64 timestamp = 7;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 7;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // optional uint32 to_add = 6;
  bool has_to_add() const;
  void clear_to_add();
  static const int kToAddFieldNumber = 6;
  ::google::protobuf::uint32 to_add() const;
  void set_to_add(::google::protobuf::uint32 value);

  // optional int32 status = 8;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 8;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zjchain.ws.protobuf.WsTxItem)
 private:
  void set_has_from();
  void clear_has_from();
  void set_has_to();
  void clear_has_to();
  void set_has_amount();
  void clear_has_amount();
  void set_has_balance();
  void clear_has_balance();
  void set_has_height();
  void clear_has_height();
  void set_has_to_add();
  void clear_has_to_add();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr from_;
  ::google::protobuf::internal::ArenaStringPtr to_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint64 balance_;
  ::google::protobuf::uint64 height_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 to_add_;
  ::google::protobuf::int32 status_;
  friend struct ::protobuf_protos_2fws_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WsTxItemResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.ws.protobuf.WsTxItemResponse) */ {
 public:
  WsTxItemResponse();
  virtual ~WsTxItemResponse();

  WsTxItemResponse(const WsTxItemResponse& from);

  inline WsTxItemResponse& operator=(const WsTxItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WsTxItemResponse(WsTxItemResponse&& from) noexcept
    : WsTxItemResponse() {
    *this = ::std::move(from);
  }

  inline WsTxItemResponse& operator=(WsTxItemResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WsTxItemResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WsTxItemResponse* internal_default_instance() {
    return reinterpret_cast<const WsTxItemResponse*>(
               &_WsTxItemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(WsTxItemResponse* other);
  friend void swap(WsTxItemResponse& a, WsTxItemResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WsTxItemResponse* New() const final {
    return CreateMaybeMessage<WsTxItemResponse>(NULL);
  }

  WsTxItemResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WsTxItemResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WsTxItemResponse& from);
  void MergeFrom(const WsTxItemResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WsTxItemResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zjchain.ws.protobuf.WsTxItem txs = 1;
  int txs_size() const;
  void clear_txs();
  static const int kTxsFieldNumber = 1;
  ::zjchain::ws::protobuf::WsTxItem* mutable_txs(int index);
  ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::WsTxItem >*
      mutable_txs();
  const ::zjchain::ws::protobuf::WsTxItem& txs(int index) const;
  ::zjchain::ws::protobuf::WsTxItem* add_txs();
  const ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::WsTxItem >&
      txs() const;

  // @@protoc_insertion_point(class_scope:zjchain.ws.protobuf.WsTxItemResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::WsTxItem > txs_;
  friend struct ::protobuf_protos_2fws_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BandwidthItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.ws.protobuf.BandwidthItem) */ {
 public:
  BandwidthItem();
  virtual ~BandwidthItem();

  BandwidthItem(const BandwidthItem& from);

  inline BandwidthItem& operator=(const BandwidthItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BandwidthItem(BandwidthItem&& from) noexcept
    : BandwidthItem() {
    *this = ::std::move(from);
  }

  inline BandwidthItem& operator=(BandwidthItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BandwidthItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BandwidthItem* internal_default_instance() {
    return reinterpret_cast<const BandwidthItem*>(
               &_BandwidthItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(BandwidthItem* other);
  friend void swap(BandwidthItem& a, BandwidthItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BandwidthItem* New() const final {
    return CreateMaybeMessage<BandwidthItem>(NULL);
  }

  BandwidthItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BandwidthItem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BandwidthItem& from);
  void MergeFrom(const BandwidthItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BandwidthItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional uint64 bandwidth = 2;
  bool has_bandwidth() const;
  void clear_bandwidth();
  static const int kBandwidthFieldNumber = 2;
  ::google::protobuf::uint64 bandwidth() const;
  void set_bandwidth(::google::protobuf::uint64 value);

  // optional uint64 timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:zjchain.ws.protobuf.BandwidthItem)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_bandwidth();
  void clear_has_bandwidth();
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::uint64 bandwidth_;
  ::google::protobuf::uint64 timestamp_;
  friend struct ::protobuf_protos_2fws_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BandwidthInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.ws.protobuf.BandwidthInfo) */ {
 public:
  BandwidthInfo();
  virtual ~BandwidthInfo();

  BandwidthInfo(const BandwidthInfo& from);

  inline BandwidthInfo& operator=(const BandwidthInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BandwidthInfo(BandwidthInfo&& from) noexcept
    : BandwidthInfo() {
    *this = ::std::move(from);
  }

  inline BandwidthInfo& operator=(BandwidthInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BandwidthInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BandwidthInfo* internal_default_instance() {
    return reinterpret_cast<const BandwidthInfo*>(
               &_BandwidthInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(BandwidthInfo* other);
  friend void swap(BandwidthInfo& a, BandwidthInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BandwidthInfo* New() const final {
    return CreateMaybeMessage<BandwidthInfo>(NULL);
  }

  BandwidthInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BandwidthInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BandwidthInfo& from);
  void MergeFrom(const BandwidthInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BandwidthInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zjchain.ws.protobuf.BandwidthItem bws = 1;
  int bws_size() const;
  void clear_bws();
  static const int kBwsFieldNumber = 1;
  ::zjchain::ws::protobuf::BandwidthItem* mutable_bws(int index);
  ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::BandwidthItem >*
      mutable_bws();
  const ::zjchain::ws::protobuf::BandwidthItem& bws(int index) const;
  ::zjchain::ws::protobuf::BandwidthItem* add_bws();
  const ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::BandwidthItem >&
      bws() const;

  // @@protoc_insertion_point(class_scope:zjchain.ws.protobuf.BandwidthInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::BandwidthItem > bws_;
  friend struct ::protobuf_protos_2fws_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WsMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.ws.protobuf.WsMessage) */ {
 public:
  WsMessage();
  virtual ~WsMessage();

  WsMessage(const WsMessage& from);

  inline WsMessage& operator=(const WsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WsMessage(WsMessage&& from) noexcept
    : WsMessage() {
    *this = ::std::move(from);
  }

  inline WsMessage& operator=(WsMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WsMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WsMessage* internal_default_instance() {
    return reinterpret_cast<const WsMessage*>(
               &_WsMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(WsMessage* other);
  friend void swap(WsMessage& a, WsMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WsMessage* New() const final {
    return CreateMaybeMessage<WsMessage>(NULL);
  }

  WsMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WsMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WsMessage& from);
  void MergeFrom(const WsMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WsMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zjchain.ws.protobuf.WsTxItem txs = 1;
  int txs_size() const;
  void clear_txs();
  static const int kTxsFieldNumber = 1;
  ::zjchain::ws::protobuf::WsTxItem* mutable_txs(int index);
  ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::WsTxItem >*
      mutable_txs();
  const ::zjchain::ws::protobuf::WsTxItem& txs(int index) const;
  ::zjchain::ws::protobuf::WsTxItem* add_txs();
  const ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::WsTxItem >&
      txs() const;

  // repeated .zjchain.ws.protobuf.BandwidthItem bws = 2;
  int bws_size() const;
  void clear_bws();
  static const int kBwsFieldNumber = 2;
  ::zjchain::ws::protobuf::BandwidthItem* mutable_bws(int index);
  ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::BandwidthItem >*
      mutable_bws();
  const ::zjchain::ws::protobuf::BandwidthItem& bws(int index) const;
  ::zjchain::ws::protobuf::BandwidthItem* add_bws();
  const ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::BandwidthItem >&
      bws() const;

  // optional .zjchain.ws.protobuf.InitInfo init_info = 3;
  bool has_init_info() const;
  void clear_init_info();
  static const int kInitInfoFieldNumber = 3;
  private:
  const ::zjchain::ws::protobuf::InitInfo& _internal_init_info() const;
  public:
  const ::zjchain::ws::protobuf::InitInfo& init_info() const;
  ::zjchain::ws::protobuf::InitInfo* release_init_info();
  ::zjchain::ws::protobuf::InitInfo* mutable_init_info();
  void set_allocated_init_info(::zjchain::ws::protobuf::InitInfo* init_info);

  // @@protoc_insertion_point(class_scope:zjchain.ws.protobuf.WsMessage)
 private:
  void set_has_init_info();
  void clear_has_init_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::WsTxItem > txs_;
  ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::BandwidthItem > bws_;
  ::zjchain::ws::protobuf::InitInfo* init_info_;
  friend struct ::protobuf_protos_2fws_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TxMessage

// optional uint32 version = 1;
inline bool TxMessage::has_version() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TxMessage::set_has_version() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TxMessage::clear_has_version() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TxMessage::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 TxMessage::version() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.TxMessage.version)
  return version_;
}
inline void TxMessage::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.TxMessage.version)
}

// optional bytes gid = 2;
inline bool TxMessage::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxMessage::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxMessage::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxMessage::clear_gid() {
  gid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gid();
}
inline const ::std::string& TxMessage::gid() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.TxMessage.gid)
  return gid_.GetNoArena();
}
inline void TxMessage::set_gid(const ::std::string& value) {
  set_has_gid();
  gid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.TxMessage.gid)
}
#if LANG_CXX11
inline void TxMessage::set_gid(::std::string&& value) {
  set_has_gid();
  gid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.TxMessage.gid)
}
#endif
inline void TxMessage::set_gid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_gid();
  gid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.TxMessage.gid)
}
inline void TxMessage::set_gid(const void* value, size_t size) {
  set_has_gid();
  gid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.TxMessage.gid)
}
inline ::std::string* TxMessage::mutable_gid() {
  set_has_gid();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.TxMessage.gid)
  return gid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxMessage::release_gid() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.TxMessage.gid)
  if (!has_gid()) {
    return NULL;
  }
  clear_has_gid();
  return gid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxMessage::set_allocated_gid(::std::string* gid) {
  if (gid != NULL) {
    set_has_gid();
  } else {
    clear_has_gid();
  }
  gid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gid);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.TxMessage.gid)
}

// optional bytes pubkey = 3;
inline bool TxMessage::has_pubkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxMessage::set_has_pubkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxMessage::clear_has_pubkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxMessage::clear_pubkey() {
  pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pubkey();
}
inline const ::std::string& TxMessage::pubkey() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.TxMessage.pubkey)
  return pubkey_.GetNoArena();
}
inline void TxMessage::set_pubkey(const ::std::string& value) {
  set_has_pubkey();
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.TxMessage.pubkey)
}
#if LANG_CXX11
inline void TxMessage::set_pubkey(::std::string&& value) {
  set_has_pubkey();
  pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.TxMessage.pubkey)
}
#endif
inline void TxMessage::set_pubkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pubkey();
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.TxMessage.pubkey)
}
inline void TxMessage::set_pubkey(const void* value, size_t size) {
  set_has_pubkey();
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.TxMessage.pubkey)
}
inline ::std::string* TxMessage::mutable_pubkey() {
  set_has_pubkey();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.TxMessage.pubkey)
  return pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxMessage::release_pubkey() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.TxMessage.pubkey)
  if (!has_pubkey()) {
    return NULL;
  }
  clear_has_pubkey();
  return pubkey_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxMessage::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey != NULL) {
    set_has_pubkey();
  } else {
    clear_has_pubkey();
  }
  pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pubkey);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.TxMessage.pubkey)
}

// optional uint64 gas_limit = 4;
inline bool TxMessage::has_gas_limit() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TxMessage::set_has_gas_limit() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TxMessage::clear_has_gas_limit() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TxMessage::clear_gas_limit() {
  gas_limit_ = GOOGLE_ULONGLONG(0);
  clear_has_gas_limit();
}
inline ::google::protobuf::uint64 TxMessage::gas_limit() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.TxMessage.gas_limit)
  return gas_limit_;
}
inline void TxMessage::set_gas_limit(::google::protobuf::uint64 value) {
  set_has_gas_limit();
  gas_limit_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.TxMessage.gas_limit)
}

// optional uint64 gas_price = 5;
inline bool TxMessage::has_gas_price() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TxMessage::set_has_gas_price() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TxMessage::clear_has_gas_price() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TxMessage::clear_gas_price() {
  gas_price_ = GOOGLE_ULONGLONG(0);
  clear_has_gas_price();
}
inline ::google::protobuf::uint64 TxMessage::gas_price() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.TxMessage.gas_price)
  return gas_price_;
}
inline void TxMessage::set_gas_price(::google::protobuf::uint64 value) {
  set_has_gas_price();
  gas_price_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.TxMessage.gas_price)
}

// optional bytes key = 6;
inline bool TxMessage::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxMessage::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxMessage::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxMessage::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& TxMessage::key() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.TxMessage.key)
  return key_.GetNoArena();
}
inline void TxMessage::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.TxMessage.key)
}
#if LANG_CXX11
inline void TxMessage::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.TxMessage.key)
}
#endif
inline void TxMessage::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.TxMessage.key)
}
inline void TxMessage::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.TxMessage.key)
}
inline ::std::string* TxMessage::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.TxMessage.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxMessage::release_key() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.TxMessage.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxMessage::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.TxMessage.key)
}

// optional bytes value = 7;
inline bool TxMessage::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxMessage::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxMessage::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxMessage::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& TxMessage::value() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.TxMessage.value)
  return value_.GetNoArena();
}
inline void TxMessage::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.TxMessage.value)
}
#if LANG_CXX11
inline void TxMessage::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.TxMessage.value)
}
#endif
inline void TxMessage::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.TxMessage.value)
}
inline void TxMessage::set_value(const void* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.TxMessage.value)
}
inline ::std::string* TxMessage::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.TxMessage.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxMessage::release_value() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.TxMessage.value)
  if (!has_value()) {
    return NULL;
  }
  clear_has_value();
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxMessage::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.TxMessage.value)
}

// optional bytes to = 8;
inline bool TxMessage::has_to() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxMessage::set_has_to() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TxMessage::clear_has_to() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TxMessage::clear_to() {
  to_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_to();
}
inline const ::std::string& TxMessage::to() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.TxMessage.to)
  return to_.GetNoArena();
}
inline void TxMessage::set_to(const ::std::string& value) {
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.TxMessage.to)
}
#if LANG_CXX11
inline void TxMessage::set_to(::std::string&& value) {
  set_has_to();
  to_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.TxMessage.to)
}
#endif
inline void TxMessage::set_to(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.TxMessage.to)
}
inline void TxMessage::set_to(const void* value, size_t size) {
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.TxMessage.to)
}
inline ::std::string* TxMessage::mutable_to() {
  set_has_to();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.TxMessage.to)
  return to_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxMessage::release_to() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.TxMessage.to)
  if (!has_to()) {
    return NULL;
  }
  clear_has_to();
  return to_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxMessage::set_allocated_to(::std::string* to) {
  if (to != NULL) {
    set_has_to();
  } else {
    clear_has_to();
  }
  to_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.TxMessage.to)
}

// optional uint64 amount = 9;
inline bool TxMessage::has_amount() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TxMessage::set_has_amount() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TxMessage::clear_has_amount() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TxMessage::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 TxMessage::amount() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.TxMessage.amount)
  return amount_;
}
inline void TxMessage::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.TxMessage.amount)
}

// optional .zjchain.ws.protobuf.StepType step = 10 [default = kNormalFrom];
inline bool TxMessage::has_step() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TxMessage::set_has_step() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TxMessage::clear_has_step() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TxMessage::clear_step() {
  step_ = 0;
  clear_has_step();
}
inline ::zjchain::ws::protobuf::StepType TxMessage::step() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.TxMessage.step)
  return static_cast< ::zjchain::ws::protobuf::StepType >(step_);
}
inline void TxMessage::set_step(::zjchain::ws::protobuf::StepType value) {
  assert(::zjchain::ws::protobuf::StepType_IsValid(value));
  set_has_step();
  step_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.TxMessage.step)
}

// optional uint64 contract_prepayment = 11;
inline bool TxMessage::has_contract_prepayment() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TxMessage::set_has_contract_prepayment() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TxMessage::clear_has_contract_prepayment() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TxMessage::clear_contract_prepayment() {
  contract_prepayment_ = GOOGLE_ULONGLONG(0);
  clear_has_contract_prepayment();
}
inline ::google::protobuf::uint64 TxMessage::contract_prepayment() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.TxMessage.contract_prepayment)
  return contract_prepayment_;
}
inline void TxMessage::set_contract_prepayment(::google::protobuf::uint64 value) {
  set_has_contract_prepayment();
  contract_prepayment_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.TxMessage.contract_prepayment)
}

// optional bytes contract_code = 12;
inline bool TxMessage::has_contract_code() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TxMessage::set_has_contract_code() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TxMessage::clear_has_contract_code() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TxMessage::clear_contract_code() {
  contract_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_contract_code();
}
inline const ::std::string& TxMessage::contract_code() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.TxMessage.contract_code)
  return contract_code_.GetNoArena();
}
inline void TxMessage::set_contract_code(const ::std::string& value) {
  set_has_contract_code();
  contract_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.TxMessage.contract_code)
}
#if LANG_CXX11
inline void TxMessage::set_contract_code(::std::string&& value) {
  set_has_contract_code();
  contract_code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.TxMessage.contract_code)
}
#endif
inline void TxMessage::set_contract_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_contract_code();
  contract_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.TxMessage.contract_code)
}
inline void TxMessage::set_contract_code(const void* value, size_t size) {
  set_has_contract_code();
  contract_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.TxMessage.contract_code)
}
inline ::std::string* TxMessage::mutable_contract_code() {
  set_has_contract_code();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.TxMessage.contract_code)
  return contract_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxMessage::release_contract_code() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.TxMessage.contract_code)
  if (!has_contract_code()) {
    return NULL;
  }
  clear_has_contract_code();
  return contract_code_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxMessage::set_allocated_contract_code(::std::string* contract_code) {
  if (contract_code != NULL) {
    set_has_contract_code();
  } else {
    clear_has_contract_code();
  }
  contract_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contract_code);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.TxMessage.contract_code)
}

// optional bytes contract_input = 13;
inline bool TxMessage::has_contract_input() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TxMessage::set_has_contract_input() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TxMessage::clear_has_contract_input() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TxMessage::clear_contract_input() {
  contract_input_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_contract_input();
}
inline const ::std::string& TxMessage::contract_input() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.TxMessage.contract_input)
  return contract_input_.GetNoArena();
}
inline void TxMessage::set_contract_input(const ::std::string& value) {
  set_has_contract_input();
  contract_input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.TxMessage.contract_input)
}
#if LANG_CXX11
inline void TxMessage::set_contract_input(::std::string&& value) {
  set_has_contract_input();
  contract_input_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.TxMessage.contract_input)
}
#endif
inline void TxMessage::set_contract_input(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_contract_input();
  contract_input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.TxMessage.contract_input)
}
inline void TxMessage::set_contract_input(const void* value, size_t size) {
  set_has_contract_input();
  contract_input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.TxMessage.contract_input)
}
inline ::std::string* TxMessage::mutable_contract_input() {
  set_has_contract_input();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.TxMessage.contract_input)
  return contract_input_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxMessage::release_contract_input() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.TxMessage.contract_input)
  if (!has_contract_input()) {
    return NULL;
  }
  clear_has_contract_input();
  return contract_input_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxMessage::set_allocated_contract_input(::std::string* contract_input) {
  if (contract_input != NULL) {
    set_has_contract_input();
  } else {
    clear_has_contract_input();
  }
  contract_input_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contract_input);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.TxMessage.contract_input)
}

// optional bytes signr = 14;
inline bool TxMessage::has_signr() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TxMessage::set_has_signr() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TxMessage::clear_has_signr() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TxMessage::clear_signr() {
  signr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signr();
}
inline const ::std::string& TxMessage::signr() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.TxMessage.signr)
  return signr_.GetNoArena();
}
inline void TxMessage::set_signr(const ::std::string& value) {
  set_has_signr();
  signr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.TxMessage.signr)
}
#if LANG_CXX11
inline void TxMessage::set_signr(::std::string&& value) {
  set_has_signr();
  signr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.TxMessage.signr)
}
#endif
inline void TxMessage::set_signr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signr();
  signr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.TxMessage.signr)
}
inline void TxMessage::set_signr(const void* value, size_t size) {
  set_has_signr();
  signr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.TxMessage.signr)
}
inline ::std::string* TxMessage::mutable_signr() {
  set_has_signr();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.TxMessage.signr)
  return signr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxMessage::release_signr() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.TxMessage.signr)
  if (!has_signr()) {
    return NULL;
  }
  clear_has_signr();
  return signr_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxMessage::set_allocated_signr(::std::string* signr) {
  if (signr != NULL) {
    set_has_signr();
  } else {
    clear_has_signr();
  }
  signr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signr);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.TxMessage.signr)
}

// optional bytes signs = 15;
inline bool TxMessage::has_signs() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TxMessage::set_has_signs() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TxMessage::clear_has_signs() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TxMessage::clear_signs() {
  signs_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signs();
}
inline const ::std::string& TxMessage::signs() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.TxMessage.signs)
  return signs_.GetNoArena();
}
inline void TxMessage::set_signs(const ::std::string& value) {
  set_has_signs();
  signs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.TxMessage.signs)
}
#if LANG_CXX11
inline void TxMessage::set_signs(::std::string&& value) {
  set_has_signs();
  signs_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.TxMessage.signs)
}
#endif
inline void TxMessage::set_signs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signs();
  signs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.TxMessage.signs)
}
inline void TxMessage::set_signs(const void* value, size_t size) {
  set_has_signs();
  signs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.TxMessage.signs)
}
inline ::std::string* TxMessage::mutable_signs() {
  set_has_signs();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.TxMessage.signs)
  return signs_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxMessage::release_signs() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.TxMessage.signs)
  if (!has_signs()) {
    return NULL;
  }
  clear_has_signs();
  return signs_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxMessage::set_allocated_signs(::std::string* signs) {
  if (signs != NULL) {
    set_has_signs();
  } else {
    clear_has_signs();
  }
  signs_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signs);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.TxMessage.signs)
}

// optional bytes signv = 16;
inline bool TxMessage::has_signv() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TxMessage::set_has_signv() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TxMessage::clear_has_signv() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TxMessage::clear_signv() {
  signv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signv();
}
inline const ::std::string& TxMessage::signv() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.TxMessage.signv)
  return signv_.GetNoArena();
}
inline void TxMessage::set_signv(const ::std::string& value) {
  set_has_signv();
  signv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.TxMessage.signv)
}
#if LANG_CXX11
inline void TxMessage::set_signv(::std::string&& value) {
  set_has_signv();
  signv_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.TxMessage.signv)
}
#endif
inline void TxMessage::set_signv(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signv();
  signv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.TxMessage.signv)
}
inline void TxMessage::set_signv(const void* value, size_t size) {
  set_has_signv();
  signv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.TxMessage.signv)
}
inline ::std::string* TxMessage::mutable_signv() {
  set_has_signv();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.TxMessage.signv)
  return signv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxMessage::release_signv() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.TxMessage.signv)
  if (!has_signv()) {
    return NULL;
  }
  clear_has_signv();
  return signv_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxMessage::set_allocated_signv(::std::string* signv) {
  if (signv != NULL) {
    set_has_signv();
  } else {
    clear_has_signv();
  }
  signv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signv);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.TxMessage.signv)
}

// -------------------------------------------------------------------

// OrderInfo

// optional bytes buyer = 1;
inline bool OrderInfo::has_buyer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderInfo::set_has_buyer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderInfo::clear_has_buyer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderInfo::clear_buyer() {
  buyer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_buyer();
}
inline const ::std::string& OrderInfo::buyer() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.OrderInfo.buyer)
  return buyer_.GetNoArena();
}
inline void OrderInfo::set_buyer(const ::std::string& value) {
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.OrderInfo.buyer)
}
#if LANG_CXX11
inline void OrderInfo::set_buyer(::std::string&& value) {
  set_has_buyer();
  buyer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.OrderInfo.buyer)
}
#endif
inline void OrderInfo::set_buyer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.OrderInfo.buyer)
}
inline void OrderInfo::set_buyer(const void* value, size_t size) {
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.OrderInfo.buyer)
}
inline ::std::string* OrderInfo::mutable_buyer() {
  set_has_buyer();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.OrderInfo.buyer)
  return buyer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OrderInfo::release_buyer() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.OrderInfo.buyer)
  if (!has_buyer()) {
    return NULL;
  }
  clear_has_buyer();
  return buyer_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OrderInfo::set_allocated_buyer(::std::string* buyer) {
  if (buyer != NULL) {
    set_has_buyer();
  } else {
    clear_has_buyer();
  }
  buyer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), buyer);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.OrderInfo.buyer)
}

// optional .zjchain.ws.protobuf.Status status = 2;
inline bool OrderInfo::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderInfo::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderInfo::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::zjchain::ws::protobuf::Status OrderInfo::status() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.OrderInfo.status)
  return static_cast< ::zjchain::ws::protobuf::Status >(status_);
}
inline void OrderInfo::set_status(::zjchain::ws::protobuf::Status value) {
  assert(::zjchain::ws::protobuf::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.OrderInfo.status)
}

// optional uint64 amount = 3;
inline bool OrderInfo::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderInfo::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderInfo::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderInfo::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 OrderInfo::amount() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.OrderInfo.amount)
  return amount_;
}
inline void OrderInfo::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.OrderInfo.amount)
}

// optional bytes seller = 4;
inline bool OrderInfo::has_seller() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderInfo::set_has_seller() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderInfo::clear_has_seller() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderInfo::clear_seller() {
  seller_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_seller();
}
inline const ::std::string& OrderInfo::seller() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.OrderInfo.seller)
  return seller_.GetNoArena();
}
inline void OrderInfo::set_seller(const ::std::string& value) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.OrderInfo.seller)
}
#if LANG_CXX11
inline void OrderInfo::set_seller(::std::string&& value) {
  set_has_seller();
  seller_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.OrderInfo.seller)
}
#endif
inline void OrderInfo::set_seller(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.OrderInfo.seller)
}
inline void OrderInfo::set_seller(const void* value, size_t size) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.OrderInfo.seller)
}
inline ::std::string* OrderInfo::mutable_seller() {
  set_has_seller();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.OrderInfo.seller)
  return seller_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OrderInfo::release_seller() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.OrderInfo.seller)
  if (!has_seller()) {
    return NULL;
  }
  clear_has_seller();
  return seller_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OrderInfo::set_allocated_seller(::std::string* seller) {
  if (seller != NULL) {
    set_has_seller();
  } else {
    clear_has_seller();
  }
  seller_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), seller);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.OrderInfo.seller)
}

// optional uint64 create_tm_ms = 5;
inline bool OrderInfo::has_create_tm_ms() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderInfo::set_has_create_tm_ms() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderInfo::clear_has_create_tm_ms() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderInfo::clear_create_tm_ms() {
  create_tm_ms_ = GOOGLE_ULONGLONG(0);
  clear_has_create_tm_ms();
}
inline ::google::protobuf::uint64 OrderInfo::create_tm_ms() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.OrderInfo.create_tm_ms)
  return create_tm_ms_;
}
inline void OrderInfo::set_create_tm_ms(::google::protobuf::uint64 value) {
  set_has_create_tm_ms();
  create_tm_ms_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.OrderInfo.create_tm_ms)
}

// -------------------------------------------------------------------

// ReceivableInfo

// optional .zjchain.ws.protobuf.ReceiveType type = 1;
inline bool ReceivableInfo::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReceivableInfo::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReceivableInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReceivableInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::zjchain::ws::protobuf::ReceiveType ReceivableInfo::type() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.ReceivableInfo.type)
  return static_cast< ::zjchain::ws::protobuf::ReceiveType >(type_);
}
inline void ReceivableInfo::set_type(::zjchain::ws::protobuf::ReceiveType value) {
  assert(::zjchain::ws::protobuf::ReceiveType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.ReceivableInfo.type)
}

// optional bytes name = 2;
inline bool ReceivableInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReceivableInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReceivableInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReceivableInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ReceivableInfo::name() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.ReceivableInfo.name)
  return name_.GetNoArena();
}
inline void ReceivableInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.ReceivableInfo.name)
}
#if LANG_CXX11
inline void ReceivableInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.ReceivableInfo.name)
}
#endif
inline void ReceivableInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.ReceivableInfo.name)
}
inline void ReceivableInfo::set_name(const void* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.ReceivableInfo.name)
}
inline ::std::string* ReceivableInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.ReceivableInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReceivableInfo::release_name() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.ReceivableInfo.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReceivableInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.ReceivableInfo.name)
}

// optional bytes id = 3;
inline bool ReceivableInfo::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReceivableInfo::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReceivableInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReceivableInfo::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& ReceivableInfo::id() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.ReceivableInfo.id)
  return id_.GetNoArena();
}
inline void ReceivableInfo::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.ReceivableInfo.id)
}
#if LANG_CXX11
inline void ReceivableInfo::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.ReceivableInfo.id)
}
#endif
inline void ReceivableInfo::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.ReceivableInfo.id)
}
inline void ReceivableInfo::set_id(const void* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.ReceivableInfo.id)
}
inline ::std::string* ReceivableInfo::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.ReceivableInfo.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReceivableInfo::release_id() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.ReceivableInfo.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReceivableInfo::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.ReceivableInfo.id)
}

// optional bytes user_name = 4;
inline bool ReceivableInfo::has_user_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReceivableInfo::set_has_user_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReceivableInfo::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReceivableInfo::clear_user_name() {
  user_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_name();
}
inline const ::std::string& ReceivableInfo::user_name() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.ReceivableInfo.user_name)
  return user_name_.GetNoArena();
}
inline void ReceivableInfo::set_user_name(const ::std::string& value) {
  set_has_user_name();
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.ReceivableInfo.user_name)
}
#if LANG_CXX11
inline void ReceivableInfo::set_user_name(::std::string&& value) {
  set_has_user_name();
  user_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.ReceivableInfo.user_name)
}
#endif
inline void ReceivableInfo::set_user_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user_name();
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.ReceivableInfo.user_name)
}
inline void ReceivableInfo::set_user_name(const void* value, size_t size) {
  set_has_user_name();
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.ReceivableInfo.user_name)
}
inline ::std::string* ReceivableInfo::mutable_user_name() {
  set_has_user_name();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.ReceivableInfo.user_name)
  return user_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReceivableInfo::release_user_name() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.ReceivableInfo.user_name)
  if (!has_user_name()) {
    return NULL;
  }
  clear_has_user_name();
  return user_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReceivableInfo::set_allocated_user_name(::std::string* user_name) {
  if (user_name != NULL) {
    set_has_user_name();
  } else {
    clear_has_user_name();
  }
  user_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_name);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.ReceivableInfo.user_name)
}

// optional bytes other = 5;
inline bool ReceivableInfo::has_other() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReceivableInfo::set_has_other() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReceivableInfo::clear_has_other() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReceivableInfo::clear_other() {
  other_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_other();
}
inline const ::std::string& ReceivableInfo::other() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.ReceivableInfo.other)
  return other_.GetNoArena();
}
inline void ReceivableInfo::set_other(const ::std::string& value) {
  set_has_other();
  other_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.ReceivableInfo.other)
}
#if LANG_CXX11
inline void ReceivableInfo::set_other(::std::string&& value) {
  set_has_other();
  other_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.ReceivableInfo.other)
}
#endif
inline void ReceivableInfo::set_other(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_other();
  other_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.ReceivableInfo.other)
}
inline void ReceivableInfo::set_other(const void* value, size_t size) {
  set_has_other();
  other_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.ReceivableInfo.other)
}
inline ::std::string* ReceivableInfo::mutable_other() {
  set_has_other();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.ReceivableInfo.other)
  return other_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReceivableInfo::release_other() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.ReceivableInfo.other)
  if (!has_other()) {
    return NULL;
  }
  clear_has_other();
  return other_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReceivableInfo::set_allocated_other(::std::string* other) {
  if (other != NULL) {
    set_has_other();
  } else {
    clear_has_other();
  }
  other_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), other);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.ReceivableInfo.other)
}

// optional bytes qrcode = 6;
inline bool ReceivableInfo::has_qrcode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReceivableInfo::set_has_qrcode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReceivableInfo::clear_has_qrcode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReceivableInfo::clear_qrcode() {
  qrcode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_qrcode();
}
inline const ::std::string& ReceivableInfo::qrcode() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.ReceivableInfo.qrcode)
  return qrcode_.GetNoArena();
}
inline void ReceivableInfo::set_qrcode(const ::std::string& value) {
  set_has_qrcode();
  qrcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.ReceivableInfo.qrcode)
}
#if LANG_CXX11
inline void ReceivableInfo::set_qrcode(::std::string&& value) {
  set_has_qrcode();
  qrcode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.ReceivableInfo.qrcode)
}
#endif
inline void ReceivableInfo::set_qrcode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_qrcode();
  qrcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.ReceivableInfo.qrcode)
}
inline void ReceivableInfo::set_qrcode(const void* value, size_t size) {
  set_has_qrcode();
  qrcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.ReceivableInfo.qrcode)
}
inline ::std::string* ReceivableInfo::mutable_qrcode() {
  set_has_qrcode();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.ReceivableInfo.qrcode)
  return qrcode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReceivableInfo::release_qrcode() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.ReceivableInfo.qrcode)
  if (!has_qrcode()) {
    return NULL;
  }
  clear_has_qrcode();
  return qrcode_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReceivableInfo::set_allocated_qrcode(::std::string* qrcode) {
  if (qrcode != NULL) {
    set_has_qrcode();
  } else {
    clear_has_qrcode();
  }
  qrcode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), qrcode);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.ReceivableInfo.qrcode)
}

// -------------------------------------------------------------------

// ReceivableArray

// repeated .zjchain.ws.protobuf.ReceivableInfo receivable = 1;
inline int ReceivableArray::receivable_size() const {
  return receivable_.size();
}
inline void ReceivableArray::clear_receivable() {
  receivable_.Clear();
}
inline ::zjchain::ws::protobuf::ReceivableInfo* ReceivableArray::mutable_receivable(int index) {
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.ReceivableArray.receivable)
  return receivable_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::ReceivableInfo >*
ReceivableArray::mutable_receivable() {
  // @@protoc_insertion_point(field_mutable_list:zjchain.ws.protobuf.ReceivableArray.receivable)
  return &receivable_;
}
inline const ::zjchain::ws::protobuf::ReceivableInfo& ReceivableArray::receivable(int index) const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.ReceivableArray.receivable)
  return receivable_.Get(index);
}
inline ::zjchain::ws::protobuf::ReceivableInfo* ReceivableArray::add_receivable() {
  // @@protoc_insertion_point(field_add:zjchain.ws.protobuf.ReceivableArray.receivable)
  return receivable_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::ReceivableInfo >&
ReceivableArray::receivable() const {
  // @@protoc_insertion_point(field_list:zjchain.ws.protobuf.ReceivableArray.receivable)
  return receivable_;
}

// -------------------------------------------------------------------

// SellInfo

// optional bytes seller = 1;
inline bool SellInfo::has_seller() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SellInfo::set_has_seller() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SellInfo::clear_has_seller() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SellInfo::clear_seller() {
  seller_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_seller();
}
inline const ::std::string& SellInfo::seller() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.seller)
  return seller_.GetNoArena();
}
inline void SellInfo::set_seller(const ::std::string& value) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.SellInfo.seller)
}
#if LANG_CXX11
inline void SellInfo::set_seller(::std::string&& value) {
  set_has_seller();
  seller_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.SellInfo.seller)
}
#endif
inline void SellInfo::set_seller(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.SellInfo.seller)
}
inline void SellInfo::set_seller(const void* value, size_t size) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.SellInfo.seller)
}
inline ::std::string* SellInfo::mutable_seller() {
  set_has_seller();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.SellInfo.seller)
  return seller_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SellInfo::release_seller() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.SellInfo.seller)
  if (!has_seller()) {
    return NULL;
  }
  clear_has_seller();
  return seller_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SellInfo::set_allocated_seller(::std::string* seller) {
  if (seller != NULL) {
    set_has_seller();
  } else {
    clear_has_seller();
  }
  seller_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), seller);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.SellInfo.seller)
}

// optional bytes buyer = 2;
inline bool SellInfo::has_buyer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SellInfo::set_has_buyer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SellInfo::clear_has_buyer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SellInfo::clear_buyer() {
  buyer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_buyer();
}
inline const ::std::string& SellInfo::buyer() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.buyer)
  return buyer_.GetNoArena();
}
inline void SellInfo::set_buyer(const ::std::string& value) {
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.SellInfo.buyer)
}
#if LANG_CXX11
inline void SellInfo::set_buyer(::std::string&& value) {
  set_has_buyer();
  buyer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.SellInfo.buyer)
}
#endif
inline void SellInfo::set_buyer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.SellInfo.buyer)
}
inline void SellInfo::set_buyer(const void* value, size_t size) {
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.SellInfo.buyer)
}
inline ::std::string* SellInfo::mutable_buyer() {
  set_has_buyer();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.SellInfo.buyer)
  return buyer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SellInfo::release_buyer() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.SellInfo.buyer)
  if (!has_buyer()) {
    return NULL;
  }
  clear_has_buyer();
  return buyer_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SellInfo::set_allocated_buyer(::std::string* buyer) {
  if (buyer != NULL) {
    set_has_buyer();
  } else {
    clear_has_buyer();
  }
  buyer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), buyer);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.SellInfo.buyer)
}

// optional bytes contract = 3;
inline bool SellInfo::has_contract() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SellInfo::set_has_contract() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SellInfo::clear_has_contract() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SellInfo::clear_contract() {
  contract_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_contract();
}
inline const ::std::string& SellInfo::contract() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.contract)
  return contract_.GetNoArena();
}
inline void SellInfo::set_contract(const ::std::string& value) {
  set_has_contract();
  contract_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.SellInfo.contract)
}
#if LANG_CXX11
inline void SellInfo::set_contract(::std::string&& value) {
  set_has_contract();
  contract_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.SellInfo.contract)
}
#endif
inline void SellInfo::set_contract(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_contract();
  contract_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.SellInfo.contract)
}
inline void SellInfo::set_contract(const void* value, size_t size) {
  set_has_contract();
  contract_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.SellInfo.contract)
}
inline ::std::string* SellInfo::mutable_contract() {
  set_has_contract();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.SellInfo.contract)
  return contract_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SellInfo::release_contract() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.SellInfo.contract)
  if (!has_contract()) {
    return NULL;
  }
  clear_has_contract();
  return contract_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SellInfo::set_allocated_contract(::std::string* contract) {
  if (contract != NULL) {
    set_has_contract();
  } else {
    clear_has_contract();
  }
  contract_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contract);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.SellInfo.contract)
}

// optional uint64 amount = 4;
inline bool SellInfo::has_amount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SellInfo::set_has_amount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SellInfo::clear_has_amount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SellInfo::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 SellInfo::amount() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.amount)
  return amount_;
}
inline void SellInfo::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.SellInfo.amount)
}

// optional .zjchain.ws.protobuf.ReceivableArray receivable = 5;
inline bool SellInfo::has_receivable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SellInfo::set_has_receivable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SellInfo::clear_has_receivable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SellInfo::clear_receivable() {
  if (receivable_ != NULL) receivable_->Clear();
  clear_has_receivable();
}
inline const ::zjchain::ws::protobuf::ReceivableArray& SellInfo::_internal_receivable() const {
  return *receivable_;
}
inline const ::zjchain::ws::protobuf::ReceivableArray& SellInfo::receivable() const {
  const ::zjchain::ws::protobuf::ReceivableArray* p = receivable_;
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.receivable)
  return p != NULL ? *p : *reinterpret_cast<const ::zjchain::ws::protobuf::ReceivableArray*>(
      &::zjchain::ws::protobuf::_ReceivableArray_default_instance_);
}
inline ::zjchain::ws::protobuf::ReceivableArray* SellInfo::release_receivable() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.SellInfo.receivable)
  clear_has_receivable();
  ::zjchain::ws::protobuf::ReceivableArray* temp = receivable_;
  receivable_ = NULL;
  return temp;
}
inline ::zjchain::ws::protobuf::ReceivableArray* SellInfo::mutable_receivable() {
  set_has_receivable();
  if (receivable_ == NULL) {
    auto* p = CreateMaybeMessage<::zjchain::ws::protobuf::ReceivableArray>(GetArenaNoVirtual());
    receivable_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.SellInfo.receivable)
  return receivable_;
}
inline void SellInfo::set_allocated_receivable(::zjchain::ws::protobuf::ReceivableArray* receivable) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete receivable_;
  }
  if (receivable) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      receivable = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, receivable, submessage_arena);
    }
    set_has_receivable();
  } else {
    clear_has_receivable();
  }
  receivable_ = receivable;
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.SellInfo.receivable)
}

// optional uint64 all = 6;
inline bool SellInfo::has_all() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SellInfo::set_has_all() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SellInfo::clear_has_all() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SellInfo::clear_all() {
  all_ = GOOGLE_ULONGLONG(0);
  clear_has_all();
}
inline ::google::protobuf::uint64 SellInfo::all() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.all)
  return all_;
}
inline void SellInfo::set_all(::google::protobuf::uint64 value) {
  set_has_all();
  all_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.SellInfo.all)
}

// optional uint64 price = 7;
inline bool SellInfo::has_price() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SellInfo::set_has_price() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SellInfo::clear_has_price() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SellInfo::clear_price() {
  price_ = GOOGLE_ULONGLONG(0);
  clear_has_price();
}
inline ::google::protobuf::uint64 SellInfo::price() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.price)
  return price_;
}
inline void SellInfo::set_price(::google::protobuf::uint64 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.SellInfo.price)
}

// optional uint32 mchecked = 8;
inline bool SellInfo::has_mchecked() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SellInfo::set_has_mchecked() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SellInfo::clear_has_mchecked() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SellInfo::clear_mchecked() {
  mchecked_ = 0u;
  clear_has_mchecked();
}
inline ::google::protobuf::uint32 SellInfo::mchecked() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.mchecked)
  return mchecked_;
}
inline void SellInfo::set_mchecked(::google::protobuf::uint32 value) {
  set_has_mchecked();
  mchecked_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.SellInfo.mchecked)
}

// optional uint32 schecked = 9;
inline bool SellInfo::has_schecked() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SellInfo::set_has_schecked() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SellInfo::clear_has_schecked() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SellInfo::clear_schecked() {
  schecked_ = 0u;
  clear_has_schecked();
}
inline ::google::protobuf::uint32 SellInfo::schecked() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.schecked)
  return schecked_;
}
inline void SellInfo::set_schecked(::google::protobuf::uint32 value) {
  set_has_schecked();
  schecked_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.SellInfo.schecked)
}

// optional uint32 reported = 10;
inline bool SellInfo::has_reported() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SellInfo::set_has_reported() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SellInfo::clear_has_reported() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SellInfo::clear_reported() {
  reported_ = 0u;
  clear_has_reported();
}
inline ::google::protobuf::uint32 SellInfo::reported() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.reported)
  return reported_;
}
inline void SellInfo::set_reported(::google::protobuf::uint32 value) {
  set_has_reported();
  reported_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.SellInfo.reported)
}

// optional uint64 orderId = 11;
inline bool SellInfo::has_orderid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SellInfo::set_has_orderid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SellInfo::clear_has_orderid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SellInfo::clear_orderid() {
  orderid_ = GOOGLE_ULONGLONG(0);
  clear_has_orderid();
}
inline ::google::protobuf::uint64 SellInfo::orderid() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.orderId)
  return orderid_;
}
inline void SellInfo::set_orderid(::google::protobuf::uint64 value) {
  set_has_orderid();
  orderid_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.SellInfo.orderId)
}

// optional uint64 height = 12;
inline bool SellInfo::has_height() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SellInfo::set_has_height() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SellInfo::clear_has_height() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SellInfo::clear_height() {
  height_ = GOOGLE_ULONGLONG(0);
  clear_has_height();
}
inline ::google::protobuf::uint64 SellInfo::height() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.height)
  return height_;
}
inline void SellInfo::set_height(::google::protobuf::uint64 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.SellInfo.height)
}

// optional uint64 timestamp = 13;
inline bool SellInfo::has_timestamp() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SellInfo::set_has_timestamp() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SellInfo::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SellInfo::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 SellInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.timestamp)
  return timestamp_;
}
inline void SellInfo::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.SellInfo.timestamp)
}

// optional bytes username = 14;
inline bool SellInfo::has_username() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SellInfo::set_has_username() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SellInfo::clear_has_username() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SellInfo::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& SellInfo::username() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.username)
  return username_.GetNoArena();
}
inline void SellInfo::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.SellInfo.username)
}
#if LANG_CXX11
inline void SellInfo::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.SellInfo.username)
}
#endif
inline void SellInfo::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.SellInfo.username)
}
inline void SellInfo::set_username(const void* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.SellInfo.username)
}
inline ::std::string* SellInfo::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.SellInfo.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SellInfo::release_username() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.SellInfo.username)
  if (!has_username()) {
    return NULL;
  }
  clear_has_username();
  return username_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SellInfo::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.SellInfo.username)
}

// optional int32 status = 15;
inline bool SellInfo::has_status() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SellInfo::set_has_status() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SellInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SellInfo::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 SellInfo::status() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.status)
  return status_;
}
inline void SellInfo::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.SellInfo.status)
}

// optional uint64 purchase_amount = 16;
inline bool SellInfo::has_purchase_amount() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SellInfo::set_has_purchase_amount() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SellInfo::clear_has_purchase_amount() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SellInfo::clear_purchase_amount() {
  purchase_amount_ = GOOGLE_ULONGLONG(0);
  clear_has_purchase_amount();
}
inline ::google::protobuf::uint64 SellInfo::purchase_amount() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.purchase_amount)
  return purchase_amount_;
}
inline void SellInfo::set_purchase_amount(::google::protobuf::uint64 value) {
  set_has_purchase_amount();
  purchase_amount_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.SellInfo.purchase_amount)
}

// optional uint64 create_timestamp = 17;
inline bool SellInfo::has_create_timestamp() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SellInfo::set_has_create_timestamp() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SellInfo::clear_has_create_timestamp() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SellInfo::clear_create_timestamp() {
  create_timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_create_timestamp();
}
inline ::google::protobuf::uint64 SellInfo::create_timestamp() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.create_timestamp)
  return create_timestamp_;
}
inline void SellInfo::set_create_timestamp(::google::protobuf::uint64 value) {
  set_has_create_timestamp();
  create_timestamp_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.SellInfo.create_timestamp)
}

// optional uint64 min_amount = 18;
inline bool SellInfo::has_min_amount() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SellInfo::set_has_min_amount() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SellInfo::clear_has_min_amount() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SellInfo::clear_min_amount() {
  min_amount_ = GOOGLE_ULONGLONG(0);
  clear_has_min_amount();
}
inline ::google::protobuf::uint64 SellInfo::min_amount() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.min_amount)
  return min_amount_;
}
inline void SellInfo::set_min_amount(::google::protobuf::uint64 value) {
  set_has_min_amount();
  min_amount_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.SellInfo.min_amount)
}

// optional uint64 max_amount = 19;
inline bool SellInfo::has_max_amount() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SellInfo::set_has_max_amount() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SellInfo::clear_has_max_amount() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SellInfo::clear_max_amount() {
  max_amount_ = GOOGLE_ULONGLONG(0);
  clear_has_max_amount();
}
inline ::google::protobuf::uint64 SellInfo::max_amount() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.max_amount)
  return max_amount_;
}
inline void SellInfo::set_max_amount(::google::protobuf::uint64 value) {
  set_has_max_amount();
  max_amount_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.SellInfo.max_amount)
}

// optional uint64 now = 20;
inline bool SellInfo::has_now() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SellInfo::set_has_now() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SellInfo::clear_has_now() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SellInfo::clear_now() {
  now_ = GOOGLE_ULONGLONG(0);
  clear_has_now();
}
inline ::google::protobuf::uint64 SellInfo::now() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.now)
  return now_;
}
inline void SellInfo::set_now(::google::protobuf::uint64 value) {
  set_has_now();
  now_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.SellInfo.now)
}

// optional bool is_order = 21;
inline bool SellInfo::has_is_order() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void SellInfo::set_has_is_order() {
  _has_bits_[0] |= 0x00400000u;
}
inline void SellInfo::clear_has_is_order() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void SellInfo::clear_is_order() {
  is_order_ = false;
  clear_has_is_order();
}
inline bool SellInfo::is_order() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.is_order)
  return is_order_;
}
inline void SellInfo::set_is_order(bool value) {
  set_has_is_order();
  is_order_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.SellInfo.is_order)
}

// optional .zjchain.ws.protobuf.Appeal appeal = 22;
inline bool SellInfo::has_appeal() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SellInfo::set_has_appeal() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SellInfo::clear_has_appeal() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SellInfo::clear_appeal() {
  if (appeal_ != NULL) appeal_->Clear();
  clear_has_appeal();
}
inline const ::zjchain::ws::protobuf::Appeal& SellInfo::_internal_appeal() const {
  return *appeal_;
}
inline const ::zjchain::ws::protobuf::Appeal& SellInfo::appeal() const {
  const ::zjchain::ws::protobuf::Appeal* p = appeal_;
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.appeal)
  return p != NULL ? *p : *reinterpret_cast<const ::zjchain::ws::protobuf::Appeal*>(
      &::zjchain::ws::protobuf::_Appeal_default_instance_);
}
inline ::zjchain::ws::protobuf::Appeal* SellInfo::release_appeal() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.SellInfo.appeal)
  clear_has_appeal();
  ::zjchain::ws::protobuf::Appeal* temp = appeal_;
  appeal_ = NULL;
  return temp;
}
inline ::zjchain::ws::protobuf::Appeal* SellInfo::mutable_appeal() {
  set_has_appeal();
  if (appeal_ == NULL) {
    auto* p = CreateMaybeMessage<::zjchain::ws::protobuf::Appeal>(GetArenaNoVirtual());
    appeal_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.SellInfo.appeal)
  return appeal_;
}
inline void SellInfo::set_allocated_appeal(::zjchain::ws::protobuf::Appeal* appeal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete appeal_;
  }
  if (appeal) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      appeal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, appeal, submessage_arena);
    }
    set_has_appeal();
  } else {
    clear_has_appeal();
  }
  appeal_ = appeal;
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.SellInfo.appeal)
}

// optional int32 credit = 23;
inline bool SellInfo::has_credit() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void SellInfo::set_has_credit() {
  _has_bits_[0] |= 0x00800000u;
}
inline void SellInfo::clear_has_credit() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void SellInfo::clear_credit() {
  credit_ = 0;
  clear_has_credit();
}
inline ::google::protobuf::int32 SellInfo::credit() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.credit)
  return credit_;
}
inline void SellInfo::set_credit(::google::protobuf::int32 value) {
  set_has_credit();
  credit_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.SellInfo.credit)
}

// optional .zjchain.ws.protobuf.Appeal peer_appeal = 24;
inline bool SellInfo::has_peer_appeal() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SellInfo::set_has_peer_appeal() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SellInfo::clear_has_peer_appeal() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SellInfo::clear_peer_appeal() {
  if (peer_appeal_ != NULL) peer_appeal_->Clear();
  clear_has_peer_appeal();
}
inline const ::zjchain::ws::protobuf::Appeal& SellInfo::_internal_peer_appeal() const {
  return *peer_appeal_;
}
inline const ::zjchain::ws::protobuf::Appeal& SellInfo::peer_appeal() const {
  const ::zjchain::ws::protobuf::Appeal* p = peer_appeal_;
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.SellInfo.peer_appeal)
  return p != NULL ? *p : *reinterpret_cast<const ::zjchain::ws::protobuf::Appeal*>(
      &::zjchain::ws::protobuf::_Appeal_default_instance_);
}
inline ::zjchain::ws::protobuf::Appeal* SellInfo::release_peer_appeal() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.SellInfo.peer_appeal)
  clear_has_peer_appeal();
  ::zjchain::ws::protobuf::Appeal* temp = peer_appeal_;
  peer_appeal_ = NULL;
  return temp;
}
inline ::zjchain::ws::protobuf::Appeal* SellInfo::mutable_peer_appeal() {
  set_has_peer_appeal();
  if (peer_appeal_ == NULL) {
    auto* p = CreateMaybeMessage<::zjchain::ws::protobuf::Appeal>(GetArenaNoVirtual());
    peer_appeal_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.SellInfo.peer_appeal)
  return peer_appeal_;
}
inline void SellInfo::set_allocated_peer_appeal(::zjchain::ws::protobuf::Appeal* peer_appeal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete peer_appeal_;
  }
  if (peer_appeal) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      peer_appeal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peer_appeal, submessage_arena);
    }
    set_has_peer_appeal();
  } else {
    clear_has_peer_appeal();
  }
  peer_appeal_ = peer_appeal;
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.SellInfo.peer_appeal)
}

// -------------------------------------------------------------------

// NewOrder

// optional bytes seller = 1;
inline bool NewOrder::has_seller() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewOrder::set_has_seller() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewOrder::clear_has_seller() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewOrder::clear_seller() {
  seller_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_seller();
}
inline const ::std::string& NewOrder::seller() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.NewOrder.seller)
  return seller_.GetNoArena();
}
inline void NewOrder::set_seller(const ::std::string& value) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.NewOrder.seller)
}
#if LANG_CXX11
inline void NewOrder::set_seller(::std::string&& value) {
  set_has_seller();
  seller_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.NewOrder.seller)
}
#endif
inline void NewOrder::set_seller(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.NewOrder.seller)
}
inline void NewOrder::set_seller(const void* value, size_t size) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.NewOrder.seller)
}
inline ::std::string* NewOrder::mutable_seller() {
  set_has_seller();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.NewOrder.seller)
  return seller_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewOrder::release_seller() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.NewOrder.seller)
  if (!has_seller()) {
    return NULL;
  }
  clear_has_seller();
  return seller_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewOrder::set_allocated_seller(::std::string* seller) {
  if (seller != NULL) {
    set_has_seller();
  } else {
    clear_has_seller();
  }
  seller_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), seller);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.NewOrder.seller)
}

// optional uint64 amount = 2;
inline bool NewOrder::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewOrder::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewOrder::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewOrder::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 NewOrder::amount() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.NewOrder.amount)
  return amount_;
}
inline void NewOrder::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.NewOrder.amount)
}

// optional bytes buyer = 3;
inline bool NewOrder::has_buyer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewOrder::set_has_buyer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewOrder::clear_has_buyer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewOrder::clear_buyer() {
  buyer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_buyer();
}
inline const ::std::string& NewOrder::buyer() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.NewOrder.buyer)
  return buyer_.GetNoArena();
}
inline void NewOrder::set_buyer(const ::std::string& value) {
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.NewOrder.buyer)
}
#if LANG_CXX11
inline void NewOrder::set_buyer(::std::string&& value) {
  set_has_buyer();
  buyer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.NewOrder.buyer)
}
#endif
inline void NewOrder::set_buyer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.NewOrder.buyer)
}
inline void NewOrder::set_buyer(const void* value, size_t size) {
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.NewOrder.buyer)
}
inline ::std::string* NewOrder::mutable_buyer() {
  set_has_buyer();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.NewOrder.buyer)
  return buyer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewOrder::release_buyer() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.NewOrder.buyer)
  if (!has_buyer()) {
    return NULL;
  }
  clear_has_buyer();
  return buyer_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewOrder::set_allocated_buyer(::std::string* buyer) {
  if (buyer != NULL) {
    set_has_buyer();
  } else {
    clear_has_buyer();
  }
  buyer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), buyer);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.NewOrder.buyer)
}

// -------------------------------------------------------------------

// Appeal

// optional bytes seller = 1;
inline bool Appeal::has_seller() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Appeal::set_has_seller() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Appeal::clear_has_seller() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Appeal::clear_seller() {
  seller_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_seller();
}
inline const ::std::string& Appeal::seller() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.Appeal.seller)
  return seller_.GetNoArena();
}
inline void Appeal::set_seller(const ::std::string& value) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.Appeal.seller)
}
#if LANG_CXX11
inline void Appeal::set_seller(::std::string&& value) {
  set_has_seller();
  seller_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.Appeal.seller)
}
#endif
inline void Appeal::set_seller(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.Appeal.seller)
}
inline void Appeal::set_seller(const void* value, size_t size) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.Appeal.seller)
}
inline ::std::string* Appeal::mutable_seller() {
  set_has_seller();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.Appeal.seller)
  return seller_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Appeal::release_seller() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.Appeal.seller)
  if (!has_seller()) {
    return NULL;
  }
  clear_has_seller();
  return seller_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Appeal::set_allocated_seller(::std::string* seller) {
  if (seller != NULL) {
    set_has_seller();
  } else {
    clear_has_seller();
  }
  seller_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), seller);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.Appeal.seller)
}

// optional bytes buyer = 2;
inline bool Appeal::has_buyer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Appeal::set_has_buyer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Appeal::clear_has_buyer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Appeal::clear_buyer() {
  buyer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_buyer();
}
inline const ::std::string& Appeal::buyer() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.Appeal.buyer)
  return buyer_.GetNoArena();
}
inline void Appeal::set_buyer(const ::std::string& value) {
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.Appeal.buyer)
}
#if LANG_CXX11
inline void Appeal::set_buyer(::std::string&& value) {
  set_has_buyer();
  buyer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.Appeal.buyer)
}
#endif
inline void Appeal::set_buyer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.Appeal.buyer)
}
inline void Appeal::set_buyer(const void* value, size_t size) {
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.Appeal.buyer)
}
inline ::std::string* Appeal::mutable_buyer() {
  set_has_buyer();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.Appeal.buyer)
  return buyer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Appeal::release_buyer() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.Appeal.buyer)
  if (!has_buyer()) {
    return NULL;
  }
  clear_has_buyer();
  return buyer_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Appeal::set_allocated_buyer(::std::string* buyer) {
  if (buyer != NULL) {
    set_has_buyer();
  } else {
    clear_has_buyer();
  }
  buyer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), buyer);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.Appeal.buyer)
}

// optional int32 type = 3;
inline bool Appeal::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Appeal::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Appeal::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Appeal::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Appeal::type() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.Appeal.type)
  return type_;
}
inline void Appeal::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.Appeal.type)
}

// optional bytes content = 4;
inline bool Appeal::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Appeal::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Appeal::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Appeal::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_content();
}
inline const ::std::string& Appeal::content() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.Appeal.content)
  return content_.GetNoArena();
}
inline void Appeal::set_content(const ::std::string& value) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.Appeal.content)
}
#if LANG_CXX11
inline void Appeal::set_content(::std::string&& value) {
  set_has_content();
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.Appeal.content)
}
#endif
inline void Appeal::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.Appeal.content)
}
inline void Appeal::set_content(const void* value, size_t size) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.Appeal.content)
}
inline ::std::string* Appeal::mutable_content() {
  set_has_content();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.Appeal.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Appeal::release_content() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.Appeal.content)
  if (!has_content()) {
    return NULL;
  }
  clear_has_content();
  return content_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Appeal::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    set_has_content();
  } else {
    clear_has_content();
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.Appeal.content)
}

// optional bytes pic = 5;
inline bool Appeal::has_pic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Appeal::set_has_pic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Appeal::clear_has_pic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Appeal::clear_pic() {
  pic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pic();
}
inline const ::std::string& Appeal::pic() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.Appeal.pic)
  return pic_.GetNoArena();
}
inline void Appeal::set_pic(const ::std::string& value) {
  set_has_pic();
  pic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.Appeal.pic)
}
#if LANG_CXX11
inline void Appeal::set_pic(::std::string&& value) {
  set_has_pic();
  pic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.Appeal.pic)
}
#endif
inline void Appeal::set_pic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pic();
  pic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.Appeal.pic)
}
inline void Appeal::set_pic(const void* value, size_t size) {
  set_has_pic();
  pic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.Appeal.pic)
}
inline ::std::string* Appeal::mutable_pic() {
  set_has_pic();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.Appeal.pic)
  return pic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Appeal::release_pic() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.Appeal.pic)
  if (!has_pic()) {
    return NULL;
  }
  clear_has_pic();
  return pic_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Appeal::set_allocated_pic(::std::string* pic) {
  if (pic != NULL) {
    set_has_pic();
  } else {
    clear_has_pic();
  }
  pic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pic);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.Appeal.pic)
}

// -------------------------------------------------------------------

// NewSell

// optional bytes protocol_addr = 1;
inline bool NewSell::has_protocol_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewSell::set_has_protocol_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewSell::clear_has_protocol_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewSell::clear_protocol_addr() {
  protocol_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_protocol_addr();
}
inline const ::std::string& NewSell::protocol_addr() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.NewSell.protocol_addr)
  return protocol_addr_.GetNoArena();
}
inline void NewSell::set_protocol_addr(const ::std::string& value) {
  set_has_protocol_addr();
  protocol_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.NewSell.protocol_addr)
}
#if LANG_CXX11
inline void NewSell::set_protocol_addr(::std::string&& value) {
  set_has_protocol_addr();
  protocol_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.NewSell.protocol_addr)
}
#endif
inline void NewSell::set_protocol_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_protocol_addr();
  protocol_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.NewSell.protocol_addr)
}
inline void NewSell::set_protocol_addr(const void* value, size_t size) {
  set_has_protocol_addr();
  protocol_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.NewSell.protocol_addr)
}
inline ::std::string* NewSell::mutable_protocol_addr() {
  set_has_protocol_addr();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.NewSell.protocol_addr)
  return protocol_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewSell::release_protocol_addr() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.NewSell.protocol_addr)
  if (!has_protocol_addr()) {
    return NULL;
  }
  clear_has_protocol_addr();
  return protocol_addr_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewSell::set_allocated_protocol_addr(::std::string* protocol_addr) {
  if (protocol_addr != NULL) {
    set_has_protocol_addr();
  } else {
    clear_has_protocol_addr();
  }
  protocol_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol_addr);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.NewSell.protocol_addr)
}

// optional bytes seller = 2;
inline bool NewSell::has_seller() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewSell::set_has_seller() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewSell::clear_has_seller() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewSell::clear_seller() {
  seller_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_seller();
}
inline const ::std::string& NewSell::seller() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.NewSell.seller)
  return seller_.GetNoArena();
}
inline void NewSell::set_seller(const ::std::string& value) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.NewSell.seller)
}
#if LANG_CXX11
inline void NewSell::set_seller(::std::string&& value) {
  set_has_seller();
  seller_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.NewSell.seller)
}
#endif
inline void NewSell::set_seller(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.NewSell.seller)
}
inline void NewSell::set_seller(const void* value, size_t size) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.NewSell.seller)
}
inline ::std::string* NewSell::mutable_seller() {
  set_has_seller();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.NewSell.seller)
  return seller_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewSell::release_seller() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.NewSell.seller)
  if (!has_seller()) {
    return NULL;
  }
  clear_has_seller();
  return seller_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewSell::set_allocated_seller(::std::string* seller) {
  if (seller != NULL) {
    set_has_seller();
  } else {
    clear_has_seller();
  }
  seller_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), seller);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.NewSell.seller)
}

// optional uint64 amount = 3;
inline bool NewSell::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewSell::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewSell::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewSell::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 NewSell::amount() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.NewSell.amount)
  return amount_;
}
inline void NewSell::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.NewSell.amount)
}

// optional uint64 price = 4;
inline bool NewSell::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewSell::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewSell::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewSell::clear_price() {
  price_ = GOOGLE_ULONGLONG(0);
  clear_has_price();
}
inline ::google::protobuf::uint64 NewSell::price() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.NewSell.price)
  return price_;
}
inline void NewSell::set_price(::google::protobuf::uint64 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.NewSell.price)
}

// repeated .zjchain.ws.protobuf.ReceivableInfo receivable = 5;
inline int NewSell::receivable_size() const {
  return receivable_.size();
}
inline void NewSell::clear_receivable() {
  receivable_.Clear();
}
inline ::zjchain::ws::protobuf::ReceivableInfo* NewSell::mutable_receivable(int index) {
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.NewSell.receivable)
  return receivable_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::ReceivableInfo >*
NewSell::mutable_receivable() {
  // @@protoc_insertion_point(field_mutable_list:zjchain.ws.protobuf.NewSell.receivable)
  return &receivable_;
}
inline const ::zjchain::ws::protobuf::ReceivableInfo& NewSell::receivable(int index) const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.NewSell.receivable)
  return receivable_.Get(index);
}
inline ::zjchain::ws::protobuf::ReceivableInfo* NewSell::add_receivable() {
  // @@protoc_insertion_point(field_add:zjchain.ws.protobuf.NewSell.receivable)
  return receivable_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::ReceivableInfo >&
NewSell::receivable() const {
  // @@protoc_insertion_point(field_list:zjchain.ws.protobuf.NewSell.receivable)
  return receivable_;
}

// -------------------------------------------------------------------

// BuyerReport

// optional bytes seller = 1;
inline bool BuyerReport::has_seller() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuyerReport::set_has_seller() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuyerReport::clear_has_seller() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuyerReport::clear_seller() {
  seller_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_seller();
}
inline const ::std::string& BuyerReport::seller() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.BuyerReport.seller)
  return seller_.GetNoArena();
}
inline void BuyerReport::set_seller(const ::std::string& value) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.BuyerReport.seller)
}
#if LANG_CXX11
inline void BuyerReport::set_seller(::std::string&& value) {
  set_has_seller();
  seller_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.BuyerReport.seller)
}
#endif
inline void BuyerReport::set_seller(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.BuyerReport.seller)
}
inline void BuyerReport::set_seller(const void* value, size_t size) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.BuyerReport.seller)
}
inline ::std::string* BuyerReport::mutable_seller() {
  set_has_seller();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.BuyerReport.seller)
  return seller_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuyerReport::release_seller() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.BuyerReport.seller)
  if (!has_seller()) {
    return NULL;
  }
  clear_has_seller();
  return seller_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuyerReport::set_allocated_seller(::std::string* seller) {
  if (seller != NULL) {
    set_has_seller();
  } else {
    clear_has_seller();
  }
  seller_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), seller);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.BuyerReport.seller)
}

// optional bytes reports_info = 2;
inline bool BuyerReport::has_reports_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuyerReport::set_has_reports_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuyerReport::clear_has_reports_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuyerReport::clear_reports_info() {
  reports_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reports_info();
}
inline const ::std::string& BuyerReport::reports_info() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.BuyerReport.reports_info)
  return reports_info_.GetNoArena();
}
inline void BuyerReport::set_reports_info(const ::std::string& value) {
  set_has_reports_info();
  reports_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.BuyerReport.reports_info)
}
#if LANG_CXX11
inline void BuyerReport::set_reports_info(::std::string&& value) {
  set_has_reports_info();
  reports_info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.BuyerReport.reports_info)
}
#endif
inline void BuyerReport::set_reports_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reports_info();
  reports_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.BuyerReport.reports_info)
}
inline void BuyerReport::set_reports_info(const void* value, size_t size) {
  set_has_reports_info();
  reports_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.BuyerReport.reports_info)
}
inline ::std::string* BuyerReport::mutable_reports_info() {
  set_has_reports_info();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.BuyerReport.reports_info)
  return reports_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuyerReport::release_reports_info() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.BuyerReport.reports_info)
  if (!has_reports_info()) {
    return NULL;
  }
  clear_has_reports_info();
  return reports_info_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuyerReport::set_allocated_reports_info(::std::string* reports_info) {
  if (reports_info != NULL) {
    set_has_reports_info();
  } else {
    clear_has_reports_info();
  }
  reports_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reports_info);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.BuyerReport.reports_info)
}

// -------------------------------------------------------------------

// GetSell

// optional bytes seller = 1;
inline bool GetSell::has_seller() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSell::set_has_seller() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSell::clear_has_seller() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSell::clear_seller() {
  seller_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_seller();
}
inline const ::std::string& GetSell::seller() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.GetSell.seller)
  return seller_.GetNoArena();
}
inline void GetSell::set_seller(const ::std::string& value) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.GetSell.seller)
}
#if LANG_CXX11
inline void GetSell::set_seller(::std::string&& value) {
  set_has_seller();
  seller_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.GetSell.seller)
}
#endif
inline void GetSell::set_seller(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.GetSell.seller)
}
inline void GetSell::set_seller(const void* value, size_t size) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.GetSell.seller)
}
inline ::std::string* GetSell::mutable_seller() {
  set_has_seller();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.GetSell.seller)
  return seller_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetSell::release_seller() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.GetSell.seller)
  if (!has_seller()) {
    return NULL;
  }
  clear_has_seller();
  return seller_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetSell::set_allocated_seller(::std::string* seller) {
  if (seller != NULL) {
    set_has_seller();
  } else {
    clear_has_seller();
  }
  seller_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), seller);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.GetSell.seller)
}

// -------------------------------------------------------------------

// C2cMessage

// optional .zjchain.ws.protobuf.NewSell sell = 1;
inline bool C2cMessage::has_sell() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2cMessage::set_has_sell() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2cMessage::clear_has_sell() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2cMessage::clear_sell() {
  if (sell_ != NULL) sell_->Clear();
  clear_has_sell();
}
inline const ::zjchain::ws::protobuf::NewSell& C2cMessage::_internal_sell() const {
  return *sell_;
}
inline const ::zjchain::ws::protobuf::NewSell& C2cMessage::sell() const {
  const ::zjchain::ws::protobuf::NewSell* p = sell_;
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.C2cMessage.sell)
  return p != NULL ? *p : *reinterpret_cast<const ::zjchain::ws::protobuf::NewSell*>(
      &::zjchain::ws::protobuf::_NewSell_default_instance_);
}
inline ::zjchain::ws::protobuf::NewSell* C2cMessage::release_sell() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.C2cMessage.sell)
  clear_has_sell();
  ::zjchain::ws::protobuf::NewSell* temp = sell_;
  sell_ = NULL;
  return temp;
}
inline ::zjchain::ws::protobuf::NewSell* C2cMessage::mutable_sell() {
  set_has_sell();
  if (sell_ == NULL) {
    auto* p = CreateMaybeMessage<::zjchain::ws::protobuf::NewSell>(GetArenaNoVirtual());
    sell_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.C2cMessage.sell)
  return sell_;
}
inline void C2cMessage::set_allocated_sell(::zjchain::ws::protobuf::NewSell* sell) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sell_;
  }
  if (sell) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sell = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sell, submessage_arena);
    }
    set_has_sell();
  } else {
    clear_has_sell();
  }
  sell_ = sell;
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.C2cMessage.sell)
}

// optional .zjchain.ws.protobuf.NewOrder order = 2;
inline bool C2cMessage::has_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void C2cMessage::set_has_order() {
  _has_bits_[0] |= 0x00000004u;
}
inline void C2cMessage::clear_has_order() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void C2cMessage::clear_order() {
  if (order_ != NULL) order_->Clear();
  clear_has_order();
}
inline const ::zjchain::ws::protobuf::NewOrder& C2cMessage::_internal_order() const {
  return *order_;
}
inline const ::zjchain::ws::protobuf::NewOrder& C2cMessage::order() const {
  const ::zjchain::ws::protobuf::NewOrder* p = order_;
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.C2cMessage.order)
  return p != NULL ? *p : *reinterpret_cast<const ::zjchain::ws::protobuf::NewOrder*>(
      &::zjchain::ws::protobuf::_NewOrder_default_instance_);
}
inline ::zjchain::ws::protobuf::NewOrder* C2cMessage::release_order() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.C2cMessage.order)
  clear_has_order();
  ::zjchain::ws::protobuf::NewOrder* temp = order_;
  order_ = NULL;
  return temp;
}
inline ::zjchain::ws::protobuf::NewOrder* C2cMessage::mutable_order() {
  set_has_order();
  if (order_ == NULL) {
    auto* p = CreateMaybeMessage<::zjchain::ws::protobuf::NewOrder>(GetArenaNoVirtual());
    order_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.C2cMessage.order)
  return order_;
}
inline void C2cMessage::set_allocated_order(::zjchain::ws::protobuf::NewOrder* order) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete order_;
  }
  if (order) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      order = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    set_has_order();
  } else {
    clear_has_order();
  }
  order_ = order;
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.C2cMessage.order)
}

// optional .zjchain.ws.protobuf.BuyerReport report = 3;
inline bool C2cMessage::has_report() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void C2cMessage::set_has_report() {
  _has_bits_[0] |= 0x00000008u;
}
inline void C2cMessage::clear_has_report() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void C2cMessage::clear_report() {
  if (report_ != NULL) report_->Clear();
  clear_has_report();
}
inline const ::zjchain::ws::protobuf::BuyerReport& C2cMessage::_internal_report() const {
  return *report_;
}
inline const ::zjchain::ws::protobuf::BuyerReport& C2cMessage::report() const {
  const ::zjchain::ws::protobuf::BuyerReport* p = report_;
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.C2cMessage.report)
  return p != NULL ? *p : *reinterpret_cast<const ::zjchain::ws::protobuf::BuyerReport*>(
      &::zjchain::ws::protobuf::_BuyerReport_default_instance_);
}
inline ::zjchain::ws::protobuf::BuyerReport* C2cMessage::release_report() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.C2cMessage.report)
  clear_has_report();
  ::zjchain::ws::protobuf::BuyerReport* temp = report_;
  report_ = NULL;
  return temp;
}
inline ::zjchain::ws::protobuf::BuyerReport* C2cMessage::mutable_report() {
  set_has_report();
  if (report_ == NULL) {
    auto* p = CreateMaybeMessage<::zjchain::ws::protobuf::BuyerReport>(GetArenaNoVirtual());
    report_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.C2cMessage.report)
  return report_;
}
inline void C2cMessage::set_allocated_report(::zjchain::ws::protobuf::BuyerReport* report) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete report_;
  }
  if (report) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      report = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, report, submessage_arena);
    }
    set_has_report();
  } else {
    clear_has_report();
  }
  report_ = report;
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.C2cMessage.report)
}

// repeated .zjchain.ws.protobuf.SellInfo sells = 4;
inline int C2cMessage::sells_size() const {
  return sells_.size();
}
inline void C2cMessage::clear_sells() {
  sells_.Clear();
}
inline ::zjchain::ws::protobuf::SellInfo* C2cMessage::mutable_sells(int index) {
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.C2cMessage.sells)
  return sells_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::SellInfo >*
C2cMessage::mutable_sells() {
  // @@protoc_insertion_point(field_mutable_list:zjchain.ws.protobuf.C2cMessage.sells)
  return &sells_;
}
inline const ::zjchain::ws::protobuf::SellInfo& C2cMessage::sells(int index) const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.C2cMessage.sells)
  return sells_.Get(index);
}
inline ::zjchain::ws::protobuf::SellInfo* C2cMessage::add_sells() {
  // @@protoc_insertion_point(field_add:zjchain.ws.protobuf.C2cMessage.sells)
  return sells_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::SellInfo >&
C2cMessage::sells() const {
  // @@protoc_insertion_point(field_list:zjchain.ws.protobuf.C2cMessage.sells)
  return sells_;
}

// optional .zjchain.ws.protobuf.GetSell get_sell = 5;
inline bool C2cMessage::has_get_sell() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void C2cMessage::set_has_get_sell() {
  _has_bits_[0] |= 0x00000010u;
}
inline void C2cMessage::clear_has_get_sell() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void C2cMessage::clear_get_sell() {
  if (get_sell_ != NULL) get_sell_->Clear();
  clear_has_get_sell();
}
inline const ::zjchain::ws::protobuf::GetSell& C2cMessage::_internal_get_sell() const {
  return *get_sell_;
}
inline const ::zjchain::ws::protobuf::GetSell& C2cMessage::get_sell() const {
  const ::zjchain::ws::protobuf::GetSell* p = get_sell_;
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.C2cMessage.get_sell)
  return p != NULL ? *p : *reinterpret_cast<const ::zjchain::ws::protobuf::GetSell*>(
      &::zjchain::ws::protobuf::_GetSell_default_instance_);
}
inline ::zjchain::ws::protobuf::GetSell* C2cMessage::release_get_sell() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.C2cMessage.get_sell)
  clear_has_get_sell();
  ::zjchain::ws::protobuf::GetSell* temp = get_sell_;
  get_sell_ = NULL;
  return temp;
}
inline ::zjchain::ws::protobuf::GetSell* C2cMessage::mutable_get_sell() {
  set_has_get_sell();
  if (get_sell_ == NULL) {
    auto* p = CreateMaybeMessage<::zjchain::ws::protobuf::GetSell>(GetArenaNoVirtual());
    get_sell_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.C2cMessage.get_sell)
  return get_sell_;
}
inline void C2cMessage::set_allocated_get_sell(::zjchain::ws::protobuf::GetSell* get_sell) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_sell_;
  }
  if (get_sell) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      get_sell = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_sell, submessage_arena);
    }
    set_has_get_sell();
  } else {
    clear_has_get_sell();
  }
  get_sell_ = get_sell;
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.C2cMessage.get_sell)
}

// optional uint64 prepayment = 6;
inline bool C2cMessage::has_prepayment() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void C2cMessage::set_has_prepayment() {
  _has_bits_[0] |= 0x00000080u;
}
inline void C2cMessage::clear_has_prepayment() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void C2cMessage::clear_prepayment() {
  prepayment_ = GOOGLE_ULONGLONG(0);
  clear_has_prepayment();
}
inline ::google::protobuf::uint64 C2cMessage::prepayment() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.C2cMessage.prepayment)
  return prepayment_;
}
inline void C2cMessage::set_prepayment(::google::protobuf::uint64 value) {
  set_has_prepayment();
  prepayment_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.C2cMessage.prepayment)
}

// optional bytes c2c_addr = 7;
inline bool C2cMessage::has_c2c_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2cMessage::set_has_c2c_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2cMessage::clear_has_c2c_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2cMessage::clear_c2c_addr() {
  c2c_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_c2c_addr();
}
inline const ::std::string& C2cMessage::c2c_addr() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.C2cMessage.c2c_addr)
  return c2c_addr_.GetNoArena();
}
inline void C2cMessage::set_c2c_addr(const ::std::string& value) {
  set_has_c2c_addr();
  c2c_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.C2cMessage.c2c_addr)
}
#if LANG_CXX11
inline void C2cMessage::set_c2c_addr(::std::string&& value) {
  set_has_c2c_addr();
  c2c_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.C2cMessage.c2c_addr)
}
#endif
inline void C2cMessage::set_c2c_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_c2c_addr();
  c2c_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.C2cMessage.c2c_addr)
}
inline void C2cMessage::set_c2c_addr(const void* value, size_t size) {
  set_has_c2c_addr();
  c2c_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.C2cMessage.c2c_addr)
}
inline ::std::string* C2cMessage::mutable_c2c_addr() {
  set_has_c2c_addr();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.C2cMessage.c2c_addr)
  return c2c_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* C2cMessage::release_c2c_addr() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.C2cMessage.c2c_addr)
  if (!has_c2c_addr()) {
    return NULL;
  }
  clear_has_c2c_addr();
  return c2c_addr_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void C2cMessage::set_allocated_c2c_addr(::std::string* c2c_addr) {
  if (c2c_addr != NULL) {
    set_has_c2c_addr();
  } else {
    clear_has_c2c_addr();
  }
  c2c_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), c2c_addr);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.C2cMessage.c2c_addr)
}

// optional .zjchain.ws.protobuf.SellInfo user_order_info = 8;
inline bool C2cMessage::has_user_order_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void C2cMessage::set_has_user_order_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void C2cMessage::clear_has_user_order_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void C2cMessage::clear_user_order_info() {
  if (user_order_info_ != NULL) user_order_info_->Clear();
  clear_has_user_order_info();
}
inline const ::zjchain::ws::protobuf::SellInfo& C2cMessage::_internal_user_order_info() const {
  return *user_order_info_;
}
inline const ::zjchain::ws::protobuf::SellInfo& C2cMessage::user_order_info() const {
  const ::zjchain::ws::protobuf::SellInfo* p = user_order_info_;
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.C2cMessage.user_order_info)
  return p != NULL ? *p : *reinterpret_cast<const ::zjchain::ws::protobuf::SellInfo*>(
      &::zjchain::ws::protobuf::_SellInfo_default_instance_);
}
inline ::zjchain::ws::protobuf::SellInfo* C2cMessage::release_user_order_info() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.C2cMessage.user_order_info)
  clear_has_user_order_info();
  ::zjchain::ws::protobuf::SellInfo* temp = user_order_info_;
  user_order_info_ = NULL;
  return temp;
}
inline ::zjchain::ws::protobuf::SellInfo* C2cMessage::mutable_user_order_info() {
  set_has_user_order_info();
  if (user_order_info_ == NULL) {
    auto* p = CreateMaybeMessage<::zjchain::ws::protobuf::SellInfo>(GetArenaNoVirtual());
    user_order_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.C2cMessage.user_order_info)
  return user_order_info_;
}
inline void C2cMessage::set_allocated_user_order_info(::zjchain::ws::protobuf::SellInfo* user_order_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_order_info_;
  }
  if (user_order_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_order_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_order_info, submessage_arena);
    }
    set_has_user_order_info();
  } else {
    clear_has_user_order_info();
  }
  user_order_info_ = user_order_info;
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.C2cMessage.user_order_info)
}

// optional .zjchain.ws.protobuf.Appeal appeal = 9;
inline bool C2cMessage::has_appeal() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void C2cMessage::set_has_appeal() {
  _has_bits_[0] |= 0x00000040u;
}
inline void C2cMessage::clear_has_appeal() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void C2cMessage::clear_appeal() {
  if (appeal_ != NULL) appeal_->Clear();
  clear_has_appeal();
}
inline const ::zjchain::ws::protobuf::Appeal& C2cMessage::_internal_appeal() const {
  return *appeal_;
}
inline const ::zjchain::ws::protobuf::Appeal& C2cMessage::appeal() const {
  const ::zjchain::ws::protobuf::Appeal* p = appeal_;
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.C2cMessage.appeal)
  return p != NULL ? *p : *reinterpret_cast<const ::zjchain::ws::protobuf::Appeal*>(
      &::zjchain::ws::protobuf::_Appeal_default_instance_);
}
inline ::zjchain::ws::protobuf::Appeal* C2cMessage::release_appeal() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.C2cMessage.appeal)
  clear_has_appeal();
  ::zjchain::ws::protobuf::Appeal* temp = appeal_;
  appeal_ = NULL;
  return temp;
}
inline ::zjchain::ws::protobuf::Appeal* C2cMessage::mutable_appeal() {
  set_has_appeal();
  if (appeal_ == NULL) {
    auto* p = CreateMaybeMessage<::zjchain::ws::protobuf::Appeal>(GetArenaNoVirtual());
    appeal_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.C2cMessage.appeal)
  return appeal_;
}
inline void C2cMessage::set_allocated_appeal(::zjchain::ws::protobuf::Appeal* appeal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete appeal_;
  }
  if (appeal) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      appeal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, appeal, submessage_arena);
    }
    set_has_appeal();
  } else {
    clear_has_appeal();
  }
  appeal_ = appeal;
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.C2cMessage.appeal)
}

// -------------------------------------------------------------------

// StatusInfo

// optional int32 status = 1;
inline bool StatusInfo::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StatusInfo::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StatusInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StatusInfo::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 StatusInfo::status() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.StatusInfo.status)
  return status_;
}
inline void StatusInfo::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.StatusInfo.status)
}

// optional bytes message = 2;
inline bool StatusInfo::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatusInfo::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatusInfo::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatusInfo::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& StatusInfo::message() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.StatusInfo.message)
  return message_.GetNoArena();
}
inline void StatusInfo::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.StatusInfo.message)
}
#if LANG_CXX11
inline void StatusInfo::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.StatusInfo.message)
}
#endif
inline void StatusInfo::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.StatusInfo.message)
}
inline void StatusInfo::set_message(const void* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.StatusInfo.message)
}
inline ::std::string* StatusInfo::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.StatusInfo.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusInfo::release_message() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.StatusInfo.message)
  if (!has_message()) {
    return NULL;
  }
  clear_has_message();
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusInfo::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.StatusInfo.message)
}

// optional uint64 msg_id = 3;
inline bool StatusInfo::has_msg_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatusInfo::set_has_msg_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatusInfo::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatusInfo::clear_msg_id() {
  msg_id_ = GOOGLE_ULONGLONG(0);
  clear_has_msg_id();
}
inline ::google::protobuf::uint64 StatusInfo::msg_id() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.StatusInfo.msg_id)
  return msg_id_;
}
inline void StatusInfo::set_msg_id(::google::protobuf::uint64 value) {
  set_has_msg_id();
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.StatusInfo.msg_id)
}

// -------------------------------------------------------------------

// InitInfo

// optional bytes pubkey = 1;
inline bool InitInfo::has_pubkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitInfo::set_has_pubkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitInfo::clear_has_pubkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitInfo::clear_pubkey() {
  pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pubkey();
}
inline const ::std::string& InitInfo::pubkey() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.InitInfo.pubkey)
  return pubkey_.GetNoArena();
}
inline void InitInfo::set_pubkey(const ::std::string& value) {
  set_has_pubkey();
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.InitInfo.pubkey)
}
#if LANG_CXX11
inline void InitInfo::set_pubkey(::std::string&& value) {
  set_has_pubkey();
  pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.InitInfo.pubkey)
}
#endif
inline void InitInfo::set_pubkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pubkey();
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.InitInfo.pubkey)
}
inline void InitInfo::set_pubkey(const void* value, size_t size) {
  set_has_pubkey();
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.InitInfo.pubkey)
}
inline ::std::string* InitInfo::mutable_pubkey() {
  set_has_pubkey();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.InitInfo.pubkey)
  return pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitInfo::release_pubkey() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.InitInfo.pubkey)
  if (!has_pubkey()) {
    return NULL;
  }
  clear_has_pubkey();
  return pubkey_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitInfo::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey != NULL) {
    set_has_pubkey();
  } else {
    clear_has_pubkey();
  }
  pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pubkey);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.InitInfo.pubkey)
}

// optional bytes platform = 2;
inline bool InitInfo::has_platform() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitInfo::set_has_platform() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitInfo::clear_has_platform() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitInfo::clear_platform() {
  platform_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_platform();
}
inline const ::std::string& InitInfo::platform() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.InitInfo.platform)
  return platform_.GetNoArena();
}
inline void InitInfo::set_platform(const ::std::string& value) {
  set_has_platform();
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.InitInfo.platform)
}
#if LANG_CXX11
inline void InitInfo::set_platform(::std::string&& value) {
  set_has_platform();
  platform_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.InitInfo.platform)
}
#endif
inline void InitInfo::set_platform(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_platform();
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.InitInfo.platform)
}
inline void InitInfo::set_platform(const void* value, size_t size) {
  set_has_platform();
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.InitInfo.platform)
}
inline ::std::string* InitInfo::mutable_platform() {
  set_has_platform();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.InitInfo.platform)
  return platform_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitInfo::release_platform() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.InitInfo.platform)
  if (!has_platform()) {
    return NULL;
  }
  clear_has_platform();
  return platform_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitInfo::set_allocated_platform(::std::string* platform) {
  if (platform != NULL) {
    set_has_platform();
  } else {
    clear_has_platform();
  }
  platform_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), platform);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.InitInfo.platform)
}

// optional bytes version = 3;
inline bool InitInfo::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InitInfo::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InitInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InitInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& InitInfo::version() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.InitInfo.version)
  return version_.GetNoArena();
}
inline void InitInfo::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.InitInfo.version)
}
#if LANG_CXX11
inline void InitInfo::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.InitInfo.version)
}
#endif
inline void InitInfo::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.InitInfo.version)
}
inline void InitInfo::set_version(const void* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.InitInfo.version)
}
inline ::std::string* InitInfo::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.InitInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitInfo::release_version() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.InitInfo.version)
  if (!has_version()) {
    return NULL;
  }
  clear_has_version();
  return version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.InitInfo.version)
}

// optional bytes pk_hash = 4;
inline bool InitInfo::has_pk_hash() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InitInfo::set_has_pk_hash() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InitInfo::clear_has_pk_hash() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InitInfo::clear_pk_hash() {
  pk_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pk_hash();
}
inline const ::std::string& InitInfo::pk_hash() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.InitInfo.pk_hash)
  return pk_hash_.GetNoArena();
}
inline void InitInfo::set_pk_hash(const ::std::string& value) {
  set_has_pk_hash();
  pk_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.InitInfo.pk_hash)
}
#if LANG_CXX11
inline void InitInfo::set_pk_hash(::std::string&& value) {
  set_has_pk_hash();
  pk_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.InitInfo.pk_hash)
}
#endif
inline void InitInfo::set_pk_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pk_hash();
  pk_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.InitInfo.pk_hash)
}
inline void InitInfo::set_pk_hash(const void* value, size_t size) {
  set_has_pk_hash();
  pk_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.InitInfo.pk_hash)
}
inline ::std::string* InitInfo::mutable_pk_hash() {
  set_has_pk_hash();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.InitInfo.pk_hash)
  return pk_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitInfo::release_pk_hash() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.InitInfo.pk_hash)
  if (!has_pk_hash()) {
    return NULL;
  }
  clear_has_pk_hash();
  return pk_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitInfo::set_allocated_pk_hash(::std::string* pk_hash) {
  if (pk_hash != NULL) {
    set_has_pk_hash();
  } else {
    clear_has_pk_hash();
  }
  pk_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pk_hash);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.InitInfo.pk_hash)
}

// optional .zjchain.ws.protobuf.InitInfoTagType tag = 5;
inline bool InitInfo::has_tag() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void InitInfo::set_has_tag() {
  _has_bits_[0] |= 0x00000200u;
}
inline void InitInfo::clear_has_tag() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void InitInfo::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::zjchain::ws::protobuf::InitInfoTagType InitInfo::tag() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.InitInfo.tag)
  return static_cast< ::zjchain::ws::protobuf::InitInfoTagType >(tag_);
}
inline void InitInfo::set_tag(::zjchain::ws::protobuf::InitInfoTagType value) {
  assert(::zjchain::ws::protobuf::InitInfoTagType_IsValid(value));
  set_has_tag();
  tag_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.InitInfo.tag)
}

// optional .zjchain.ws.protobuf.TxMessage tx = 6;
inline bool InitInfo::has_tx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InitInfo::set_has_tx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InitInfo::clear_has_tx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InitInfo::clear_tx() {
  if (tx_ != NULL) tx_->Clear();
  clear_has_tx();
}
inline const ::zjchain::ws::protobuf::TxMessage& InitInfo::_internal_tx() const {
  return *tx_;
}
inline const ::zjchain::ws::protobuf::TxMessage& InitInfo::tx() const {
  const ::zjchain::ws::protobuf::TxMessage* p = tx_;
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.InitInfo.tx)
  return p != NULL ? *p : *reinterpret_cast<const ::zjchain::ws::protobuf::TxMessage*>(
      &::zjchain::ws::protobuf::_TxMessage_default_instance_);
}
inline ::zjchain::ws::protobuf::TxMessage* InitInfo::release_tx() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.InitInfo.tx)
  clear_has_tx();
  ::zjchain::ws::protobuf::TxMessage* temp = tx_;
  tx_ = NULL;
  return temp;
}
inline ::zjchain::ws::protobuf::TxMessage* InitInfo::mutable_tx() {
  set_has_tx();
  if (tx_ == NULL) {
    auto* p = CreateMaybeMessage<::zjchain::ws::protobuf::TxMessage>(GetArenaNoVirtual());
    tx_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.InitInfo.tx)
  return tx_;
}
inline void InitInfo::set_allocated_tx(::zjchain::ws::protobuf::TxMessage* tx) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tx_;
  }
  if (tx) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tx = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tx, submessage_arena);
    }
    set_has_tx();
  } else {
    clear_has_tx();
  }
  tx_ = tx;
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.InitInfo.tx)
}

// optional uint64 tx_height = 7;
inline bool InitInfo::has_tx_height() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InitInfo::set_has_tx_height() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InitInfo::clear_has_tx_height() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InitInfo::clear_tx_height() {
  tx_height_ = GOOGLE_ULONGLONG(0);
  clear_has_tx_height();
}
inline ::google::protobuf::uint64 InitInfo::tx_height() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.InitInfo.tx_height)
  return tx_height_;
}
inline void InitInfo::set_tx_height(::google::protobuf::uint64 value) {
  set_has_tx_height();
  tx_height_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.InitInfo.tx_height)
}

// optional .zjchain.ws.protobuf.C2cMessage c2c = 8;
inline bool InitInfo::has_c2c() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InitInfo::set_has_c2c() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InitInfo::clear_has_c2c() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InitInfo::clear_c2c() {
  if (c2c_ != NULL) c2c_->Clear();
  clear_has_c2c();
}
inline const ::zjchain::ws::protobuf::C2cMessage& InitInfo::_internal_c2c() const {
  return *c2c_;
}
inline const ::zjchain::ws::protobuf::C2cMessage& InitInfo::c2c() const {
  const ::zjchain::ws::protobuf::C2cMessage* p = c2c_;
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.InitInfo.c2c)
  return p != NULL ? *p : *reinterpret_cast<const ::zjchain::ws::protobuf::C2cMessage*>(
      &::zjchain::ws::protobuf::_C2cMessage_default_instance_);
}
inline ::zjchain::ws::protobuf::C2cMessage* InitInfo::release_c2c() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.InitInfo.c2c)
  clear_has_c2c();
  ::zjchain::ws::protobuf::C2cMessage* temp = c2c_;
  c2c_ = NULL;
  return temp;
}
inline ::zjchain::ws::protobuf::C2cMessage* InitInfo::mutable_c2c() {
  set_has_c2c();
  if (c2c_ == NULL) {
    auto* p = CreateMaybeMessage<::zjchain::ws::protobuf::C2cMessage>(GetArenaNoVirtual());
    c2c_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.InitInfo.c2c)
  return c2c_;
}
inline void InitInfo::set_allocated_c2c(::zjchain::ws::protobuf::C2cMessage* c2c) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete c2c_;
  }
  if (c2c) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      c2c = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, c2c, submessage_arena);
    }
    set_has_c2c();
  } else {
    clear_has_c2c();
  }
  c2c_ = c2c;
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.InitInfo.c2c)
}

// optional .zjchain.ws.protobuf.StatusInfo status = 9;
inline bool InitInfo::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InitInfo::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InitInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InitInfo::clear_status() {
  if (status_ != NULL) status_->Clear();
  clear_has_status();
}
inline const ::zjchain::ws::protobuf::StatusInfo& InitInfo::_internal_status() const {
  return *status_;
}
inline const ::zjchain::ws::protobuf::StatusInfo& InitInfo::status() const {
  const ::zjchain::ws::protobuf::StatusInfo* p = status_;
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.InitInfo.status)
  return p != NULL ? *p : *reinterpret_cast<const ::zjchain::ws::protobuf::StatusInfo*>(
      &::zjchain::ws::protobuf::_StatusInfo_default_instance_);
}
inline ::zjchain::ws::protobuf::StatusInfo* InitInfo::release_status() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.InitInfo.status)
  clear_has_status();
  ::zjchain::ws::protobuf::StatusInfo* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::zjchain::ws::protobuf::StatusInfo* InitInfo::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::zjchain::ws::protobuf::StatusInfo>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.InitInfo.status)
  return status_;
}
inline void InitInfo::set_allocated_status(::zjchain::ws::protobuf::StatusInfo* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete status_;
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    set_has_status();
  } else {
    clear_has_status();
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.InitInfo.status)
}

// optional uint64 msg_id = 10;
inline bool InitInfo::has_msg_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InitInfo::set_has_msg_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InitInfo::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InitInfo::clear_msg_id() {
  msg_id_ = GOOGLE_ULONGLONG(0);
  clear_has_msg_id();
}
inline ::google::protobuf::uint64 InitInfo::msg_id() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.InitInfo.msg_id)
  return msg_id_;
}
inline void InitInfo::set_msg_id(::google::protobuf::uint64 value) {
  set_has_msg_id();
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.InitInfo.msg_id)
}

// -------------------------------------------------------------------

// WsTxItem

// optional bytes from = 1;
inline bool WsTxItem::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WsTxItem::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WsTxItem::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WsTxItem::clear_from() {
  from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_from();
}
inline const ::std::string& WsTxItem::from() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.WsTxItem.from)
  return from_.GetNoArena();
}
inline void WsTxItem::set_from(const ::std::string& value) {
  set_has_from();
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.WsTxItem.from)
}
#if LANG_CXX11
inline void WsTxItem::set_from(::std::string&& value) {
  set_has_from();
  from_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.WsTxItem.from)
}
#endif
inline void WsTxItem::set_from(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_from();
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.WsTxItem.from)
}
inline void WsTxItem::set_from(const void* value, size_t size) {
  set_has_from();
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.WsTxItem.from)
}
inline ::std::string* WsTxItem::mutable_from() {
  set_has_from();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.WsTxItem.from)
  return from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WsTxItem::release_from() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.WsTxItem.from)
  if (!has_from()) {
    return NULL;
  }
  clear_has_from();
  return from_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WsTxItem::set_allocated_from(::std::string* from) {
  if (from != NULL) {
    set_has_from();
  } else {
    clear_has_from();
  }
  from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.WsTxItem.from)
}

// optional bytes to = 2;
inline bool WsTxItem::has_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WsTxItem::set_has_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WsTxItem::clear_has_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WsTxItem::clear_to() {
  to_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_to();
}
inline const ::std::string& WsTxItem::to() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.WsTxItem.to)
  return to_.GetNoArena();
}
inline void WsTxItem::set_to(const ::std::string& value) {
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.WsTxItem.to)
}
#if LANG_CXX11
inline void WsTxItem::set_to(::std::string&& value) {
  set_has_to();
  to_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.WsTxItem.to)
}
#endif
inline void WsTxItem::set_to(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.WsTxItem.to)
}
inline void WsTxItem::set_to(const void* value, size_t size) {
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.WsTxItem.to)
}
inline ::std::string* WsTxItem::mutable_to() {
  set_has_to();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.WsTxItem.to)
  return to_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WsTxItem::release_to() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.WsTxItem.to)
  if (!has_to()) {
    return NULL;
  }
  clear_has_to();
  return to_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WsTxItem::set_allocated_to(::std::string* to) {
  if (to != NULL) {
    set_has_to();
  } else {
    clear_has_to();
  }
  to_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.WsTxItem.to)
}

// optional uint64 amount = 3;
inline bool WsTxItem::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WsTxItem::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WsTxItem::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WsTxItem::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 WsTxItem::amount() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.WsTxItem.amount)
  return amount_;
}
inline void WsTxItem::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.WsTxItem.amount)
}

// optional uint64 balance = 4;
inline bool WsTxItem::has_balance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WsTxItem::set_has_balance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WsTxItem::clear_has_balance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WsTxItem::clear_balance() {
  balance_ = GOOGLE_ULONGLONG(0);
  clear_has_balance();
}
inline ::google::protobuf::uint64 WsTxItem::balance() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.WsTxItem.balance)
  return balance_;
}
inline void WsTxItem::set_balance(::google::protobuf::uint64 value) {
  set_has_balance();
  balance_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.WsTxItem.balance)
}

// optional uint64 height = 5;
inline bool WsTxItem::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WsTxItem::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WsTxItem::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WsTxItem::clear_height() {
  height_ = GOOGLE_ULONGLONG(0);
  clear_has_height();
}
inline ::google::protobuf::uint64 WsTxItem::height() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.WsTxItem.height)
  return height_;
}
inline void WsTxItem::set_height(::google::protobuf::uint64 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.WsTxItem.height)
}

// optional uint32 to_add = 6;
inline bool WsTxItem::has_to_add() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WsTxItem::set_has_to_add() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WsTxItem::clear_has_to_add() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WsTxItem::clear_to_add() {
  to_add_ = 0u;
  clear_has_to_add();
}
inline ::google::protobuf::uint32 WsTxItem::to_add() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.WsTxItem.to_add)
  return to_add_;
}
inline void WsTxItem::set_to_add(::google::protobuf::uint32 value) {
  set_has_to_add();
  to_add_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.WsTxItem.to_add)
}

// optional uint64 timestamp = 7;
inline bool WsTxItem::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WsTxItem::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WsTxItem::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WsTxItem::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 WsTxItem::timestamp() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.WsTxItem.timestamp)
  return timestamp_;
}
inline void WsTxItem::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.WsTxItem.timestamp)
}

// optional int32 status = 8;
inline bool WsTxItem::has_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void WsTxItem::set_has_status() {
  _has_bits_[0] |= 0x00000080u;
}
inline void WsTxItem::clear_has_status() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void WsTxItem::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 WsTxItem::status() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.WsTxItem.status)
  return status_;
}
inline void WsTxItem::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.WsTxItem.status)
}

// -------------------------------------------------------------------

// WsTxItemResponse

// repeated .zjchain.ws.protobuf.WsTxItem txs = 1;
inline int WsTxItemResponse::txs_size() const {
  return txs_.size();
}
inline void WsTxItemResponse::clear_txs() {
  txs_.Clear();
}
inline ::zjchain::ws::protobuf::WsTxItem* WsTxItemResponse::mutable_txs(int index) {
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.WsTxItemResponse.txs)
  return txs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::WsTxItem >*
WsTxItemResponse::mutable_txs() {
  // @@protoc_insertion_point(field_mutable_list:zjchain.ws.protobuf.WsTxItemResponse.txs)
  return &txs_;
}
inline const ::zjchain::ws::protobuf::WsTxItem& WsTxItemResponse::txs(int index) const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.WsTxItemResponse.txs)
  return txs_.Get(index);
}
inline ::zjchain::ws::protobuf::WsTxItem* WsTxItemResponse::add_txs() {
  // @@protoc_insertion_point(field_add:zjchain.ws.protobuf.WsTxItemResponse.txs)
  return txs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::WsTxItem >&
WsTxItemResponse::txs() const {
  // @@protoc_insertion_point(field_list:zjchain.ws.protobuf.WsTxItemResponse.txs)
  return txs_;
}

// -------------------------------------------------------------------

// BandwidthItem

// optional bytes id = 1;
inline bool BandwidthItem::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BandwidthItem::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BandwidthItem::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BandwidthItem::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& BandwidthItem::id() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.BandwidthItem.id)
  return id_.GetNoArena();
}
inline void BandwidthItem::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.BandwidthItem.id)
}
#if LANG_CXX11
inline void BandwidthItem::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.ws.protobuf.BandwidthItem.id)
}
#endif
inline void BandwidthItem::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.ws.protobuf.BandwidthItem.id)
}
inline void BandwidthItem::set_id(const void* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.ws.protobuf.BandwidthItem.id)
}
inline ::std::string* BandwidthItem::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.BandwidthItem.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BandwidthItem::release_id() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.BandwidthItem.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BandwidthItem::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.BandwidthItem.id)
}

// optional uint64 bandwidth = 2;
inline bool BandwidthItem::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BandwidthItem::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BandwidthItem::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BandwidthItem::clear_bandwidth() {
  bandwidth_ = GOOGLE_ULONGLONG(0);
  clear_has_bandwidth();
}
inline ::google::protobuf::uint64 BandwidthItem::bandwidth() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.BandwidthItem.bandwidth)
  return bandwidth_;
}
inline void BandwidthItem::set_bandwidth(::google::protobuf::uint64 value) {
  set_has_bandwidth();
  bandwidth_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.BandwidthItem.bandwidth)
}

// optional uint64 timestamp = 3;
inline bool BandwidthItem::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BandwidthItem::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BandwidthItem::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BandwidthItem::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 BandwidthItem::timestamp() const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.BandwidthItem.timestamp)
  return timestamp_;
}
inline void BandwidthItem::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:zjchain.ws.protobuf.BandwidthItem.timestamp)
}

// -------------------------------------------------------------------

// BandwidthInfo

// repeated .zjchain.ws.protobuf.BandwidthItem bws = 1;
inline int BandwidthInfo::bws_size() const {
  return bws_.size();
}
inline void BandwidthInfo::clear_bws() {
  bws_.Clear();
}
inline ::zjchain::ws::protobuf::BandwidthItem* BandwidthInfo::mutable_bws(int index) {
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.BandwidthInfo.bws)
  return bws_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::BandwidthItem >*
BandwidthInfo::mutable_bws() {
  // @@protoc_insertion_point(field_mutable_list:zjchain.ws.protobuf.BandwidthInfo.bws)
  return &bws_;
}
inline const ::zjchain::ws::protobuf::BandwidthItem& BandwidthInfo::bws(int index) const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.BandwidthInfo.bws)
  return bws_.Get(index);
}
inline ::zjchain::ws::protobuf::BandwidthItem* BandwidthInfo::add_bws() {
  // @@protoc_insertion_point(field_add:zjchain.ws.protobuf.BandwidthInfo.bws)
  return bws_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::BandwidthItem >&
BandwidthInfo::bws() const {
  // @@protoc_insertion_point(field_list:zjchain.ws.protobuf.BandwidthInfo.bws)
  return bws_;
}

// -------------------------------------------------------------------

// WsMessage

// repeated .zjchain.ws.protobuf.WsTxItem txs = 1;
inline int WsMessage::txs_size() const {
  return txs_.size();
}
inline void WsMessage::clear_txs() {
  txs_.Clear();
}
inline ::zjchain::ws::protobuf::WsTxItem* WsMessage::mutable_txs(int index) {
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.WsMessage.txs)
  return txs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::WsTxItem >*
WsMessage::mutable_txs() {
  // @@protoc_insertion_point(field_mutable_list:zjchain.ws.protobuf.WsMessage.txs)
  return &txs_;
}
inline const ::zjchain::ws::protobuf::WsTxItem& WsMessage::txs(int index) const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.WsMessage.txs)
  return txs_.Get(index);
}
inline ::zjchain::ws::protobuf::WsTxItem* WsMessage::add_txs() {
  // @@protoc_insertion_point(field_add:zjchain.ws.protobuf.WsMessage.txs)
  return txs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::WsTxItem >&
WsMessage::txs() const {
  // @@protoc_insertion_point(field_list:zjchain.ws.protobuf.WsMessage.txs)
  return txs_;
}

// repeated .zjchain.ws.protobuf.BandwidthItem bws = 2;
inline int WsMessage::bws_size() const {
  return bws_.size();
}
inline void WsMessage::clear_bws() {
  bws_.Clear();
}
inline ::zjchain::ws::protobuf::BandwidthItem* WsMessage::mutable_bws(int index) {
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.WsMessage.bws)
  return bws_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::BandwidthItem >*
WsMessage::mutable_bws() {
  // @@protoc_insertion_point(field_mutable_list:zjchain.ws.protobuf.WsMessage.bws)
  return &bws_;
}
inline const ::zjchain::ws::protobuf::BandwidthItem& WsMessage::bws(int index) const {
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.WsMessage.bws)
  return bws_.Get(index);
}
inline ::zjchain::ws::protobuf::BandwidthItem* WsMessage::add_bws() {
  // @@protoc_insertion_point(field_add:zjchain.ws.protobuf.WsMessage.bws)
  return bws_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zjchain::ws::protobuf::BandwidthItem >&
WsMessage::bws() const {
  // @@protoc_insertion_point(field_list:zjchain.ws.protobuf.WsMessage.bws)
  return bws_;
}

// optional .zjchain.ws.protobuf.InitInfo init_info = 3;
inline bool WsMessage::has_init_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WsMessage::set_has_init_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WsMessage::clear_has_init_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WsMessage::clear_init_info() {
  if (init_info_ != NULL) init_info_->Clear();
  clear_has_init_info();
}
inline const ::zjchain::ws::protobuf::InitInfo& WsMessage::_internal_init_info() const {
  return *init_info_;
}
inline const ::zjchain::ws::protobuf::InitInfo& WsMessage::init_info() const {
  const ::zjchain::ws::protobuf::InitInfo* p = init_info_;
  // @@protoc_insertion_point(field_get:zjchain.ws.protobuf.WsMessage.init_info)
  return p != NULL ? *p : *reinterpret_cast<const ::zjchain::ws::protobuf::InitInfo*>(
      &::zjchain::ws::protobuf::_InitInfo_default_instance_);
}
inline ::zjchain::ws::protobuf::InitInfo* WsMessage::release_init_info() {
  // @@protoc_insertion_point(field_release:zjchain.ws.protobuf.WsMessage.init_info)
  clear_has_init_info();
  ::zjchain::ws::protobuf::InitInfo* temp = init_info_;
  init_info_ = NULL;
  return temp;
}
inline ::zjchain::ws::protobuf::InitInfo* WsMessage::mutable_init_info() {
  set_has_init_info();
  if (init_info_ == NULL) {
    auto* p = CreateMaybeMessage<::zjchain::ws::protobuf::InitInfo>(GetArenaNoVirtual());
    init_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zjchain.ws.protobuf.WsMessage.init_info)
  return init_info_;
}
inline void WsMessage::set_allocated_init_info(::zjchain::ws::protobuf::InitInfo* init_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete init_info_;
  }
  if (init_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      init_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, init_info, submessage_arena);
    }
    set_has_init_info();
  } else {
    clear_has_init_info();
  }
  init_info_ = init_info;
  // @@protoc_insertion_point(field_set_allocated:zjchain.ws.protobuf.WsMessage.init_info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace ws
}  // namespace zjchain

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::zjchain::ws::protobuf::StepType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zjchain::ws::protobuf::StepType>() {
  return ::zjchain::ws::protobuf::StepType_descriptor();
}
template <> struct is_proto_enum< ::zjchain::ws::protobuf::InitInfoTagType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zjchain::ws::protobuf::InitInfoTagType>() {
  return ::zjchain::ws::protobuf::InitInfoTagType_descriptor();
}
template <> struct is_proto_enum< ::zjchain::ws::protobuf::ReceiveType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zjchain::ws::protobuf::ReceiveType>() {
  return ::zjchain::ws::protobuf::ReceiveType_descriptor();
}
template <> struct is_proto_enum< ::zjchain::ws::protobuf::Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zjchain::ws::protobuf::Status>() {
  return ::zjchain::ws::protobuf::Status_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_protos_2fws_2eproto
