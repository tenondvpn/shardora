// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/zbft.proto

#ifndef PROTOBUF_protos_2fzbft_2eproto__INCLUDED
#define PROTOBUF_protos_2fzbft_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "protos/block.pb.h"
#include "protos/pools.pb.h"
// @@protoc_insertion_point(includes)

namespace zjchain {
namespace zbft {
namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_protos_2fzbft_2eproto();
void protobuf_AssignDesc_protos_2fzbft_2eproto();
void protobuf_ShutdownFile_protos_2fzbft_2eproto();

class TxBft;
class ZbftMessage;

// ===================================================================

class TxBft : public ::google::protobuf::Message {
 public:
  TxBft();
  virtual ~TxBft();

  TxBft(const TxBft& from);

  inline TxBft& operator=(const TxBft& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxBft& default_instance();

  void Swap(TxBft* other);

  // implements Message ----------------------------------------------

  TxBft* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxBft& from);
  void MergeFrom(const TxBft& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .zjchain.block.protobuf.Block block = 1;
  inline bool has_block() const;
  inline void clear_block();
  static const int kBlockFieldNumber = 1;
  inline const ::zjchain::block::protobuf::Block& block() const;
  inline ::zjchain::block::protobuf::Block* mutable_block();
  inline ::zjchain::block::protobuf::Block* release_block();
  inline void set_allocated_block(::zjchain::block::protobuf::Block* block);

  // optional bytes prepare_final_hash = 2;
  inline bool has_prepare_final_hash() const;
  inline void clear_prepare_final_hash();
  static const int kPrepareFinalHashFieldNumber = 2;
  inline const ::std::string& prepare_final_hash() const;
  inline void set_prepare_final_hash(const ::std::string& value);
  inline void set_prepare_final_hash(const char* value);
  inline void set_prepare_final_hash(const void* value, size_t size);
  inline ::std::string* mutable_prepare_final_hash();
  inline ::std::string* release_prepare_final_hash();
  inline void set_allocated_prepare_final_hash(::std::string* prepare_final_hash);

  // optional uint64 height = 3;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 3;
  inline ::google::protobuf::uint64 height() const;
  inline void set_height(::google::protobuf::uint64 value);

  // repeated bytes tx_hash_list = 4;
  inline int tx_hash_list_size() const;
  inline void clear_tx_hash_list();
  static const int kTxHashListFieldNumber = 4;
  inline const ::std::string& tx_hash_list(int index) const;
  inline ::std::string* mutable_tx_hash_list(int index);
  inline void set_tx_hash_list(int index, const ::std::string& value);
  inline void set_tx_hash_list(int index, const char* value);
  inline void set_tx_hash_list(int index, const void* value, size_t size);
  inline ::std::string* add_tx_hash_list();
  inline void add_tx_hash_list(const ::std::string& value);
  inline void add_tx_hash_list(const char* value);
  inline void add_tx_hash_list(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tx_hash_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tx_hash_list();

  // optional .zjchain.pools.protobuf.StepType tx_type = 5 [default = kNormalFrom];
  inline bool has_tx_type() const;
  inline void clear_tx_type();
  static const int kTxTypeFieldNumber = 5;
  inline ::zjchain::pools::protobuf::StepType tx_type() const;
  inline void set_tx_type(::zjchain::pools::protobuf::StepType value);

  // @@protoc_insertion_point(class_scope:zjchain.zbft.protobuf.TxBft)
 private:
  inline void set_has_block();
  inline void clear_has_block();
  inline void set_has_prepare_final_hash();
  inline void clear_has_prepare_final_hash();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_tx_type();
  inline void clear_has_tx_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::zjchain::block::protobuf::Block* block_;
  ::std::string* prepare_final_hash_;
  ::google::protobuf::uint64 height_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tx_hash_list_;
  int tx_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fzbft_2eproto();
  friend void protobuf_AssignDesc_protos_2fzbft_2eproto();
  friend void protobuf_ShutdownFile_protos_2fzbft_2eproto();

  void InitAsDefaultInstance();
  static TxBft* default_instance_;
};
// -------------------------------------------------------------------

class ZbftMessage : public ::google::protobuf::Message {
 public:
  ZbftMessage();
  virtual ~ZbftMessage();

  ZbftMessage(const ZbftMessage& from);

  inline ZbftMessage& operator=(const ZbftMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ZbftMessage& default_instance();

  void Swap(ZbftMessage* other);

  // implements Message ----------------------------------------------

  ZbftMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZbftMessage& from);
  void MergeFrom(const ZbftMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes prepare_gid = 1;
  inline bool has_prepare_gid() const;
  inline void clear_prepare_gid();
  static const int kPrepareGidFieldNumber = 1;
  inline const ::std::string& prepare_gid() const;
  inline void set_prepare_gid(const ::std::string& value);
  inline void set_prepare_gid(const char* value);
  inline void set_prepare_gid(const void* value, size_t size);
  inline ::std::string* mutable_prepare_gid();
  inline ::std::string* release_prepare_gid();
  inline void set_allocated_prepare_gid(::std::string* prepare_gid);

  // optional bytes precommit_gid = 2;
  inline bool has_precommit_gid() const;
  inline void clear_precommit_gid();
  static const int kPrecommitGidFieldNumber = 2;
  inline const ::std::string& precommit_gid() const;
  inline void set_precommit_gid(const ::std::string& value);
  inline void set_precommit_gid(const char* value);
  inline void set_precommit_gid(const void* value, size_t size);
  inline ::std::string* mutable_precommit_gid();
  inline ::std::string* release_precommit_gid();
  inline void set_allocated_precommit_gid(::std::string* precommit_gid);

  // optional bytes commit_gid = 3;
  inline bool has_commit_gid() const;
  inline void clear_commit_gid();
  static const int kCommitGidFieldNumber = 3;
  inline const ::std::string& commit_gid() const;
  inline void set_commit_gid(const ::std::string& value);
  inline void set_commit_gid(const char* value);
  inline void set_commit_gid(const void* value, size_t size);
  inline ::std::string* mutable_commit_gid();
  inline ::std::string* release_commit_gid();
  inline void set_allocated_commit_gid(::std::string* commit_gid);

  // optional int32 leader_idx = 4 [default = -1];
  inline bool has_leader_idx() const;
  inline void clear_leader_idx();
  static const int kLeaderIdxFieldNumber = 4;
  inline ::google::protobuf::int32 leader_idx() const;
  inline void set_leader_idx(::google::protobuf::int32 value);

  // optional uint32 net_id = 5;
  inline bool has_net_id() const;
  inline void clear_net_id();
  static const int kNetIdFieldNumber = 5;
  inline ::google::protobuf::uint32 net_id() const;
  inline void set_net_id(::google::protobuf::uint32 value);

  // optional bool agree_precommit = 6 [default = false];
  inline bool has_agree_precommit() const;
  inline void clear_agree_precommit();
  static const int kAgreePrecommitFieldNumber = 6;
  inline bool agree_precommit() const;
  inline void set_agree_precommit(bool value);

  // optional bool agree_commit = 7 [default = false];
  inline bool has_agree_commit() const;
  inline void clear_agree_commit();
  static const int kAgreeCommitFieldNumber = 7;
  inline bool agree_commit() const;
  inline void set_agree_commit(bool value);

  // optional uint32 pool_index = 8 [default = 4294967295];
  inline bool has_pool_index() const;
  inline void clear_pool_index();
  static const int kPoolIndexFieldNumber = 8;
  inline ::google::protobuf::uint32 pool_index() const;
  inline void set_pool_index(::google::protobuf::uint32 value);

  // optional int32 error = 9;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 9;
  inline ::google::protobuf::int32 error() const;
  inline void set_error(::google::protobuf::int32 value);

  // optional .zjchain.zbft.protobuf.TxBft tx_bft = 10;
  inline bool has_tx_bft() const;
  inline void clear_tx_bft();
  static const int kTxBftFieldNumber = 10;
  inline const ::zjchain::zbft::protobuf::TxBft& tx_bft() const;
  inline ::zjchain::zbft::protobuf::TxBft* mutable_tx_bft();
  inline ::zjchain::zbft::protobuf::TxBft* release_tx_bft();
  inline void set_allocated_tx_bft(::zjchain::zbft::protobuf::TxBft* tx_bft);

  // optional uint32 member_index = 11;
  inline bool has_member_index() const;
  inline void clear_member_index();
  static const int kMemberIndexFieldNumber = 11;
  inline ::google::protobuf::uint32 member_index() const;
  inline void set_member_index(::google::protobuf::uint32 value);

  // optional bytes backup_enc_data = 12;
  inline bool has_backup_enc_data() const;
  inline void clear_backup_enc_data();
  static const int kBackupEncDataFieldNumber = 12;
  inline const ::std::string& backup_enc_data() const;
  inline void set_backup_enc_data(const ::std::string& value);
  inline void set_backup_enc_data(const char* value);
  inline void set_backup_enc_data(const void* value, size_t size);
  inline ::std::string* mutable_backup_enc_data();
  inline ::std::string* release_backup_enc_data();
  inline void set_allocated_backup_enc_data(::std::string* backup_enc_data);

  // optional uint64 elect_height = 13;
  inline bool has_elect_height() const;
  inline void clear_elect_height();
  static const int kElectHeightFieldNumber = 13;
  inline ::google::protobuf::uint64 elect_height() const;
  inline void set_elect_height(::google::protobuf::uint64 value);

  // optional bytes bls_sign_x = 14;
  inline bool has_bls_sign_x() const;
  inline void clear_bls_sign_x();
  static const int kBlsSignXFieldNumber = 14;
  inline const ::std::string& bls_sign_x() const;
  inline void set_bls_sign_x(const ::std::string& value);
  inline void set_bls_sign_x(const char* value);
  inline void set_bls_sign_x(const void* value, size_t size);
  inline ::std::string* mutable_bls_sign_x();
  inline ::std::string* release_bls_sign_x();
  inline void set_allocated_bls_sign_x(::std::string* bls_sign_x);

  // optional bytes bls_sign_y = 15;
  inline bool has_bls_sign_y() const;
  inline void clear_bls_sign_y();
  static const int kBlsSignYFieldNumber = 15;
  inline const ::std::string& bls_sign_y() const;
  inline void set_bls_sign_y(const ::std::string& value);
  inline void set_bls_sign_y(const char* value);
  inline void set_bls_sign_y(const void* value, size_t size);
  inline ::std::string* mutable_bls_sign_y();
  inline ::std::string* release_bls_sign_y();
  inline void set_allocated_bls_sign_y(::std::string* bls_sign_y);

  // optional uint64 prepare_height = 16;
  inline bool has_prepare_height() const;
  inline void clear_prepare_height();
  static const int kPrepareHeightFieldNumber = 16;
  inline ::google::protobuf::uint64 prepare_height() const;
  inline void set_prepare_height(::google::protobuf::uint64 value);

  // optional bytes prepare_hash = 17;
  inline bool has_prepare_hash() const;
  inline void clear_prepare_hash();
  static const int kPrepareHashFieldNumber = 17;
  inline const ::std::string& prepare_hash() const;
  inline void set_prepare_hash(const ::std::string& value);
  inline void set_prepare_hash(const char* value);
  inline void set_prepare_hash(const void* value, size_t size);
  inline ::std::string* mutable_prepare_hash();
  inline ::std::string* release_prepare_hash();
  inline void set_allocated_prepare_hash(::std::string* prepare_hash);

  // optional .zjchain.block.protobuf.Block block = 18;
  inline bool has_block() const;
  inline void clear_block();
  static const int kBlockFieldNumber = 18;
  inline const ::zjchain::block::protobuf::Block& block() const;
  inline ::zjchain::block::protobuf::Block* mutable_block();
  inline ::zjchain::block::protobuf::Block* release_block();
  inline void set_allocated_block(::zjchain::block::protobuf::Block* block);

  // optional bool sync_block = 19;
  inline bool has_sync_block() const;
  inline void clear_sync_block();
  static const int kSyncBlockFieldNumber = 19;
  inline bool sync_block() const;
  inline void set_sync_block(bool value);

  // repeated uint32 ips = 20;
  inline int ips_size() const;
  inline void clear_ips();
  static const int kIpsFieldNumber = 20;
  inline ::google::protobuf::uint32 ips(int index) const;
  inline void set_ips(int index, ::google::protobuf::uint32 value);
  inline void add_ips(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ips() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ips();

  // optional bytes oppose_prepare_gid = 21;
  inline bool has_oppose_prepare_gid() const;
  inline void clear_oppose_prepare_gid();
  static const int kOpposePrepareGidFieldNumber = 21;
  inline const ::std::string& oppose_prepare_gid() const;
  inline void set_oppose_prepare_gid(const ::std::string& value);
  inline void set_oppose_prepare_gid(const char* value);
  inline void set_oppose_prepare_gid(const void* value, size_t size);
  inline ::std::string* mutable_oppose_prepare_gid();
  inline ::std::string* release_oppose_prepare_gid();
  inline void set_allocated_oppose_prepare_gid(::std::string* oppose_prepare_gid);

  // repeated uint32 invaid_txs = 22;
  inline int invaid_txs_size() const;
  inline void clear_invaid_txs();
  static const int kInvaidTxsFieldNumber = 22;
  inline ::google::protobuf::uint32 invaid_txs(int index) const;
  inline void set_invaid_txs(int index, ::google::protobuf::uint32 value);
  inline void add_invaid_txs(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      invaid_txs() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_invaid_txs();

  // @@protoc_insertion_point(class_scope:zjchain.zbft.protobuf.ZbftMessage)
 private:
  inline void set_has_prepare_gid();
  inline void clear_has_prepare_gid();
  inline void set_has_precommit_gid();
  inline void clear_has_precommit_gid();
  inline void set_has_commit_gid();
  inline void clear_has_commit_gid();
  inline void set_has_leader_idx();
  inline void clear_has_leader_idx();
  inline void set_has_net_id();
  inline void clear_has_net_id();
  inline void set_has_agree_precommit();
  inline void clear_has_agree_precommit();
  inline void set_has_agree_commit();
  inline void clear_has_agree_commit();
  inline void set_has_pool_index();
  inline void clear_has_pool_index();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_tx_bft();
  inline void clear_has_tx_bft();
  inline void set_has_member_index();
  inline void clear_has_member_index();
  inline void set_has_backup_enc_data();
  inline void clear_has_backup_enc_data();
  inline void set_has_elect_height();
  inline void clear_has_elect_height();
  inline void set_has_bls_sign_x();
  inline void clear_has_bls_sign_x();
  inline void set_has_bls_sign_y();
  inline void clear_has_bls_sign_y();
  inline void set_has_prepare_height();
  inline void clear_has_prepare_height();
  inline void set_has_prepare_hash();
  inline void clear_has_prepare_hash();
  inline void set_has_block();
  inline void clear_has_block();
  inline void set_has_sync_block();
  inline void clear_has_sync_block();
  inline void set_has_oppose_prepare_gid();
  inline void clear_has_oppose_prepare_gid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* prepare_gid_;
  ::std::string* precommit_gid_;
  ::std::string* commit_gid_;
  ::google::protobuf::int32 leader_idx_;
  ::google::protobuf::uint32 net_id_;
  ::google::protobuf::uint32 pool_index_;
  ::google::protobuf::int32 error_;
  ::zjchain::zbft::protobuf::TxBft* tx_bft_;
  bool agree_precommit_;
  bool agree_commit_;
  bool sync_block_;
  ::google::protobuf::uint32 member_index_;
  ::std::string* backup_enc_data_;
  ::google::protobuf::uint64 elect_height_;
  ::std::string* bls_sign_x_;
  ::std::string* bls_sign_y_;
  ::google::protobuf::uint64 prepare_height_;
  ::std::string* prepare_hash_;
  ::zjchain::block::protobuf::Block* block_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ips_;
  ::std::string* oppose_prepare_gid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > invaid_txs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(22 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fzbft_2eproto();
  friend void protobuf_AssignDesc_protos_2fzbft_2eproto();
  friend void protobuf_ShutdownFile_protos_2fzbft_2eproto();

  void InitAsDefaultInstance();
  static ZbftMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// TxBft

// optional .zjchain.block.protobuf.Block block = 1;
inline bool TxBft::has_block() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxBft::set_has_block() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxBft::clear_has_block() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxBft::clear_block() {
  if (block_ != NULL) block_->::zjchain::block::protobuf::Block::Clear();
  clear_has_block();
}
inline const ::zjchain::block::protobuf::Block& TxBft::block() const {
  return block_ != NULL ? *block_ : *default_instance_->block_;
}
inline ::zjchain::block::protobuf::Block* TxBft::mutable_block() {
  set_has_block();
  if (block_ == NULL) block_ = new ::zjchain::block::protobuf::Block;
  return block_;
}
inline ::zjchain::block::protobuf::Block* TxBft::release_block() {
  clear_has_block();
  ::zjchain::block::protobuf::Block* temp = block_;
  block_ = NULL;
  return temp;
}
inline void TxBft::set_allocated_block(::zjchain::block::protobuf::Block* block) {
  delete block_;
  block_ = block;
  if (block) {
    set_has_block();
  } else {
    clear_has_block();
  }
}

// optional bytes prepare_final_hash = 2;
inline bool TxBft::has_prepare_final_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxBft::set_has_prepare_final_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxBft::clear_has_prepare_final_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxBft::clear_prepare_final_hash() {
  if (prepare_final_hash_ != &::google::protobuf::internal::kEmptyString) {
    prepare_final_hash_->clear();
  }
  clear_has_prepare_final_hash();
}
inline const ::std::string& TxBft::prepare_final_hash() const {
  return *prepare_final_hash_;
}
inline void TxBft::set_prepare_final_hash(const ::std::string& value) {
  set_has_prepare_final_hash();
  if (prepare_final_hash_ == &::google::protobuf::internal::kEmptyString) {
    prepare_final_hash_ = new ::std::string;
  }
  prepare_final_hash_->assign(value);
}
inline void TxBft::set_prepare_final_hash(const char* value) {
  set_has_prepare_final_hash();
  if (prepare_final_hash_ == &::google::protobuf::internal::kEmptyString) {
    prepare_final_hash_ = new ::std::string;
  }
  prepare_final_hash_->assign(value);
}
inline void TxBft::set_prepare_final_hash(const void* value, size_t size) {
  set_has_prepare_final_hash();
  if (prepare_final_hash_ == &::google::protobuf::internal::kEmptyString) {
    prepare_final_hash_ = new ::std::string;
  }
  prepare_final_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxBft::mutable_prepare_final_hash() {
  set_has_prepare_final_hash();
  if (prepare_final_hash_ == &::google::protobuf::internal::kEmptyString) {
    prepare_final_hash_ = new ::std::string;
  }
  return prepare_final_hash_;
}
inline ::std::string* TxBft::release_prepare_final_hash() {
  clear_has_prepare_final_hash();
  if (prepare_final_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prepare_final_hash_;
    prepare_final_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxBft::set_allocated_prepare_final_hash(::std::string* prepare_final_hash) {
  if (prepare_final_hash_ != &::google::protobuf::internal::kEmptyString) {
    delete prepare_final_hash_;
  }
  if (prepare_final_hash) {
    set_has_prepare_final_hash();
    prepare_final_hash_ = prepare_final_hash;
  } else {
    clear_has_prepare_final_hash();
    prepare_final_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 height = 3;
inline bool TxBft::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxBft::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxBft::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxBft::clear_height() {
  height_ = GOOGLE_ULONGLONG(0);
  clear_has_height();
}
inline ::google::protobuf::uint64 TxBft::height() const {
  return height_;
}
inline void TxBft::set_height(::google::protobuf::uint64 value) {
  set_has_height();
  height_ = value;
}

// repeated bytes tx_hash_list = 4;
inline int TxBft::tx_hash_list_size() const {
  return tx_hash_list_.size();
}
inline void TxBft::clear_tx_hash_list() {
  tx_hash_list_.Clear();
}
inline const ::std::string& TxBft::tx_hash_list(int index) const {
  return tx_hash_list_.Get(index);
}
inline ::std::string* TxBft::mutable_tx_hash_list(int index) {
  return tx_hash_list_.Mutable(index);
}
inline void TxBft::set_tx_hash_list(int index, const ::std::string& value) {
  tx_hash_list_.Mutable(index)->assign(value);
}
inline void TxBft::set_tx_hash_list(int index, const char* value) {
  tx_hash_list_.Mutable(index)->assign(value);
}
inline void TxBft::set_tx_hash_list(int index, const void* value, size_t size) {
  tx_hash_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxBft::add_tx_hash_list() {
  return tx_hash_list_.Add();
}
inline void TxBft::add_tx_hash_list(const ::std::string& value) {
  tx_hash_list_.Add()->assign(value);
}
inline void TxBft::add_tx_hash_list(const char* value) {
  tx_hash_list_.Add()->assign(value);
}
inline void TxBft::add_tx_hash_list(const void* value, size_t size) {
  tx_hash_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TxBft::tx_hash_list() const {
  return tx_hash_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TxBft::mutable_tx_hash_list() {
  return &tx_hash_list_;
}

// optional .zjchain.pools.protobuf.StepType tx_type = 5 [default = kNormalFrom];
inline bool TxBft::has_tx_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxBft::set_has_tx_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TxBft::clear_has_tx_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TxBft::clear_tx_type() {
  tx_type_ = 0;
  clear_has_tx_type();
}
inline ::zjchain::pools::protobuf::StepType TxBft::tx_type() const {
  return static_cast< ::zjchain::pools::protobuf::StepType >(tx_type_);
}
inline void TxBft::set_tx_type(::zjchain::pools::protobuf::StepType value) {
  assert(::zjchain::pools::protobuf::StepType_IsValid(value));
  set_has_tx_type();
  tx_type_ = value;
}

// -------------------------------------------------------------------

// ZbftMessage

// optional bytes prepare_gid = 1;
inline bool ZbftMessage::has_prepare_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZbftMessage::set_has_prepare_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZbftMessage::clear_has_prepare_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZbftMessage::clear_prepare_gid() {
  if (prepare_gid_ != &::google::protobuf::internal::kEmptyString) {
    prepare_gid_->clear();
  }
  clear_has_prepare_gid();
}
inline const ::std::string& ZbftMessage::prepare_gid() const {
  return *prepare_gid_;
}
inline void ZbftMessage::set_prepare_gid(const ::std::string& value) {
  set_has_prepare_gid();
  if (prepare_gid_ == &::google::protobuf::internal::kEmptyString) {
    prepare_gid_ = new ::std::string;
  }
  prepare_gid_->assign(value);
}
inline void ZbftMessage::set_prepare_gid(const char* value) {
  set_has_prepare_gid();
  if (prepare_gid_ == &::google::protobuf::internal::kEmptyString) {
    prepare_gid_ = new ::std::string;
  }
  prepare_gid_->assign(value);
}
inline void ZbftMessage::set_prepare_gid(const void* value, size_t size) {
  set_has_prepare_gid();
  if (prepare_gid_ == &::google::protobuf::internal::kEmptyString) {
    prepare_gid_ = new ::std::string;
  }
  prepare_gid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZbftMessage::mutable_prepare_gid() {
  set_has_prepare_gid();
  if (prepare_gid_ == &::google::protobuf::internal::kEmptyString) {
    prepare_gid_ = new ::std::string;
  }
  return prepare_gid_;
}
inline ::std::string* ZbftMessage::release_prepare_gid() {
  clear_has_prepare_gid();
  if (prepare_gid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prepare_gid_;
    prepare_gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ZbftMessage::set_allocated_prepare_gid(::std::string* prepare_gid) {
  if (prepare_gid_ != &::google::protobuf::internal::kEmptyString) {
    delete prepare_gid_;
  }
  if (prepare_gid) {
    set_has_prepare_gid();
    prepare_gid_ = prepare_gid;
  } else {
    clear_has_prepare_gid();
    prepare_gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes precommit_gid = 2;
inline bool ZbftMessage::has_precommit_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ZbftMessage::set_has_precommit_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ZbftMessage::clear_has_precommit_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ZbftMessage::clear_precommit_gid() {
  if (precommit_gid_ != &::google::protobuf::internal::kEmptyString) {
    precommit_gid_->clear();
  }
  clear_has_precommit_gid();
}
inline const ::std::string& ZbftMessage::precommit_gid() const {
  return *precommit_gid_;
}
inline void ZbftMessage::set_precommit_gid(const ::std::string& value) {
  set_has_precommit_gid();
  if (precommit_gid_ == &::google::protobuf::internal::kEmptyString) {
    precommit_gid_ = new ::std::string;
  }
  precommit_gid_->assign(value);
}
inline void ZbftMessage::set_precommit_gid(const char* value) {
  set_has_precommit_gid();
  if (precommit_gid_ == &::google::protobuf::internal::kEmptyString) {
    precommit_gid_ = new ::std::string;
  }
  precommit_gid_->assign(value);
}
inline void ZbftMessage::set_precommit_gid(const void* value, size_t size) {
  set_has_precommit_gid();
  if (precommit_gid_ == &::google::protobuf::internal::kEmptyString) {
    precommit_gid_ = new ::std::string;
  }
  precommit_gid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZbftMessage::mutable_precommit_gid() {
  set_has_precommit_gid();
  if (precommit_gid_ == &::google::protobuf::internal::kEmptyString) {
    precommit_gid_ = new ::std::string;
  }
  return precommit_gid_;
}
inline ::std::string* ZbftMessage::release_precommit_gid() {
  clear_has_precommit_gid();
  if (precommit_gid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = precommit_gid_;
    precommit_gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ZbftMessage::set_allocated_precommit_gid(::std::string* precommit_gid) {
  if (precommit_gid_ != &::google::protobuf::internal::kEmptyString) {
    delete precommit_gid_;
  }
  if (precommit_gid) {
    set_has_precommit_gid();
    precommit_gid_ = precommit_gid;
  } else {
    clear_has_precommit_gid();
    precommit_gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes commit_gid = 3;
inline bool ZbftMessage::has_commit_gid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ZbftMessage::set_has_commit_gid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ZbftMessage::clear_has_commit_gid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ZbftMessage::clear_commit_gid() {
  if (commit_gid_ != &::google::protobuf::internal::kEmptyString) {
    commit_gid_->clear();
  }
  clear_has_commit_gid();
}
inline const ::std::string& ZbftMessage::commit_gid() const {
  return *commit_gid_;
}
inline void ZbftMessage::set_commit_gid(const ::std::string& value) {
  set_has_commit_gid();
  if (commit_gid_ == &::google::protobuf::internal::kEmptyString) {
    commit_gid_ = new ::std::string;
  }
  commit_gid_->assign(value);
}
inline void ZbftMessage::set_commit_gid(const char* value) {
  set_has_commit_gid();
  if (commit_gid_ == &::google::protobuf::internal::kEmptyString) {
    commit_gid_ = new ::std::string;
  }
  commit_gid_->assign(value);
}
inline void ZbftMessage::set_commit_gid(const void* value, size_t size) {
  set_has_commit_gid();
  if (commit_gid_ == &::google::protobuf::internal::kEmptyString) {
    commit_gid_ = new ::std::string;
  }
  commit_gid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZbftMessage::mutable_commit_gid() {
  set_has_commit_gid();
  if (commit_gid_ == &::google::protobuf::internal::kEmptyString) {
    commit_gid_ = new ::std::string;
  }
  return commit_gid_;
}
inline ::std::string* ZbftMessage::release_commit_gid() {
  clear_has_commit_gid();
  if (commit_gid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = commit_gid_;
    commit_gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ZbftMessage::set_allocated_commit_gid(::std::string* commit_gid) {
  if (commit_gid_ != &::google::protobuf::internal::kEmptyString) {
    delete commit_gid_;
  }
  if (commit_gid) {
    set_has_commit_gid();
    commit_gid_ = commit_gid;
  } else {
    clear_has_commit_gid();
    commit_gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 leader_idx = 4 [default = -1];
inline bool ZbftMessage::has_leader_idx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ZbftMessage::set_has_leader_idx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ZbftMessage::clear_has_leader_idx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ZbftMessage::clear_leader_idx() {
  leader_idx_ = -1;
  clear_has_leader_idx();
}
inline ::google::protobuf::int32 ZbftMessage::leader_idx() const {
  return leader_idx_;
}
inline void ZbftMessage::set_leader_idx(::google::protobuf::int32 value) {
  set_has_leader_idx();
  leader_idx_ = value;
}

// optional uint32 net_id = 5;
inline bool ZbftMessage::has_net_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ZbftMessage::set_has_net_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ZbftMessage::clear_has_net_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ZbftMessage::clear_net_id() {
  net_id_ = 0u;
  clear_has_net_id();
}
inline ::google::protobuf::uint32 ZbftMessage::net_id() const {
  return net_id_;
}
inline void ZbftMessage::set_net_id(::google::protobuf::uint32 value) {
  set_has_net_id();
  net_id_ = value;
}

// optional bool agree_precommit = 6 [default = false];
inline bool ZbftMessage::has_agree_precommit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ZbftMessage::set_has_agree_precommit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ZbftMessage::clear_has_agree_precommit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ZbftMessage::clear_agree_precommit() {
  agree_precommit_ = false;
  clear_has_agree_precommit();
}
inline bool ZbftMessage::agree_precommit() const {
  return agree_precommit_;
}
inline void ZbftMessage::set_agree_precommit(bool value) {
  set_has_agree_precommit();
  agree_precommit_ = value;
}

// optional bool agree_commit = 7 [default = false];
inline bool ZbftMessage::has_agree_commit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ZbftMessage::set_has_agree_commit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ZbftMessage::clear_has_agree_commit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ZbftMessage::clear_agree_commit() {
  agree_commit_ = false;
  clear_has_agree_commit();
}
inline bool ZbftMessage::agree_commit() const {
  return agree_commit_;
}
inline void ZbftMessage::set_agree_commit(bool value) {
  set_has_agree_commit();
  agree_commit_ = value;
}

// optional uint32 pool_index = 8 [default = 4294967295];
inline bool ZbftMessage::has_pool_index() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ZbftMessage::set_has_pool_index() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ZbftMessage::clear_has_pool_index() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ZbftMessage::clear_pool_index() {
  pool_index_ = 4294967295u;
  clear_has_pool_index();
}
inline ::google::protobuf::uint32 ZbftMessage::pool_index() const {
  return pool_index_;
}
inline void ZbftMessage::set_pool_index(::google::protobuf::uint32 value) {
  set_has_pool_index();
  pool_index_ = value;
}

// optional int32 error = 9;
inline bool ZbftMessage::has_error() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ZbftMessage::set_has_error() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ZbftMessage::clear_has_error() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ZbftMessage::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::google::protobuf::int32 ZbftMessage::error() const {
  return error_;
}
inline void ZbftMessage::set_error(::google::protobuf::int32 value) {
  set_has_error();
  error_ = value;
}

// optional .zjchain.zbft.protobuf.TxBft tx_bft = 10;
inline bool ZbftMessage::has_tx_bft() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ZbftMessage::set_has_tx_bft() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ZbftMessage::clear_has_tx_bft() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ZbftMessage::clear_tx_bft() {
  if (tx_bft_ != NULL) tx_bft_->::zjchain::zbft::protobuf::TxBft::Clear();
  clear_has_tx_bft();
}
inline const ::zjchain::zbft::protobuf::TxBft& ZbftMessage::tx_bft() const {
  return tx_bft_ != NULL ? *tx_bft_ : *default_instance_->tx_bft_;
}
inline ::zjchain::zbft::protobuf::TxBft* ZbftMessage::mutable_tx_bft() {
  set_has_tx_bft();
  if (tx_bft_ == NULL) tx_bft_ = new ::zjchain::zbft::protobuf::TxBft;
  return tx_bft_;
}
inline ::zjchain::zbft::protobuf::TxBft* ZbftMessage::release_tx_bft() {
  clear_has_tx_bft();
  ::zjchain::zbft::protobuf::TxBft* temp = tx_bft_;
  tx_bft_ = NULL;
  return temp;
}
inline void ZbftMessage::set_allocated_tx_bft(::zjchain::zbft::protobuf::TxBft* tx_bft) {
  delete tx_bft_;
  tx_bft_ = tx_bft;
  if (tx_bft) {
    set_has_tx_bft();
  } else {
    clear_has_tx_bft();
  }
}

// optional uint32 member_index = 11;
inline bool ZbftMessage::has_member_index() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ZbftMessage::set_has_member_index() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ZbftMessage::clear_has_member_index() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ZbftMessage::clear_member_index() {
  member_index_ = 0u;
  clear_has_member_index();
}
inline ::google::protobuf::uint32 ZbftMessage::member_index() const {
  return member_index_;
}
inline void ZbftMessage::set_member_index(::google::protobuf::uint32 value) {
  set_has_member_index();
  member_index_ = value;
}

// optional bytes backup_enc_data = 12;
inline bool ZbftMessage::has_backup_enc_data() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ZbftMessage::set_has_backup_enc_data() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ZbftMessage::clear_has_backup_enc_data() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ZbftMessage::clear_backup_enc_data() {
  if (backup_enc_data_ != &::google::protobuf::internal::kEmptyString) {
    backup_enc_data_->clear();
  }
  clear_has_backup_enc_data();
}
inline const ::std::string& ZbftMessage::backup_enc_data() const {
  return *backup_enc_data_;
}
inline void ZbftMessage::set_backup_enc_data(const ::std::string& value) {
  set_has_backup_enc_data();
  if (backup_enc_data_ == &::google::protobuf::internal::kEmptyString) {
    backup_enc_data_ = new ::std::string;
  }
  backup_enc_data_->assign(value);
}
inline void ZbftMessage::set_backup_enc_data(const char* value) {
  set_has_backup_enc_data();
  if (backup_enc_data_ == &::google::protobuf::internal::kEmptyString) {
    backup_enc_data_ = new ::std::string;
  }
  backup_enc_data_->assign(value);
}
inline void ZbftMessage::set_backup_enc_data(const void* value, size_t size) {
  set_has_backup_enc_data();
  if (backup_enc_data_ == &::google::protobuf::internal::kEmptyString) {
    backup_enc_data_ = new ::std::string;
  }
  backup_enc_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZbftMessage::mutable_backup_enc_data() {
  set_has_backup_enc_data();
  if (backup_enc_data_ == &::google::protobuf::internal::kEmptyString) {
    backup_enc_data_ = new ::std::string;
  }
  return backup_enc_data_;
}
inline ::std::string* ZbftMessage::release_backup_enc_data() {
  clear_has_backup_enc_data();
  if (backup_enc_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = backup_enc_data_;
    backup_enc_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ZbftMessage::set_allocated_backup_enc_data(::std::string* backup_enc_data) {
  if (backup_enc_data_ != &::google::protobuf::internal::kEmptyString) {
    delete backup_enc_data_;
  }
  if (backup_enc_data) {
    set_has_backup_enc_data();
    backup_enc_data_ = backup_enc_data;
  } else {
    clear_has_backup_enc_data();
    backup_enc_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 elect_height = 13;
inline bool ZbftMessage::has_elect_height() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ZbftMessage::set_has_elect_height() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ZbftMessage::clear_has_elect_height() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ZbftMessage::clear_elect_height() {
  elect_height_ = GOOGLE_ULONGLONG(0);
  clear_has_elect_height();
}
inline ::google::protobuf::uint64 ZbftMessage::elect_height() const {
  return elect_height_;
}
inline void ZbftMessage::set_elect_height(::google::protobuf::uint64 value) {
  set_has_elect_height();
  elect_height_ = value;
}

// optional bytes bls_sign_x = 14;
inline bool ZbftMessage::has_bls_sign_x() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ZbftMessage::set_has_bls_sign_x() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ZbftMessage::clear_has_bls_sign_x() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ZbftMessage::clear_bls_sign_x() {
  if (bls_sign_x_ != &::google::protobuf::internal::kEmptyString) {
    bls_sign_x_->clear();
  }
  clear_has_bls_sign_x();
}
inline const ::std::string& ZbftMessage::bls_sign_x() const {
  return *bls_sign_x_;
}
inline void ZbftMessage::set_bls_sign_x(const ::std::string& value) {
  set_has_bls_sign_x();
  if (bls_sign_x_ == &::google::protobuf::internal::kEmptyString) {
    bls_sign_x_ = new ::std::string;
  }
  bls_sign_x_->assign(value);
}
inline void ZbftMessage::set_bls_sign_x(const char* value) {
  set_has_bls_sign_x();
  if (bls_sign_x_ == &::google::protobuf::internal::kEmptyString) {
    bls_sign_x_ = new ::std::string;
  }
  bls_sign_x_->assign(value);
}
inline void ZbftMessage::set_bls_sign_x(const void* value, size_t size) {
  set_has_bls_sign_x();
  if (bls_sign_x_ == &::google::protobuf::internal::kEmptyString) {
    bls_sign_x_ = new ::std::string;
  }
  bls_sign_x_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZbftMessage::mutable_bls_sign_x() {
  set_has_bls_sign_x();
  if (bls_sign_x_ == &::google::protobuf::internal::kEmptyString) {
    bls_sign_x_ = new ::std::string;
  }
  return bls_sign_x_;
}
inline ::std::string* ZbftMessage::release_bls_sign_x() {
  clear_has_bls_sign_x();
  if (bls_sign_x_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bls_sign_x_;
    bls_sign_x_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ZbftMessage::set_allocated_bls_sign_x(::std::string* bls_sign_x) {
  if (bls_sign_x_ != &::google::protobuf::internal::kEmptyString) {
    delete bls_sign_x_;
  }
  if (bls_sign_x) {
    set_has_bls_sign_x();
    bls_sign_x_ = bls_sign_x;
  } else {
    clear_has_bls_sign_x();
    bls_sign_x_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes bls_sign_y = 15;
inline bool ZbftMessage::has_bls_sign_y() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ZbftMessage::set_has_bls_sign_y() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ZbftMessage::clear_has_bls_sign_y() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ZbftMessage::clear_bls_sign_y() {
  if (bls_sign_y_ != &::google::protobuf::internal::kEmptyString) {
    bls_sign_y_->clear();
  }
  clear_has_bls_sign_y();
}
inline const ::std::string& ZbftMessage::bls_sign_y() const {
  return *bls_sign_y_;
}
inline void ZbftMessage::set_bls_sign_y(const ::std::string& value) {
  set_has_bls_sign_y();
  if (bls_sign_y_ == &::google::protobuf::internal::kEmptyString) {
    bls_sign_y_ = new ::std::string;
  }
  bls_sign_y_->assign(value);
}
inline void ZbftMessage::set_bls_sign_y(const char* value) {
  set_has_bls_sign_y();
  if (bls_sign_y_ == &::google::protobuf::internal::kEmptyString) {
    bls_sign_y_ = new ::std::string;
  }
  bls_sign_y_->assign(value);
}
inline void ZbftMessage::set_bls_sign_y(const void* value, size_t size) {
  set_has_bls_sign_y();
  if (bls_sign_y_ == &::google::protobuf::internal::kEmptyString) {
    bls_sign_y_ = new ::std::string;
  }
  bls_sign_y_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZbftMessage::mutable_bls_sign_y() {
  set_has_bls_sign_y();
  if (bls_sign_y_ == &::google::protobuf::internal::kEmptyString) {
    bls_sign_y_ = new ::std::string;
  }
  return bls_sign_y_;
}
inline ::std::string* ZbftMessage::release_bls_sign_y() {
  clear_has_bls_sign_y();
  if (bls_sign_y_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bls_sign_y_;
    bls_sign_y_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ZbftMessage::set_allocated_bls_sign_y(::std::string* bls_sign_y) {
  if (bls_sign_y_ != &::google::protobuf::internal::kEmptyString) {
    delete bls_sign_y_;
  }
  if (bls_sign_y) {
    set_has_bls_sign_y();
    bls_sign_y_ = bls_sign_y;
  } else {
    clear_has_bls_sign_y();
    bls_sign_y_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 prepare_height = 16;
inline bool ZbftMessage::has_prepare_height() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ZbftMessage::set_has_prepare_height() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ZbftMessage::clear_has_prepare_height() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ZbftMessage::clear_prepare_height() {
  prepare_height_ = GOOGLE_ULONGLONG(0);
  clear_has_prepare_height();
}
inline ::google::protobuf::uint64 ZbftMessage::prepare_height() const {
  return prepare_height_;
}
inline void ZbftMessage::set_prepare_height(::google::protobuf::uint64 value) {
  set_has_prepare_height();
  prepare_height_ = value;
}

// optional bytes prepare_hash = 17;
inline bool ZbftMessage::has_prepare_hash() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ZbftMessage::set_has_prepare_hash() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ZbftMessage::clear_has_prepare_hash() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ZbftMessage::clear_prepare_hash() {
  if (prepare_hash_ != &::google::protobuf::internal::kEmptyString) {
    prepare_hash_->clear();
  }
  clear_has_prepare_hash();
}
inline const ::std::string& ZbftMessage::prepare_hash() const {
  return *prepare_hash_;
}
inline void ZbftMessage::set_prepare_hash(const ::std::string& value) {
  set_has_prepare_hash();
  if (prepare_hash_ == &::google::protobuf::internal::kEmptyString) {
    prepare_hash_ = new ::std::string;
  }
  prepare_hash_->assign(value);
}
inline void ZbftMessage::set_prepare_hash(const char* value) {
  set_has_prepare_hash();
  if (prepare_hash_ == &::google::protobuf::internal::kEmptyString) {
    prepare_hash_ = new ::std::string;
  }
  prepare_hash_->assign(value);
}
inline void ZbftMessage::set_prepare_hash(const void* value, size_t size) {
  set_has_prepare_hash();
  if (prepare_hash_ == &::google::protobuf::internal::kEmptyString) {
    prepare_hash_ = new ::std::string;
  }
  prepare_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZbftMessage::mutable_prepare_hash() {
  set_has_prepare_hash();
  if (prepare_hash_ == &::google::protobuf::internal::kEmptyString) {
    prepare_hash_ = new ::std::string;
  }
  return prepare_hash_;
}
inline ::std::string* ZbftMessage::release_prepare_hash() {
  clear_has_prepare_hash();
  if (prepare_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prepare_hash_;
    prepare_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ZbftMessage::set_allocated_prepare_hash(::std::string* prepare_hash) {
  if (prepare_hash_ != &::google::protobuf::internal::kEmptyString) {
    delete prepare_hash_;
  }
  if (prepare_hash) {
    set_has_prepare_hash();
    prepare_hash_ = prepare_hash;
  } else {
    clear_has_prepare_hash();
    prepare_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .zjchain.block.protobuf.Block block = 18;
inline bool ZbftMessage::has_block() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ZbftMessage::set_has_block() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ZbftMessage::clear_has_block() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ZbftMessage::clear_block() {
  if (block_ != NULL) block_->::zjchain::block::protobuf::Block::Clear();
  clear_has_block();
}
inline const ::zjchain::block::protobuf::Block& ZbftMessage::block() const {
  return block_ != NULL ? *block_ : *default_instance_->block_;
}
inline ::zjchain::block::protobuf::Block* ZbftMessage::mutable_block() {
  set_has_block();
  if (block_ == NULL) block_ = new ::zjchain::block::protobuf::Block;
  return block_;
}
inline ::zjchain::block::protobuf::Block* ZbftMessage::release_block() {
  clear_has_block();
  ::zjchain::block::protobuf::Block* temp = block_;
  block_ = NULL;
  return temp;
}
inline void ZbftMessage::set_allocated_block(::zjchain::block::protobuf::Block* block) {
  delete block_;
  block_ = block;
  if (block) {
    set_has_block();
  } else {
    clear_has_block();
  }
}

// optional bool sync_block = 19;
inline bool ZbftMessage::has_sync_block() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ZbftMessage::set_has_sync_block() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ZbftMessage::clear_has_sync_block() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ZbftMessage::clear_sync_block() {
  sync_block_ = false;
  clear_has_sync_block();
}
inline bool ZbftMessage::sync_block() const {
  return sync_block_;
}
inline void ZbftMessage::set_sync_block(bool value) {
  set_has_sync_block();
  sync_block_ = value;
}

// repeated uint32 ips = 20;
inline int ZbftMessage::ips_size() const {
  return ips_.size();
}
inline void ZbftMessage::clear_ips() {
  ips_.Clear();
}
inline ::google::protobuf::uint32 ZbftMessage::ips(int index) const {
  return ips_.Get(index);
}
inline void ZbftMessage::set_ips(int index, ::google::protobuf::uint32 value) {
  ips_.Set(index, value);
}
inline void ZbftMessage::add_ips(::google::protobuf::uint32 value) {
  ips_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ZbftMessage::ips() const {
  return ips_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ZbftMessage::mutable_ips() {
  return &ips_;
}

// optional bytes oppose_prepare_gid = 21;
inline bool ZbftMessage::has_oppose_prepare_gid() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ZbftMessage::set_has_oppose_prepare_gid() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ZbftMessage::clear_has_oppose_prepare_gid() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ZbftMessage::clear_oppose_prepare_gid() {
  if (oppose_prepare_gid_ != &::google::protobuf::internal::kEmptyString) {
    oppose_prepare_gid_->clear();
  }
  clear_has_oppose_prepare_gid();
}
inline const ::std::string& ZbftMessage::oppose_prepare_gid() const {
  return *oppose_prepare_gid_;
}
inline void ZbftMessage::set_oppose_prepare_gid(const ::std::string& value) {
  set_has_oppose_prepare_gid();
  if (oppose_prepare_gid_ == &::google::protobuf::internal::kEmptyString) {
    oppose_prepare_gid_ = new ::std::string;
  }
  oppose_prepare_gid_->assign(value);
}
inline void ZbftMessage::set_oppose_prepare_gid(const char* value) {
  set_has_oppose_prepare_gid();
  if (oppose_prepare_gid_ == &::google::protobuf::internal::kEmptyString) {
    oppose_prepare_gid_ = new ::std::string;
  }
  oppose_prepare_gid_->assign(value);
}
inline void ZbftMessage::set_oppose_prepare_gid(const void* value, size_t size) {
  set_has_oppose_prepare_gid();
  if (oppose_prepare_gid_ == &::google::protobuf::internal::kEmptyString) {
    oppose_prepare_gid_ = new ::std::string;
  }
  oppose_prepare_gid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZbftMessage::mutable_oppose_prepare_gid() {
  set_has_oppose_prepare_gid();
  if (oppose_prepare_gid_ == &::google::protobuf::internal::kEmptyString) {
    oppose_prepare_gid_ = new ::std::string;
  }
  return oppose_prepare_gid_;
}
inline ::std::string* ZbftMessage::release_oppose_prepare_gid() {
  clear_has_oppose_prepare_gid();
  if (oppose_prepare_gid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oppose_prepare_gid_;
    oppose_prepare_gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ZbftMessage::set_allocated_oppose_prepare_gid(::std::string* oppose_prepare_gid) {
  if (oppose_prepare_gid_ != &::google::protobuf::internal::kEmptyString) {
    delete oppose_prepare_gid_;
  }
  if (oppose_prepare_gid) {
    set_has_oppose_prepare_gid();
    oppose_prepare_gid_ = oppose_prepare_gid;
  } else {
    clear_has_oppose_prepare_gid();
    oppose_prepare_gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated uint32 invaid_txs = 22;
inline int ZbftMessage::invaid_txs_size() const {
  return invaid_txs_.size();
}
inline void ZbftMessage::clear_invaid_txs() {
  invaid_txs_.Clear();
}
inline ::google::protobuf::uint32 ZbftMessage::invaid_txs(int index) const {
  return invaid_txs_.Get(index);
}
inline void ZbftMessage::set_invaid_txs(int index, ::google::protobuf::uint32 value) {
  invaid_txs_.Set(index, value);
}
inline void ZbftMessage::add_invaid_txs(::google::protobuf::uint32 value) {
  invaid_txs_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ZbftMessage::invaid_txs() const {
  return invaid_txs_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ZbftMessage::mutable_invaid_txs() {
  return &invaid_txs_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace zbft
}  // namespace zjchain

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fzbft_2eproto__INCLUDED
