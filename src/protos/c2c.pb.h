// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/c2c.proto

#ifndef PROTOBUF_protos_2fc2c_2eproto__INCLUDED
#define PROTOBUF_protos_2fc2c_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace zjchain {
namespace c2c {
namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_protos_2fc2c_2eproto();
void protobuf_AssignDesc_protos_2fc2c_2eproto();
void protobuf_ShutdownFile_protos_2fc2c_2eproto();

class OrderInfo;
class SellInfo;
class NewOrder;
class NewSell;
class BuyerReport;
class GetSell;
class C2cMessage;

enum Status {
  kDefault = 0,
  kConfirmed = 1,
  kReported = 2,
  kSellWaiting = 3,
  kSellValid = 4,
  kSellInvalid = 5,
  kSellReleased = 6,
  kSellExists = 7
};
bool Status_IsValid(int value);
const Status Status_MIN = kDefault;
const Status Status_MAX = kSellExists;
const int Status_ARRAYSIZE = Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_descriptor();
inline const ::std::string& Status_Name(Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_descriptor(), value);
}
inline bool Status_Parse(
    const ::std::string& name, Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
// ===================================================================

class OrderInfo : public ::google::protobuf::Message {
 public:
  OrderInfo();
  virtual ~OrderInfo();

  OrderInfo(const OrderInfo& from);

  inline OrderInfo& operator=(const OrderInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderInfo& default_instance();

  void Swap(OrderInfo* other);

  // implements Message ----------------------------------------------

  OrderInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderInfo& from);
  void MergeFrom(const OrderInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes buyer = 1;
  inline bool has_buyer() const;
  inline void clear_buyer();
  static const int kBuyerFieldNumber = 1;
  inline const ::std::string& buyer() const;
  inline void set_buyer(const ::std::string& value);
  inline void set_buyer(const char* value);
  inline void set_buyer(const void* value, size_t size);
  inline ::std::string* mutable_buyer();
  inline ::std::string* release_buyer();
  inline void set_allocated_buyer(::std::string* buyer);

  // optional .zjchain.c2c.protobuf.Status status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::zjchain::c2c::protobuf::Status status() const;
  inline void set_status(::zjchain::c2c::protobuf::Status value);

  // optional uint64 amount = 3;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 3;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.OrderInfo)
 private:
  inline void set_has_buyer();
  inline void clear_has_buyer();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_amount();
  inline void clear_has_amount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* buyer_;
  ::google::protobuf::uint64 amount_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fc2c_2eproto();
  friend void protobuf_AssignDesc_protos_2fc2c_2eproto();
  friend void protobuf_ShutdownFile_protos_2fc2c_2eproto();

  void InitAsDefaultInstance();
  static OrderInfo* default_instance_;
};
// -------------------------------------------------------------------

class SellInfo : public ::google::protobuf::Message {
 public:
  SellInfo();
  virtual ~SellInfo();

  SellInfo(const SellInfo& from);

  inline SellInfo& operator=(const SellInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SellInfo& default_instance();

  void Swap(SellInfo* other);

  // implements Message ----------------------------------------------

  SellInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SellInfo& from);
  void MergeFrom(const SellInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes protocol_addr = 1;
  inline bool has_protocol_addr() const;
  inline void clear_protocol_addr();
  static const int kProtocolAddrFieldNumber = 1;
  inline const ::std::string& protocol_addr() const;
  inline void set_protocol_addr(const ::std::string& value);
  inline void set_protocol_addr(const char* value);
  inline void set_protocol_addr(const void* value, size_t size);
  inline ::std::string* mutable_protocol_addr();
  inline ::std::string* release_protocol_addr();
  inline void set_allocated_protocol_addr(::std::string* protocol_addr);

  // optional bytes seller = 2;
  inline bool has_seller() const;
  inline void clear_seller();
  static const int kSellerFieldNumber = 2;
  inline const ::std::string& seller() const;
  inline void set_seller(const ::std::string& value);
  inline void set_seller(const char* value);
  inline void set_seller(const void* value, size_t size);
  inline ::std::string* mutable_seller();
  inline ::std::string* release_seller();
  inline void set_allocated_seller(::std::string* seller);

  // optional uint64 pledge_amount = 3;
  inline bool has_pledge_amount() const;
  inline void clear_pledge_amount();
  static const int kPledgeAmountFieldNumber = 3;
  inline ::google::protobuf::uint64 pledge_amount() const;
  inline void set_pledge_amount(::google::protobuf::uint64 value);

  // optional uint64 price = 4;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 4;
  inline ::google::protobuf::uint64 price() const;
  inline void set_price(::google::protobuf::uint64 value);

  // optional bytes receivable = 5;
  inline bool has_receivable() const;
  inline void clear_receivable();
  static const int kReceivableFieldNumber = 5;
  inline const ::std::string& receivable() const;
  inline void set_receivable(const ::std::string& value);
  inline void set_receivable(const char* value);
  inline void set_receivable(const void* value, size_t size);
  inline ::std::string* mutable_receivable();
  inline ::std::string* release_receivable();
  inline void set_allocated_receivable(::std::string* receivable);

  // optional bool manager_released = 6;
  inline bool has_manager_released() const;
  inline void clear_manager_released();
  static const int kManagerReleasedFieldNumber = 6;
  inline bool manager_released() const;
  inline void set_manager_released(bool value);

  // optional bool seller_released = 7;
  inline bool has_seller_released() const;
  inline void clear_seller_released();
  static const int kSellerReleasedFieldNumber = 7;
  inline bool seller_released() const;
  inline void set_seller_released(bool value);

  // optional .zjchain.c2c.protobuf.Status status = 8;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 8;
  inline ::zjchain::c2c::protobuf::Status status() const;
  inline void set_status(::zjchain::c2c::protobuf::Status value);

  // optional .zjchain.c2c.protobuf.OrderInfo order_info = 9;
  inline bool has_order_info() const;
  inline void clear_order_info();
  static const int kOrderInfoFieldNumber = 9;
  inline const ::zjchain::c2c::protobuf::OrderInfo& order_info() const;
  inline ::zjchain::c2c::protobuf::OrderInfo* mutable_order_info();
  inline ::zjchain::c2c::protobuf::OrderInfo* release_order_info();
  inline void set_allocated_order_info(::zjchain::c2c::protobuf::OrderInfo* order_info);

  // repeated bytes reports = 10;
  inline int reports_size() const;
  inline void clear_reports();
  static const int kReportsFieldNumber = 10;
  inline const ::std::string& reports(int index) const;
  inline ::std::string* mutable_reports(int index);
  inline void set_reports(int index, const ::std::string& value);
  inline void set_reports(int index, const char* value);
  inline void set_reports(int index, const void* value, size_t size);
  inline ::std::string* add_reports();
  inline void add_reports(const ::std::string& value);
  inline void add_reports(const char* value);
  inline void add_reports(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& reports() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_reports();

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.SellInfo)
 private:
  inline void set_has_protocol_addr();
  inline void clear_has_protocol_addr();
  inline void set_has_seller();
  inline void clear_has_seller();
  inline void set_has_pledge_amount();
  inline void clear_has_pledge_amount();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_receivable();
  inline void clear_has_receivable();
  inline void set_has_manager_released();
  inline void clear_has_manager_released();
  inline void set_has_seller_released();
  inline void clear_has_seller_released();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_order_info();
  inline void clear_has_order_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* protocol_addr_;
  ::std::string* seller_;
  ::google::protobuf::uint64 pledge_amount_;
  ::google::protobuf::uint64 price_;
  ::std::string* receivable_;
  bool manager_released_;
  bool seller_released_;
  int status_;
  ::zjchain::c2c::protobuf::OrderInfo* order_info_;
  ::google::protobuf::RepeatedPtrField< ::std::string> reports_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fc2c_2eproto();
  friend void protobuf_AssignDesc_protos_2fc2c_2eproto();
  friend void protobuf_ShutdownFile_protos_2fc2c_2eproto();

  void InitAsDefaultInstance();
  static SellInfo* default_instance_;
};
// -------------------------------------------------------------------

class NewOrder : public ::google::protobuf::Message {
 public:
  NewOrder();
  virtual ~NewOrder();

  NewOrder(const NewOrder& from);

  inline NewOrder& operator=(const NewOrder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewOrder& default_instance();

  void Swap(NewOrder* other);

  // implements Message ----------------------------------------------

  NewOrder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewOrder& from);
  void MergeFrom(const NewOrder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes seller = 1;
  inline bool has_seller() const;
  inline void clear_seller();
  static const int kSellerFieldNumber = 1;
  inline const ::std::string& seller() const;
  inline void set_seller(const ::std::string& value);
  inline void set_seller(const char* value);
  inline void set_seller(const void* value, size_t size);
  inline ::std::string* mutable_seller();
  inline ::std::string* release_seller();
  inline void set_allocated_seller(::std::string* seller);

  // optional uint64 amount = 2;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 2;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional bytes buyer = 3;
  inline bool has_buyer() const;
  inline void clear_buyer();
  static const int kBuyerFieldNumber = 3;
  inline const ::std::string& buyer() const;
  inline void set_buyer(const ::std::string& value);
  inline void set_buyer(const char* value);
  inline void set_buyer(const void* value, size_t size);
  inline ::std::string* mutable_buyer();
  inline ::std::string* release_buyer();
  inline void set_allocated_buyer(::std::string* buyer);

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.NewOrder)
 private:
  inline void set_has_seller();
  inline void clear_has_seller();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_buyer();
  inline void clear_has_buyer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* seller_;
  ::google::protobuf::uint64 amount_;
  ::std::string* buyer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fc2c_2eproto();
  friend void protobuf_AssignDesc_protos_2fc2c_2eproto();
  friend void protobuf_ShutdownFile_protos_2fc2c_2eproto();

  void InitAsDefaultInstance();
  static NewOrder* default_instance_;
};
// -------------------------------------------------------------------

class NewSell : public ::google::protobuf::Message {
 public:
  NewSell();
  virtual ~NewSell();

  NewSell(const NewSell& from);

  inline NewSell& operator=(const NewSell& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewSell& default_instance();

  void Swap(NewSell* other);

  // implements Message ----------------------------------------------

  NewSell* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewSell& from);
  void MergeFrom(const NewSell& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes protocol_addr = 1;
  inline bool has_protocol_addr() const;
  inline void clear_protocol_addr();
  static const int kProtocolAddrFieldNumber = 1;
  inline const ::std::string& protocol_addr() const;
  inline void set_protocol_addr(const ::std::string& value);
  inline void set_protocol_addr(const char* value);
  inline void set_protocol_addr(const void* value, size_t size);
  inline ::std::string* mutable_protocol_addr();
  inline ::std::string* release_protocol_addr();
  inline void set_allocated_protocol_addr(::std::string* protocol_addr);

  // optional bytes seller = 2;
  inline bool has_seller() const;
  inline void clear_seller();
  static const int kSellerFieldNumber = 2;
  inline const ::std::string& seller() const;
  inline void set_seller(const ::std::string& value);
  inline void set_seller(const char* value);
  inline void set_seller(const void* value, size_t size);
  inline ::std::string* mutable_seller();
  inline ::std::string* release_seller();
  inline void set_allocated_seller(::std::string* seller);

  // optional uint64 amount = 3;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 3;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional uint64 price = 4;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 4;
  inline ::google::protobuf::uint64 price() const;
  inline void set_price(::google::protobuf::uint64 value);

  // optional bytes receivable = 5;
  inline bool has_receivable() const;
  inline void clear_receivable();
  static const int kReceivableFieldNumber = 5;
  inline const ::std::string& receivable() const;
  inline void set_receivable(const ::std::string& value);
  inline void set_receivable(const char* value);
  inline void set_receivable(const void* value, size_t size);
  inline ::std::string* mutable_receivable();
  inline ::std::string* release_receivable();
  inline void set_allocated_receivable(::std::string* receivable);

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.NewSell)
 private:
  inline void set_has_protocol_addr();
  inline void clear_has_protocol_addr();
  inline void set_has_seller();
  inline void clear_has_seller();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_receivable();
  inline void clear_has_receivable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* protocol_addr_;
  ::std::string* seller_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint64 price_;
  ::std::string* receivable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fc2c_2eproto();
  friend void protobuf_AssignDesc_protos_2fc2c_2eproto();
  friend void protobuf_ShutdownFile_protos_2fc2c_2eproto();

  void InitAsDefaultInstance();
  static NewSell* default_instance_;
};
// -------------------------------------------------------------------

class BuyerReport : public ::google::protobuf::Message {
 public:
  BuyerReport();
  virtual ~BuyerReport();

  BuyerReport(const BuyerReport& from);

  inline BuyerReport& operator=(const BuyerReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuyerReport& default_instance();

  void Swap(BuyerReport* other);

  // implements Message ----------------------------------------------

  BuyerReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuyerReport& from);
  void MergeFrom(const BuyerReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes seller = 1;
  inline bool has_seller() const;
  inline void clear_seller();
  static const int kSellerFieldNumber = 1;
  inline const ::std::string& seller() const;
  inline void set_seller(const ::std::string& value);
  inline void set_seller(const char* value);
  inline void set_seller(const void* value, size_t size);
  inline ::std::string* mutable_seller();
  inline ::std::string* release_seller();
  inline void set_allocated_seller(::std::string* seller);

  // optional bytes reports_info = 2;
  inline bool has_reports_info() const;
  inline void clear_reports_info();
  static const int kReportsInfoFieldNumber = 2;
  inline const ::std::string& reports_info() const;
  inline void set_reports_info(const ::std::string& value);
  inline void set_reports_info(const char* value);
  inline void set_reports_info(const void* value, size_t size);
  inline ::std::string* mutable_reports_info();
  inline ::std::string* release_reports_info();
  inline void set_allocated_reports_info(::std::string* reports_info);

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.BuyerReport)
 private:
  inline void set_has_seller();
  inline void clear_has_seller();
  inline void set_has_reports_info();
  inline void clear_has_reports_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* seller_;
  ::std::string* reports_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fc2c_2eproto();
  friend void protobuf_AssignDesc_protos_2fc2c_2eproto();
  friend void protobuf_ShutdownFile_protos_2fc2c_2eproto();

  void InitAsDefaultInstance();
  static BuyerReport* default_instance_;
};
// -------------------------------------------------------------------

class GetSell : public ::google::protobuf::Message {
 public:
  GetSell();
  virtual ~GetSell();

  GetSell(const GetSell& from);

  inline GetSell& operator=(const GetSell& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSell& default_instance();

  void Swap(GetSell* other);

  // implements Message ----------------------------------------------

  GetSell* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSell& from);
  void MergeFrom(const GetSell& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes seller = 1;
  inline bool has_seller() const;
  inline void clear_seller();
  static const int kSellerFieldNumber = 1;
  inline const ::std::string& seller() const;
  inline void set_seller(const ::std::string& value);
  inline void set_seller(const char* value);
  inline void set_seller(const void* value, size_t size);
  inline ::std::string* mutable_seller();
  inline ::std::string* release_seller();
  inline void set_allocated_seller(::std::string* seller);

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.GetSell)
 private:
  inline void set_has_seller();
  inline void clear_has_seller();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* seller_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fc2c_2eproto();
  friend void protobuf_AssignDesc_protos_2fc2c_2eproto();
  friend void protobuf_ShutdownFile_protos_2fc2c_2eproto();

  void InitAsDefaultInstance();
  static GetSell* default_instance_;
};
// -------------------------------------------------------------------

class C2cMessage : public ::google::protobuf::Message {
 public:
  C2cMessage();
  virtual ~C2cMessage();

  C2cMessage(const C2cMessage& from);

  inline C2cMessage& operator=(const C2cMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const C2cMessage& default_instance();

  void Swap(C2cMessage* other);

  // implements Message ----------------------------------------------

  C2cMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2cMessage& from);
  void MergeFrom(const C2cMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .zjchain.c2c.protobuf.NewSell sell = 1;
  inline bool has_sell() const;
  inline void clear_sell();
  static const int kSellFieldNumber = 1;
  inline const ::zjchain::c2c::protobuf::NewSell& sell() const;
  inline ::zjchain::c2c::protobuf::NewSell* mutable_sell();
  inline ::zjchain::c2c::protobuf::NewSell* release_sell();
  inline void set_allocated_sell(::zjchain::c2c::protobuf::NewSell* sell);

  // optional .zjchain.c2c.protobuf.NewOrder order = 2;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 2;
  inline const ::zjchain::c2c::protobuf::NewOrder& order() const;
  inline ::zjchain::c2c::protobuf::NewOrder* mutable_order();
  inline ::zjchain::c2c::protobuf::NewOrder* release_order();
  inline void set_allocated_order(::zjchain::c2c::protobuf::NewOrder* order);

  // optional .zjchain.c2c.protobuf.BuyerReport report = 3;
  inline bool has_report() const;
  inline void clear_report();
  static const int kReportFieldNumber = 3;
  inline const ::zjchain::c2c::protobuf::BuyerReport& report() const;
  inline ::zjchain::c2c::protobuf::BuyerReport* mutable_report();
  inline ::zjchain::c2c::protobuf::BuyerReport* release_report();
  inline void set_allocated_report(::zjchain::c2c::protobuf::BuyerReport* report);

  // repeated .zjchain.c2c.protobuf.SellInfo sells = 4;
  inline int sells_size() const;
  inline void clear_sells();
  static const int kSellsFieldNumber = 4;
  inline const ::zjchain::c2c::protobuf::SellInfo& sells(int index) const;
  inline ::zjchain::c2c::protobuf::SellInfo* mutable_sells(int index);
  inline ::zjchain::c2c::protobuf::SellInfo* add_sells();
  inline const ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::SellInfo >&
      sells() const;
  inline ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::SellInfo >*
      mutable_sells();

  // repeated .zjchain.c2c.protobuf.GetSell get_sell = 5;
  inline int get_sell_size() const;
  inline void clear_get_sell();
  static const int kGetSellFieldNumber = 5;
  inline const ::zjchain::c2c::protobuf::GetSell& get_sell(int index) const;
  inline ::zjchain::c2c::protobuf::GetSell* mutable_get_sell(int index);
  inline ::zjchain::c2c::protobuf::GetSell* add_get_sell();
  inline const ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::GetSell >&
      get_sell() const;
  inline ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::GetSell >*
      mutable_get_sell();

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.C2cMessage)
 private:
  inline void set_has_sell();
  inline void clear_has_sell();
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_report();
  inline void clear_has_report();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::zjchain::c2c::protobuf::NewSell* sell_;
  ::zjchain::c2c::protobuf::NewOrder* order_;
  ::zjchain::c2c::protobuf::BuyerReport* report_;
  ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::SellInfo > sells_;
  ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::GetSell > get_sell_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_protos_2fc2c_2eproto();
  friend void protobuf_AssignDesc_protos_2fc2c_2eproto();
  friend void protobuf_ShutdownFile_protos_2fc2c_2eproto();

  void InitAsDefaultInstance();
  static C2cMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// OrderInfo

// optional bytes buyer = 1;
inline bool OrderInfo::has_buyer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderInfo::set_has_buyer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderInfo::clear_has_buyer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderInfo::clear_buyer() {
  if (buyer_ != &::google::protobuf::internal::kEmptyString) {
    buyer_->clear();
  }
  clear_has_buyer();
}
inline const ::std::string& OrderInfo::buyer() const {
  return *buyer_;
}
inline void OrderInfo::set_buyer(const ::std::string& value) {
  set_has_buyer();
  if (buyer_ == &::google::protobuf::internal::kEmptyString) {
    buyer_ = new ::std::string;
  }
  buyer_->assign(value);
}
inline void OrderInfo::set_buyer(const char* value) {
  set_has_buyer();
  if (buyer_ == &::google::protobuf::internal::kEmptyString) {
    buyer_ = new ::std::string;
  }
  buyer_->assign(value);
}
inline void OrderInfo::set_buyer(const void* value, size_t size) {
  set_has_buyer();
  if (buyer_ == &::google::protobuf::internal::kEmptyString) {
    buyer_ = new ::std::string;
  }
  buyer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderInfo::mutable_buyer() {
  set_has_buyer();
  if (buyer_ == &::google::protobuf::internal::kEmptyString) {
    buyer_ = new ::std::string;
  }
  return buyer_;
}
inline ::std::string* OrderInfo::release_buyer() {
  clear_has_buyer();
  if (buyer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyer_;
    buyer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderInfo::set_allocated_buyer(::std::string* buyer) {
  if (buyer_ != &::google::protobuf::internal::kEmptyString) {
    delete buyer_;
  }
  if (buyer) {
    set_has_buyer();
    buyer_ = buyer;
  } else {
    clear_has_buyer();
    buyer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .zjchain.c2c.protobuf.Status status = 2;
inline bool OrderInfo::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderInfo::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderInfo::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::zjchain::c2c::protobuf::Status OrderInfo::status() const {
  return static_cast< ::zjchain::c2c::protobuf::Status >(status_);
}
inline void OrderInfo::set_status(::zjchain::c2c::protobuf::Status value) {
  assert(::zjchain::c2c::protobuf::Status_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional uint64 amount = 3;
inline bool OrderInfo::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderInfo::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderInfo::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderInfo::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 OrderInfo::amount() const {
  return amount_;
}
inline void OrderInfo::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// -------------------------------------------------------------------

// SellInfo

// optional bytes protocol_addr = 1;
inline bool SellInfo::has_protocol_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SellInfo::set_has_protocol_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SellInfo::clear_has_protocol_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SellInfo::clear_protocol_addr() {
  if (protocol_addr_ != &::google::protobuf::internal::kEmptyString) {
    protocol_addr_->clear();
  }
  clear_has_protocol_addr();
}
inline const ::std::string& SellInfo::protocol_addr() const {
  return *protocol_addr_;
}
inline void SellInfo::set_protocol_addr(const ::std::string& value) {
  set_has_protocol_addr();
  if (protocol_addr_ == &::google::protobuf::internal::kEmptyString) {
    protocol_addr_ = new ::std::string;
  }
  protocol_addr_->assign(value);
}
inline void SellInfo::set_protocol_addr(const char* value) {
  set_has_protocol_addr();
  if (protocol_addr_ == &::google::protobuf::internal::kEmptyString) {
    protocol_addr_ = new ::std::string;
  }
  protocol_addr_->assign(value);
}
inline void SellInfo::set_protocol_addr(const void* value, size_t size) {
  set_has_protocol_addr();
  if (protocol_addr_ == &::google::protobuf::internal::kEmptyString) {
    protocol_addr_ = new ::std::string;
  }
  protocol_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SellInfo::mutable_protocol_addr() {
  set_has_protocol_addr();
  if (protocol_addr_ == &::google::protobuf::internal::kEmptyString) {
    protocol_addr_ = new ::std::string;
  }
  return protocol_addr_;
}
inline ::std::string* SellInfo::release_protocol_addr() {
  clear_has_protocol_addr();
  if (protocol_addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = protocol_addr_;
    protocol_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SellInfo::set_allocated_protocol_addr(::std::string* protocol_addr) {
  if (protocol_addr_ != &::google::protobuf::internal::kEmptyString) {
    delete protocol_addr_;
  }
  if (protocol_addr) {
    set_has_protocol_addr();
    protocol_addr_ = protocol_addr;
  } else {
    clear_has_protocol_addr();
    protocol_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes seller = 2;
inline bool SellInfo::has_seller() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SellInfo::set_has_seller() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SellInfo::clear_has_seller() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SellInfo::clear_seller() {
  if (seller_ != &::google::protobuf::internal::kEmptyString) {
    seller_->clear();
  }
  clear_has_seller();
}
inline const ::std::string& SellInfo::seller() const {
  return *seller_;
}
inline void SellInfo::set_seller(const ::std::string& value) {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  seller_->assign(value);
}
inline void SellInfo::set_seller(const char* value) {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  seller_->assign(value);
}
inline void SellInfo::set_seller(const void* value, size_t size) {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  seller_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SellInfo::mutable_seller() {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  return seller_;
}
inline ::std::string* SellInfo::release_seller() {
  clear_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seller_;
    seller_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SellInfo::set_allocated_seller(::std::string* seller) {
  if (seller_ != &::google::protobuf::internal::kEmptyString) {
    delete seller_;
  }
  if (seller) {
    set_has_seller();
    seller_ = seller;
  } else {
    clear_has_seller();
    seller_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 pledge_amount = 3;
inline bool SellInfo::has_pledge_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SellInfo::set_has_pledge_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SellInfo::clear_has_pledge_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SellInfo::clear_pledge_amount() {
  pledge_amount_ = GOOGLE_ULONGLONG(0);
  clear_has_pledge_amount();
}
inline ::google::protobuf::uint64 SellInfo::pledge_amount() const {
  return pledge_amount_;
}
inline void SellInfo::set_pledge_amount(::google::protobuf::uint64 value) {
  set_has_pledge_amount();
  pledge_amount_ = value;
}

// optional uint64 price = 4;
inline bool SellInfo::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SellInfo::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SellInfo::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SellInfo::clear_price() {
  price_ = GOOGLE_ULONGLONG(0);
  clear_has_price();
}
inline ::google::protobuf::uint64 SellInfo::price() const {
  return price_;
}
inline void SellInfo::set_price(::google::protobuf::uint64 value) {
  set_has_price();
  price_ = value;
}

// optional bytes receivable = 5;
inline bool SellInfo::has_receivable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SellInfo::set_has_receivable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SellInfo::clear_has_receivable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SellInfo::clear_receivable() {
  if (receivable_ != &::google::protobuf::internal::kEmptyString) {
    receivable_->clear();
  }
  clear_has_receivable();
}
inline const ::std::string& SellInfo::receivable() const {
  return *receivable_;
}
inline void SellInfo::set_receivable(const ::std::string& value) {
  set_has_receivable();
  if (receivable_ == &::google::protobuf::internal::kEmptyString) {
    receivable_ = new ::std::string;
  }
  receivable_->assign(value);
}
inline void SellInfo::set_receivable(const char* value) {
  set_has_receivable();
  if (receivable_ == &::google::protobuf::internal::kEmptyString) {
    receivable_ = new ::std::string;
  }
  receivable_->assign(value);
}
inline void SellInfo::set_receivable(const void* value, size_t size) {
  set_has_receivable();
  if (receivable_ == &::google::protobuf::internal::kEmptyString) {
    receivable_ = new ::std::string;
  }
  receivable_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SellInfo::mutable_receivable() {
  set_has_receivable();
  if (receivable_ == &::google::protobuf::internal::kEmptyString) {
    receivable_ = new ::std::string;
  }
  return receivable_;
}
inline ::std::string* SellInfo::release_receivable() {
  clear_has_receivable();
  if (receivable_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = receivable_;
    receivable_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SellInfo::set_allocated_receivable(::std::string* receivable) {
  if (receivable_ != &::google::protobuf::internal::kEmptyString) {
    delete receivable_;
  }
  if (receivable) {
    set_has_receivable();
    receivable_ = receivable;
  } else {
    clear_has_receivable();
    receivable_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool manager_released = 6;
inline bool SellInfo::has_manager_released() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SellInfo::set_has_manager_released() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SellInfo::clear_has_manager_released() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SellInfo::clear_manager_released() {
  manager_released_ = false;
  clear_has_manager_released();
}
inline bool SellInfo::manager_released() const {
  return manager_released_;
}
inline void SellInfo::set_manager_released(bool value) {
  set_has_manager_released();
  manager_released_ = value;
}

// optional bool seller_released = 7;
inline bool SellInfo::has_seller_released() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SellInfo::set_has_seller_released() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SellInfo::clear_has_seller_released() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SellInfo::clear_seller_released() {
  seller_released_ = false;
  clear_has_seller_released();
}
inline bool SellInfo::seller_released() const {
  return seller_released_;
}
inline void SellInfo::set_seller_released(bool value) {
  set_has_seller_released();
  seller_released_ = value;
}

// optional .zjchain.c2c.protobuf.Status status = 8;
inline bool SellInfo::has_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SellInfo::set_has_status() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SellInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SellInfo::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::zjchain::c2c::protobuf::Status SellInfo::status() const {
  return static_cast< ::zjchain::c2c::protobuf::Status >(status_);
}
inline void SellInfo::set_status(::zjchain::c2c::protobuf::Status value) {
  assert(::zjchain::c2c::protobuf::Status_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional .zjchain.c2c.protobuf.OrderInfo order_info = 9;
inline bool SellInfo::has_order_info() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SellInfo::set_has_order_info() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SellInfo::clear_has_order_info() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SellInfo::clear_order_info() {
  if (order_info_ != NULL) order_info_->::zjchain::c2c::protobuf::OrderInfo::Clear();
  clear_has_order_info();
}
inline const ::zjchain::c2c::protobuf::OrderInfo& SellInfo::order_info() const {
  return order_info_ != NULL ? *order_info_ : *default_instance_->order_info_;
}
inline ::zjchain::c2c::protobuf::OrderInfo* SellInfo::mutable_order_info() {
  set_has_order_info();
  if (order_info_ == NULL) order_info_ = new ::zjchain::c2c::protobuf::OrderInfo;
  return order_info_;
}
inline ::zjchain::c2c::protobuf::OrderInfo* SellInfo::release_order_info() {
  clear_has_order_info();
  ::zjchain::c2c::protobuf::OrderInfo* temp = order_info_;
  order_info_ = NULL;
  return temp;
}
inline void SellInfo::set_allocated_order_info(::zjchain::c2c::protobuf::OrderInfo* order_info) {
  delete order_info_;
  order_info_ = order_info;
  if (order_info) {
    set_has_order_info();
  } else {
    clear_has_order_info();
  }
}

// repeated bytes reports = 10;
inline int SellInfo::reports_size() const {
  return reports_.size();
}
inline void SellInfo::clear_reports() {
  reports_.Clear();
}
inline const ::std::string& SellInfo::reports(int index) const {
  return reports_.Get(index);
}
inline ::std::string* SellInfo::mutable_reports(int index) {
  return reports_.Mutable(index);
}
inline void SellInfo::set_reports(int index, const ::std::string& value) {
  reports_.Mutable(index)->assign(value);
}
inline void SellInfo::set_reports(int index, const char* value) {
  reports_.Mutable(index)->assign(value);
}
inline void SellInfo::set_reports(int index, const void* value, size_t size) {
  reports_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SellInfo::add_reports() {
  return reports_.Add();
}
inline void SellInfo::add_reports(const ::std::string& value) {
  reports_.Add()->assign(value);
}
inline void SellInfo::add_reports(const char* value) {
  reports_.Add()->assign(value);
}
inline void SellInfo::add_reports(const void* value, size_t size) {
  reports_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SellInfo::reports() const {
  return reports_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SellInfo::mutable_reports() {
  return &reports_;
}

// -------------------------------------------------------------------

// NewOrder

// optional bytes seller = 1;
inline bool NewOrder::has_seller() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewOrder::set_has_seller() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewOrder::clear_has_seller() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewOrder::clear_seller() {
  if (seller_ != &::google::protobuf::internal::kEmptyString) {
    seller_->clear();
  }
  clear_has_seller();
}
inline const ::std::string& NewOrder::seller() const {
  return *seller_;
}
inline void NewOrder::set_seller(const ::std::string& value) {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  seller_->assign(value);
}
inline void NewOrder::set_seller(const char* value) {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  seller_->assign(value);
}
inline void NewOrder::set_seller(const void* value, size_t size) {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  seller_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewOrder::mutable_seller() {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  return seller_;
}
inline ::std::string* NewOrder::release_seller() {
  clear_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seller_;
    seller_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewOrder::set_allocated_seller(::std::string* seller) {
  if (seller_ != &::google::protobuf::internal::kEmptyString) {
    delete seller_;
  }
  if (seller) {
    set_has_seller();
    seller_ = seller;
  } else {
    clear_has_seller();
    seller_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 2;
inline bool NewOrder::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewOrder::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewOrder::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewOrder::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 NewOrder::amount() const {
  return amount_;
}
inline void NewOrder::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional bytes buyer = 3;
inline bool NewOrder::has_buyer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewOrder::set_has_buyer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewOrder::clear_has_buyer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewOrder::clear_buyer() {
  if (buyer_ != &::google::protobuf::internal::kEmptyString) {
    buyer_->clear();
  }
  clear_has_buyer();
}
inline const ::std::string& NewOrder::buyer() const {
  return *buyer_;
}
inline void NewOrder::set_buyer(const ::std::string& value) {
  set_has_buyer();
  if (buyer_ == &::google::protobuf::internal::kEmptyString) {
    buyer_ = new ::std::string;
  }
  buyer_->assign(value);
}
inline void NewOrder::set_buyer(const char* value) {
  set_has_buyer();
  if (buyer_ == &::google::protobuf::internal::kEmptyString) {
    buyer_ = new ::std::string;
  }
  buyer_->assign(value);
}
inline void NewOrder::set_buyer(const void* value, size_t size) {
  set_has_buyer();
  if (buyer_ == &::google::protobuf::internal::kEmptyString) {
    buyer_ = new ::std::string;
  }
  buyer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewOrder::mutable_buyer() {
  set_has_buyer();
  if (buyer_ == &::google::protobuf::internal::kEmptyString) {
    buyer_ = new ::std::string;
  }
  return buyer_;
}
inline ::std::string* NewOrder::release_buyer() {
  clear_has_buyer();
  if (buyer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyer_;
    buyer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewOrder::set_allocated_buyer(::std::string* buyer) {
  if (buyer_ != &::google::protobuf::internal::kEmptyString) {
    delete buyer_;
  }
  if (buyer) {
    set_has_buyer();
    buyer_ = buyer;
  } else {
    clear_has_buyer();
    buyer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NewSell

// optional bytes protocol_addr = 1;
inline bool NewSell::has_protocol_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewSell::set_has_protocol_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewSell::clear_has_protocol_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewSell::clear_protocol_addr() {
  if (protocol_addr_ != &::google::protobuf::internal::kEmptyString) {
    protocol_addr_->clear();
  }
  clear_has_protocol_addr();
}
inline const ::std::string& NewSell::protocol_addr() const {
  return *protocol_addr_;
}
inline void NewSell::set_protocol_addr(const ::std::string& value) {
  set_has_protocol_addr();
  if (protocol_addr_ == &::google::protobuf::internal::kEmptyString) {
    protocol_addr_ = new ::std::string;
  }
  protocol_addr_->assign(value);
}
inline void NewSell::set_protocol_addr(const char* value) {
  set_has_protocol_addr();
  if (protocol_addr_ == &::google::protobuf::internal::kEmptyString) {
    protocol_addr_ = new ::std::string;
  }
  protocol_addr_->assign(value);
}
inline void NewSell::set_protocol_addr(const void* value, size_t size) {
  set_has_protocol_addr();
  if (protocol_addr_ == &::google::protobuf::internal::kEmptyString) {
    protocol_addr_ = new ::std::string;
  }
  protocol_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewSell::mutable_protocol_addr() {
  set_has_protocol_addr();
  if (protocol_addr_ == &::google::protobuf::internal::kEmptyString) {
    protocol_addr_ = new ::std::string;
  }
  return protocol_addr_;
}
inline ::std::string* NewSell::release_protocol_addr() {
  clear_has_protocol_addr();
  if (protocol_addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = protocol_addr_;
    protocol_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewSell::set_allocated_protocol_addr(::std::string* protocol_addr) {
  if (protocol_addr_ != &::google::protobuf::internal::kEmptyString) {
    delete protocol_addr_;
  }
  if (protocol_addr) {
    set_has_protocol_addr();
    protocol_addr_ = protocol_addr;
  } else {
    clear_has_protocol_addr();
    protocol_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes seller = 2;
inline bool NewSell::has_seller() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewSell::set_has_seller() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewSell::clear_has_seller() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewSell::clear_seller() {
  if (seller_ != &::google::protobuf::internal::kEmptyString) {
    seller_->clear();
  }
  clear_has_seller();
}
inline const ::std::string& NewSell::seller() const {
  return *seller_;
}
inline void NewSell::set_seller(const ::std::string& value) {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  seller_->assign(value);
}
inline void NewSell::set_seller(const char* value) {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  seller_->assign(value);
}
inline void NewSell::set_seller(const void* value, size_t size) {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  seller_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewSell::mutable_seller() {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  return seller_;
}
inline ::std::string* NewSell::release_seller() {
  clear_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seller_;
    seller_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewSell::set_allocated_seller(::std::string* seller) {
  if (seller_ != &::google::protobuf::internal::kEmptyString) {
    delete seller_;
  }
  if (seller) {
    set_has_seller();
    seller_ = seller;
  } else {
    clear_has_seller();
    seller_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 3;
inline bool NewSell::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewSell::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewSell::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewSell::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 NewSell::amount() const {
  return amount_;
}
inline void NewSell::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// optional uint64 price = 4;
inline bool NewSell::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewSell::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewSell::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewSell::clear_price() {
  price_ = GOOGLE_ULONGLONG(0);
  clear_has_price();
}
inline ::google::protobuf::uint64 NewSell::price() const {
  return price_;
}
inline void NewSell::set_price(::google::protobuf::uint64 value) {
  set_has_price();
  price_ = value;
}

// optional bytes receivable = 5;
inline bool NewSell::has_receivable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NewSell::set_has_receivable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NewSell::clear_has_receivable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NewSell::clear_receivable() {
  if (receivable_ != &::google::protobuf::internal::kEmptyString) {
    receivable_->clear();
  }
  clear_has_receivable();
}
inline const ::std::string& NewSell::receivable() const {
  return *receivable_;
}
inline void NewSell::set_receivable(const ::std::string& value) {
  set_has_receivable();
  if (receivable_ == &::google::protobuf::internal::kEmptyString) {
    receivable_ = new ::std::string;
  }
  receivable_->assign(value);
}
inline void NewSell::set_receivable(const char* value) {
  set_has_receivable();
  if (receivable_ == &::google::protobuf::internal::kEmptyString) {
    receivable_ = new ::std::string;
  }
  receivable_->assign(value);
}
inline void NewSell::set_receivable(const void* value, size_t size) {
  set_has_receivable();
  if (receivable_ == &::google::protobuf::internal::kEmptyString) {
    receivable_ = new ::std::string;
  }
  receivable_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewSell::mutable_receivable() {
  set_has_receivable();
  if (receivable_ == &::google::protobuf::internal::kEmptyString) {
    receivable_ = new ::std::string;
  }
  return receivable_;
}
inline ::std::string* NewSell::release_receivable() {
  clear_has_receivable();
  if (receivable_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = receivable_;
    receivable_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewSell::set_allocated_receivable(::std::string* receivable) {
  if (receivable_ != &::google::protobuf::internal::kEmptyString) {
    delete receivable_;
  }
  if (receivable) {
    set_has_receivable();
    receivable_ = receivable;
  } else {
    clear_has_receivable();
    receivable_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BuyerReport

// optional bytes seller = 1;
inline bool BuyerReport::has_seller() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuyerReport::set_has_seller() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuyerReport::clear_has_seller() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuyerReport::clear_seller() {
  if (seller_ != &::google::protobuf::internal::kEmptyString) {
    seller_->clear();
  }
  clear_has_seller();
}
inline const ::std::string& BuyerReport::seller() const {
  return *seller_;
}
inline void BuyerReport::set_seller(const ::std::string& value) {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  seller_->assign(value);
}
inline void BuyerReport::set_seller(const char* value) {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  seller_->assign(value);
}
inline void BuyerReport::set_seller(const void* value, size_t size) {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  seller_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuyerReport::mutable_seller() {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  return seller_;
}
inline ::std::string* BuyerReport::release_seller() {
  clear_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seller_;
    seller_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuyerReport::set_allocated_seller(::std::string* seller) {
  if (seller_ != &::google::protobuf::internal::kEmptyString) {
    delete seller_;
  }
  if (seller) {
    set_has_seller();
    seller_ = seller;
  } else {
    clear_has_seller();
    seller_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes reports_info = 2;
inline bool BuyerReport::has_reports_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuyerReport::set_has_reports_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuyerReport::clear_has_reports_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuyerReport::clear_reports_info() {
  if (reports_info_ != &::google::protobuf::internal::kEmptyString) {
    reports_info_->clear();
  }
  clear_has_reports_info();
}
inline const ::std::string& BuyerReport::reports_info() const {
  return *reports_info_;
}
inline void BuyerReport::set_reports_info(const ::std::string& value) {
  set_has_reports_info();
  if (reports_info_ == &::google::protobuf::internal::kEmptyString) {
    reports_info_ = new ::std::string;
  }
  reports_info_->assign(value);
}
inline void BuyerReport::set_reports_info(const char* value) {
  set_has_reports_info();
  if (reports_info_ == &::google::protobuf::internal::kEmptyString) {
    reports_info_ = new ::std::string;
  }
  reports_info_->assign(value);
}
inline void BuyerReport::set_reports_info(const void* value, size_t size) {
  set_has_reports_info();
  if (reports_info_ == &::google::protobuf::internal::kEmptyString) {
    reports_info_ = new ::std::string;
  }
  reports_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuyerReport::mutable_reports_info() {
  set_has_reports_info();
  if (reports_info_ == &::google::protobuf::internal::kEmptyString) {
    reports_info_ = new ::std::string;
  }
  return reports_info_;
}
inline ::std::string* BuyerReport::release_reports_info() {
  clear_has_reports_info();
  if (reports_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reports_info_;
    reports_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuyerReport::set_allocated_reports_info(::std::string* reports_info) {
  if (reports_info_ != &::google::protobuf::internal::kEmptyString) {
    delete reports_info_;
  }
  if (reports_info) {
    set_has_reports_info();
    reports_info_ = reports_info;
  } else {
    clear_has_reports_info();
    reports_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetSell

// optional bytes seller = 1;
inline bool GetSell::has_seller() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSell::set_has_seller() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSell::clear_has_seller() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSell::clear_seller() {
  if (seller_ != &::google::protobuf::internal::kEmptyString) {
    seller_->clear();
  }
  clear_has_seller();
}
inline const ::std::string& GetSell::seller() const {
  return *seller_;
}
inline void GetSell::set_seller(const ::std::string& value) {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  seller_->assign(value);
}
inline void GetSell::set_seller(const char* value) {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  seller_->assign(value);
}
inline void GetSell::set_seller(const void* value, size_t size) {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  seller_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetSell::mutable_seller() {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  return seller_;
}
inline ::std::string* GetSell::release_seller() {
  clear_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seller_;
    seller_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetSell::set_allocated_seller(::std::string* seller) {
  if (seller_ != &::google::protobuf::internal::kEmptyString) {
    delete seller_;
  }
  if (seller) {
    set_has_seller();
    seller_ = seller;
  } else {
    clear_has_seller();
    seller_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// C2cMessage

// optional .zjchain.c2c.protobuf.NewSell sell = 1;
inline bool C2cMessage::has_sell() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2cMessage::set_has_sell() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2cMessage::clear_has_sell() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2cMessage::clear_sell() {
  if (sell_ != NULL) sell_->::zjchain::c2c::protobuf::NewSell::Clear();
  clear_has_sell();
}
inline const ::zjchain::c2c::protobuf::NewSell& C2cMessage::sell() const {
  return sell_ != NULL ? *sell_ : *default_instance_->sell_;
}
inline ::zjchain::c2c::protobuf::NewSell* C2cMessage::mutable_sell() {
  set_has_sell();
  if (sell_ == NULL) sell_ = new ::zjchain::c2c::protobuf::NewSell;
  return sell_;
}
inline ::zjchain::c2c::protobuf::NewSell* C2cMessage::release_sell() {
  clear_has_sell();
  ::zjchain::c2c::protobuf::NewSell* temp = sell_;
  sell_ = NULL;
  return temp;
}
inline void C2cMessage::set_allocated_sell(::zjchain::c2c::protobuf::NewSell* sell) {
  delete sell_;
  sell_ = sell;
  if (sell) {
    set_has_sell();
  } else {
    clear_has_sell();
  }
}

// optional .zjchain.c2c.protobuf.NewOrder order = 2;
inline bool C2cMessage::has_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2cMessage::set_has_order() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2cMessage::clear_has_order() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2cMessage::clear_order() {
  if (order_ != NULL) order_->::zjchain::c2c::protobuf::NewOrder::Clear();
  clear_has_order();
}
inline const ::zjchain::c2c::protobuf::NewOrder& C2cMessage::order() const {
  return order_ != NULL ? *order_ : *default_instance_->order_;
}
inline ::zjchain::c2c::protobuf::NewOrder* C2cMessage::mutable_order() {
  set_has_order();
  if (order_ == NULL) order_ = new ::zjchain::c2c::protobuf::NewOrder;
  return order_;
}
inline ::zjchain::c2c::protobuf::NewOrder* C2cMessage::release_order() {
  clear_has_order();
  ::zjchain::c2c::protobuf::NewOrder* temp = order_;
  order_ = NULL;
  return temp;
}
inline void C2cMessage::set_allocated_order(::zjchain::c2c::protobuf::NewOrder* order) {
  delete order_;
  order_ = order;
  if (order) {
    set_has_order();
  } else {
    clear_has_order();
  }
}

// optional .zjchain.c2c.protobuf.BuyerReport report = 3;
inline bool C2cMessage::has_report() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void C2cMessage::set_has_report() {
  _has_bits_[0] |= 0x00000004u;
}
inline void C2cMessage::clear_has_report() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void C2cMessage::clear_report() {
  if (report_ != NULL) report_->::zjchain::c2c::protobuf::BuyerReport::Clear();
  clear_has_report();
}
inline const ::zjchain::c2c::protobuf::BuyerReport& C2cMessage::report() const {
  return report_ != NULL ? *report_ : *default_instance_->report_;
}
inline ::zjchain::c2c::protobuf::BuyerReport* C2cMessage::mutable_report() {
  set_has_report();
  if (report_ == NULL) report_ = new ::zjchain::c2c::protobuf::BuyerReport;
  return report_;
}
inline ::zjchain::c2c::protobuf::BuyerReport* C2cMessage::release_report() {
  clear_has_report();
  ::zjchain::c2c::protobuf::BuyerReport* temp = report_;
  report_ = NULL;
  return temp;
}
inline void C2cMessage::set_allocated_report(::zjchain::c2c::protobuf::BuyerReport* report) {
  delete report_;
  report_ = report;
  if (report) {
    set_has_report();
  } else {
    clear_has_report();
  }
}

// repeated .zjchain.c2c.protobuf.SellInfo sells = 4;
inline int C2cMessage::sells_size() const {
  return sells_.size();
}
inline void C2cMessage::clear_sells() {
  sells_.Clear();
}
inline const ::zjchain::c2c::protobuf::SellInfo& C2cMessage::sells(int index) const {
  return sells_.Get(index);
}
inline ::zjchain::c2c::protobuf::SellInfo* C2cMessage::mutable_sells(int index) {
  return sells_.Mutable(index);
}
inline ::zjchain::c2c::protobuf::SellInfo* C2cMessage::add_sells() {
  return sells_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::SellInfo >&
C2cMessage::sells() const {
  return sells_;
}
inline ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::SellInfo >*
C2cMessage::mutable_sells() {
  return &sells_;
}

// repeated .zjchain.c2c.protobuf.GetSell get_sell = 5;
inline int C2cMessage::get_sell_size() const {
  return get_sell_.size();
}
inline void C2cMessage::clear_get_sell() {
  get_sell_.Clear();
}
inline const ::zjchain::c2c::protobuf::GetSell& C2cMessage::get_sell(int index) const {
  return get_sell_.Get(index);
}
inline ::zjchain::c2c::protobuf::GetSell* C2cMessage::mutable_get_sell(int index) {
  return get_sell_.Mutable(index);
}
inline ::zjchain::c2c::protobuf::GetSell* C2cMessage::add_get_sell() {
  return get_sell_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::GetSell >&
C2cMessage::get_sell() const {
  return get_sell_;
}
inline ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::GetSell >*
C2cMessage::mutable_get_sell() {
  return &get_sell_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace c2c
}  // namespace zjchain

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zjchain::c2c::protobuf::Status>() {
  return ::zjchain::c2c::protobuf::Status_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fc2c_2eproto__INCLUDED
