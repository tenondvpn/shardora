// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/c2c.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protos_2fc2c_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protos_2fc2c_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protos_2fc2c_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fc2c_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protos_2fc2c_2eproto;
namespace zjchain {
namespace c2c {
namespace protobuf {
class BuyerReport;
struct BuyerReportDefaultTypeInternal;
extern BuyerReportDefaultTypeInternal _BuyerReport_default_instance_;
class C2cMessage;
struct C2cMessageDefaultTypeInternal;
extern C2cMessageDefaultTypeInternal _C2cMessage_default_instance_;
class GetSell;
struct GetSellDefaultTypeInternal;
extern GetSellDefaultTypeInternal _GetSell_default_instance_;
class NewOrder;
struct NewOrderDefaultTypeInternal;
extern NewOrderDefaultTypeInternal _NewOrder_default_instance_;
class NewSell;
struct NewSellDefaultTypeInternal;
extern NewSellDefaultTypeInternal _NewSell_default_instance_;
class OrderInfo;
struct OrderInfoDefaultTypeInternal;
extern OrderInfoDefaultTypeInternal _OrderInfo_default_instance_;
class SellInfo;
struct SellInfoDefaultTypeInternal;
extern SellInfoDefaultTypeInternal _SellInfo_default_instance_;
}  // namespace protobuf
}  // namespace c2c
}  // namespace zjchain
PROTOBUF_NAMESPACE_OPEN
template<> ::zjchain::c2c::protobuf::BuyerReport* Arena::CreateMaybeMessage<::zjchain::c2c::protobuf::BuyerReport>(Arena*);
template<> ::zjchain::c2c::protobuf::C2cMessage* Arena::CreateMaybeMessage<::zjchain::c2c::protobuf::C2cMessage>(Arena*);
template<> ::zjchain::c2c::protobuf::GetSell* Arena::CreateMaybeMessage<::zjchain::c2c::protobuf::GetSell>(Arena*);
template<> ::zjchain::c2c::protobuf::NewOrder* Arena::CreateMaybeMessage<::zjchain::c2c::protobuf::NewOrder>(Arena*);
template<> ::zjchain::c2c::protobuf::NewSell* Arena::CreateMaybeMessage<::zjchain::c2c::protobuf::NewSell>(Arena*);
template<> ::zjchain::c2c::protobuf::OrderInfo* Arena::CreateMaybeMessage<::zjchain::c2c::protobuf::OrderInfo>(Arena*);
template<> ::zjchain::c2c::protobuf::SellInfo* Arena::CreateMaybeMessage<::zjchain::c2c::protobuf::SellInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace zjchain {
namespace c2c {
namespace protobuf {

enum Status : int {
  kDefault = 0,
  kConfirmed = 1,
  kReported = 2,
  kSellWaiting = 3,
  kSellValid = 4,
  kSellInvalid = 5,
  kSellReleased = 6,
  kSellExists = 7
};
bool Status_IsValid(int value);
constexpr Status Status_MIN = kDefault;
constexpr Status Status_MAX = kSellExists;
constexpr int Status_ARRAYSIZE = Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Status_descriptor();
template<typename T>
inline const std::string& Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Status_descriptor(), enum_t_value);
}
inline bool Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
// ===================================================================

class OrderInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zjchain.c2c.protobuf.OrderInfo) */ {
 public:
  inline OrderInfo() : OrderInfo(nullptr) {}
  ~OrderInfo() override;
  explicit PROTOBUF_CONSTEXPR OrderInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderInfo(const OrderInfo& from);
  OrderInfo(OrderInfo&& from) noexcept
    : OrderInfo() {
    *this = ::std::move(from);
  }

  inline OrderInfo& operator=(const OrderInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderInfo& operator=(OrderInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderInfo* internal_default_instance() {
    return reinterpret_cast<const OrderInfo*>(
               &_OrderInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(OrderInfo& a, OrderInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OrderInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zjchain.c2c.protobuf.OrderInfo";
  }
  protected:
  explicit OrderInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuyerFieldNumber = 1,
    kAmountFieldNumber = 3,
    kStatusFieldNumber = 2,
  };
  // optional bytes buyer = 1;
  bool has_buyer() const;
  private:
  bool _internal_has_buyer() const;
  public:
  void clear_buyer();
  const std::string& buyer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buyer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buyer();
  PROTOBUF_NODISCARD std::string* release_buyer();
  void set_allocated_buyer(std::string* buyer);
  private:
  const std::string& _internal_buyer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buyer(const std::string& value);
  std::string* _internal_mutable_buyer();
  public:

  // optional uint64 amount = 3;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // optional .zjchain.c2c.protobuf.Status status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::zjchain::c2c::protobuf::Status status() const;
  void set_status(::zjchain::c2c::protobuf::Status value);
  private:
  ::zjchain::c2c::protobuf::Status _internal_status() const;
  void _internal_set_status(::zjchain::c2c::protobuf::Status value);
  public:

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.OrderInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buyer_;
  uint64_t amount_;
  int status_;
  friend struct ::TableStruct_protos_2fc2c_2eproto;
};
// -------------------------------------------------------------------

class SellInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zjchain.c2c.protobuf.SellInfo) */ {
 public:
  inline SellInfo() : SellInfo(nullptr) {}
  ~SellInfo() override;
  explicit PROTOBUF_CONSTEXPR SellInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SellInfo(const SellInfo& from);
  SellInfo(SellInfo&& from) noexcept
    : SellInfo() {
    *this = ::std::move(from);
  }

  inline SellInfo& operator=(const SellInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SellInfo& operator=(SellInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SellInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SellInfo* internal_default_instance() {
    return reinterpret_cast<const SellInfo*>(
               &_SellInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SellInfo& a, SellInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SellInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SellInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SellInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SellInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SellInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SellInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SellInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zjchain.c2c.protobuf.SellInfo";
  }
  protected:
  explicit SellInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReportsFieldNumber = 10,
    kProtocolAddrFieldNumber = 1,
    kSellerFieldNumber = 2,
    kReceivableFieldNumber = 5,
    kOrderInfoFieldNumber = 9,
    kPledgeAmountFieldNumber = 3,
    kPriceFieldNumber = 4,
    kManagerReleasedFieldNumber = 6,
    kSellerReleasedFieldNumber = 7,
    kStatusFieldNumber = 8,
  };
  // repeated bytes reports = 10;
  int reports_size() const;
  private:
  int _internal_reports_size() const;
  public:
  void clear_reports();
  const std::string& reports(int index) const;
  std::string* mutable_reports(int index);
  void set_reports(int index, const std::string& value);
  void set_reports(int index, std::string&& value);
  void set_reports(int index, const char* value);
  void set_reports(int index, const void* value, size_t size);
  std::string* add_reports();
  void add_reports(const std::string& value);
  void add_reports(std::string&& value);
  void add_reports(const char* value);
  void add_reports(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& reports() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_reports();
  private:
  const std::string& _internal_reports(int index) const;
  std::string* _internal_add_reports();
  public:

  // optional bytes protocol_addr = 1;
  bool has_protocol_addr() const;
  private:
  bool _internal_has_protocol_addr() const;
  public:
  void clear_protocol_addr();
  const std::string& protocol_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_protocol_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_protocol_addr();
  PROTOBUF_NODISCARD std::string* release_protocol_addr();
  void set_allocated_protocol_addr(std::string* protocol_addr);
  private:
  const std::string& _internal_protocol_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocol_addr(const std::string& value);
  std::string* _internal_mutable_protocol_addr();
  public:

  // optional bytes seller = 2;
  bool has_seller() const;
  private:
  bool _internal_has_seller() const;
  public:
  void clear_seller();
  const std::string& seller() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_seller(ArgT0&& arg0, ArgT... args);
  std::string* mutable_seller();
  PROTOBUF_NODISCARD std::string* release_seller();
  void set_allocated_seller(std::string* seller);
  private:
  const std::string& _internal_seller() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_seller(const std::string& value);
  std::string* _internal_mutable_seller();
  public:

  // optional bytes receivable = 5;
  bool has_receivable() const;
  private:
  bool _internal_has_receivable() const;
  public:
  void clear_receivable();
  const std::string& receivable() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receivable(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receivable();
  PROTOBUF_NODISCARD std::string* release_receivable();
  void set_allocated_receivable(std::string* receivable);
  private:
  const std::string& _internal_receivable() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receivable(const std::string& value);
  std::string* _internal_mutable_receivable();
  public:

  // optional .zjchain.c2c.protobuf.OrderInfo order_info = 9;
  bool has_order_info() const;
  private:
  bool _internal_has_order_info() const;
  public:
  void clear_order_info();
  const ::zjchain::c2c::protobuf::OrderInfo& order_info() const;
  PROTOBUF_NODISCARD ::zjchain::c2c::protobuf::OrderInfo* release_order_info();
  ::zjchain::c2c::protobuf::OrderInfo* mutable_order_info();
  void set_allocated_order_info(::zjchain::c2c::protobuf::OrderInfo* order_info);
  private:
  const ::zjchain::c2c::protobuf::OrderInfo& _internal_order_info() const;
  ::zjchain::c2c::protobuf::OrderInfo* _internal_mutable_order_info();
  public:
  void unsafe_arena_set_allocated_order_info(
      ::zjchain::c2c::protobuf::OrderInfo* order_info);
  ::zjchain::c2c::protobuf::OrderInfo* unsafe_arena_release_order_info();

  // optional uint64 pledge_amount = 3;
  bool has_pledge_amount() const;
  private:
  bool _internal_has_pledge_amount() const;
  public:
  void clear_pledge_amount();
  uint64_t pledge_amount() const;
  void set_pledge_amount(uint64_t value);
  private:
  uint64_t _internal_pledge_amount() const;
  void _internal_set_pledge_amount(uint64_t value);
  public:

  // optional uint64 price = 4;
  bool has_price() const;
  private:
  bool _internal_has_price() const;
  public:
  void clear_price();
  uint64_t price() const;
  void set_price(uint64_t value);
  private:
  uint64_t _internal_price() const;
  void _internal_set_price(uint64_t value);
  public:

  // optional bool manager_released = 6;
  bool has_manager_released() const;
  private:
  bool _internal_has_manager_released() const;
  public:
  void clear_manager_released();
  bool manager_released() const;
  void set_manager_released(bool value);
  private:
  bool _internal_manager_released() const;
  void _internal_set_manager_released(bool value);
  public:

  // optional bool seller_released = 7;
  bool has_seller_released() const;
  private:
  bool _internal_has_seller_released() const;
  public:
  void clear_seller_released();
  bool seller_released() const;
  void set_seller_released(bool value);
  private:
  bool _internal_seller_released() const;
  void _internal_set_seller_released(bool value);
  public:

  // optional .zjchain.c2c.protobuf.Status status = 8;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::zjchain::c2c::protobuf::Status status() const;
  void set_status(::zjchain::c2c::protobuf::Status value);
  private:
  ::zjchain::c2c::protobuf::Status _internal_status() const;
  void _internal_set_status(::zjchain::c2c::protobuf::Status value);
  public:

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.SellInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> reports_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protocol_addr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr seller_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receivable_;
  ::zjchain::c2c::protobuf::OrderInfo* order_info_;
  uint64_t pledge_amount_;
  uint64_t price_;
  bool manager_released_;
  bool seller_released_;
  int status_;
  friend struct ::TableStruct_protos_2fc2c_2eproto;
};
// -------------------------------------------------------------------

class NewOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zjchain.c2c.protobuf.NewOrder) */ {
 public:
  inline NewOrder() : NewOrder(nullptr) {}
  ~NewOrder() override;
  explicit PROTOBUF_CONSTEXPR NewOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewOrder(const NewOrder& from);
  NewOrder(NewOrder&& from) noexcept
    : NewOrder() {
    *this = ::std::move(from);
  }

  inline NewOrder& operator=(const NewOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewOrder& operator=(NewOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewOrder* internal_default_instance() {
    return reinterpret_cast<const NewOrder*>(
               &_NewOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NewOrder& a, NewOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(NewOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewOrder* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NewOrder& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zjchain.c2c.protobuf.NewOrder";
  }
  protected:
  explicit NewOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSellerFieldNumber = 1,
    kBuyerFieldNumber = 3,
    kAmountFieldNumber = 2,
  };
  // optional bytes seller = 1;
  bool has_seller() const;
  private:
  bool _internal_has_seller() const;
  public:
  void clear_seller();
  const std::string& seller() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_seller(ArgT0&& arg0, ArgT... args);
  std::string* mutable_seller();
  PROTOBUF_NODISCARD std::string* release_seller();
  void set_allocated_seller(std::string* seller);
  private:
  const std::string& _internal_seller() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_seller(const std::string& value);
  std::string* _internal_mutable_seller();
  public:

  // optional bytes buyer = 3;
  bool has_buyer() const;
  private:
  bool _internal_has_buyer() const;
  public:
  void clear_buyer();
  const std::string& buyer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buyer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buyer();
  PROTOBUF_NODISCARD std::string* release_buyer();
  void set_allocated_buyer(std::string* buyer);
  private:
  const std::string& _internal_buyer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buyer(const std::string& value);
  std::string* _internal_mutable_buyer();
  public:

  // optional uint64 amount = 2;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.NewOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr seller_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buyer_;
  uint64_t amount_;
  friend struct ::TableStruct_protos_2fc2c_2eproto;
};
// -------------------------------------------------------------------

class NewSell final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zjchain.c2c.protobuf.NewSell) */ {
 public:
  inline NewSell() : NewSell(nullptr) {}
  ~NewSell() override;
  explicit PROTOBUF_CONSTEXPR NewSell(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewSell(const NewSell& from);
  NewSell(NewSell&& from) noexcept
    : NewSell() {
    *this = ::std::move(from);
  }

  inline NewSell& operator=(const NewSell& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewSell& operator=(NewSell&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewSell& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewSell* internal_default_instance() {
    return reinterpret_cast<const NewSell*>(
               &_NewSell_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NewSell& a, NewSell& b) {
    a.Swap(&b);
  }
  inline void Swap(NewSell* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewSell* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewSell* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewSell>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewSell& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NewSell& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewSell* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zjchain.c2c.protobuf.NewSell";
  }
  protected:
  explicit NewSell(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProtocolAddrFieldNumber = 1,
    kSellerFieldNumber = 2,
    kReceivableFieldNumber = 5,
    kAmountFieldNumber = 3,
    kPriceFieldNumber = 4,
  };
  // optional bytes protocol_addr = 1;
  bool has_protocol_addr() const;
  private:
  bool _internal_has_protocol_addr() const;
  public:
  void clear_protocol_addr();
  const std::string& protocol_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_protocol_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_protocol_addr();
  PROTOBUF_NODISCARD std::string* release_protocol_addr();
  void set_allocated_protocol_addr(std::string* protocol_addr);
  private:
  const std::string& _internal_protocol_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocol_addr(const std::string& value);
  std::string* _internal_mutable_protocol_addr();
  public:

  // optional bytes seller = 2;
  bool has_seller() const;
  private:
  bool _internal_has_seller() const;
  public:
  void clear_seller();
  const std::string& seller() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_seller(ArgT0&& arg0, ArgT... args);
  std::string* mutable_seller();
  PROTOBUF_NODISCARD std::string* release_seller();
  void set_allocated_seller(std::string* seller);
  private:
  const std::string& _internal_seller() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_seller(const std::string& value);
  std::string* _internal_mutable_seller();
  public:

  // optional bytes receivable = 5;
  bool has_receivable() const;
  private:
  bool _internal_has_receivable() const;
  public:
  void clear_receivable();
  const std::string& receivable() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receivable(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receivable();
  PROTOBUF_NODISCARD std::string* release_receivable();
  void set_allocated_receivable(std::string* receivable);
  private:
  const std::string& _internal_receivable() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receivable(const std::string& value);
  std::string* _internal_mutable_receivable();
  public:

  // optional uint64 amount = 3;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // optional uint64 price = 4;
  bool has_price() const;
  private:
  bool _internal_has_price() const;
  public:
  void clear_price();
  uint64_t price() const;
  void set_price(uint64_t value);
  private:
  uint64_t _internal_price() const;
  void _internal_set_price(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.NewSell)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protocol_addr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr seller_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receivable_;
  uint64_t amount_;
  uint64_t price_;
  friend struct ::TableStruct_protos_2fc2c_2eproto;
};
// -------------------------------------------------------------------

class BuyerReport final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zjchain.c2c.protobuf.BuyerReport) */ {
 public:
  inline BuyerReport() : BuyerReport(nullptr) {}
  ~BuyerReport() override;
  explicit PROTOBUF_CONSTEXPR BuyerReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BuyerReport(const BuyerReport& from);
  BuyerReport(BuyerReport&& from) noexcept
    : BuyerReport() {
    *this = ::std::move(from);
  }

  inline BuyerReport& operator=(const BuyerReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuyerReport& operator=(BuyerReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuyerReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuyerReport* internal_default_instance() {
    return reinterpret_cast<const BuyerReport*>(
               &_BuyerReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BuyerReport& a, BuyerReport& b) {
    a.Swap(&b);
  }
  inline void Swap(BuyerReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuyerReport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuyerReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BuyerReport>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BuyerReport& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BuyerReport& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuyerReport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zjchain.c2c.protobuf.BuyerReport";
  }
  protected:
  explicit BuyerReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSellerFieldNumber = 1,
    kReportsInfoFieldNumber = 2,
  };
  // optional bytes seller = 1;
  bool has_seller() const;
  private:
  bool _internal_has_seller() const;
  public:
  void clear_seller();
  const std::string& seller() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_seller(ArgT0&& arg0, ArgT... args);
  std::string* mutable_seller();
  PROTOBUF_NODISCARD std::string* release_seller();
  void set_allocated_seller(std::string* seller);
  private:
  const std::string& _internal_seller() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_seller(const std::string& value);
  std::string* _internal_mutable_seller();
  public:

  // optional bytes reports_info = 2;
  bool has_reports_info() const;
  private:
  bool _internal_has_reports_info() const;
  public:
  void clear_reports_info();
  const std::string& reports_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reports_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reports_info();
  PROTOBUF_NODISCARD std::string* release_reports_info();
  void set_allocated_reports_info(std::string* reports_info);
  private:
  const std::string& _internal_reports_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reports_info(const std::string& value);
  std::string* _internal_mutable_reports_info();
  public:

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.BuyerReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr seller_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reports_info_;
  friend struct ::TableStruct_protos_2fc2c_2eproto;
};
// -------------------------------------------------------------------

class GetSell final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zjchain.c2c.protobuf.GetSell) */ {
 public:
  inline GetSell() : GetSell(nullptr) {}
  ~GetSell() override;
  explicit PROTOBUF_CONSTEXPR GetSell(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSell(const GetSell& from);
  GetSell(GetSell&& from) noexcept
    : GetSell() {
    *this = ::std::move(from);
  }

  inline GetSell& operator=(const GetSell& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSell& operator=(GetSell&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSell& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSell* internal_default_instance() {
    return reinterpret_cast<const GetSell*>(
               &_GetSell_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetSell& a, GetSell& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSell* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSell* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSell* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSell>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSell& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetSell& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSell* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zjchain.c2c.protobuf.GetSell";
  }
  protected:
  explicit GetSell(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSellerFieldNumber = 1,
  };
  // optional bytes seller = 1;
  bool has_seller() const;
  private:
  bool _internal_has_seller() const;
  public:
  void clear_seller();
  const std::string& seller() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_seller(ArgT0&& arg0, ArgT... args);
  std::string* mutable_seller();
  PROTOBUF_NODISCARD std::string* release_seller();
  void set_allocated_seller(std::string* seller);
  private:
  const std::string& _internal_seller() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_seller(const std::string& value);
  std::string* _internal_mutable_seller();
  public:

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.GetSell)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr seller_;
  friend struct ::TableStruct_protos_2fc2c_2eproto;
};
// -------------------------------------------------------------------

class C2cMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zjchain.c2c.protobuf.C2cMessage) */ {
 public:
  inline C2cMessage() : C2cMessage(nullptr) {}
  ~C2cMessage() override;
  explicit PROTOBUF_CONSTEXPR C2cMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C2cMessage(const C2cMessage& from);
  C2cMessage(C2cMessage&& from) noexcept
    : C2cMessage() {
    *this = ::std::move(from);
  }

  inline C2cMessage& operator=(const C2cMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline C2cMessage& operator=(C2cMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C2cMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const C2cMessage* internal_default_instance() {
    return reinterpret_cast<const C2cMessage*>(
               &_C2cMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(C2cMessage& a, C2cMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(C2cMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C2cMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C2cMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C2cMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C2cMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C2cMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C2cMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zjchain.c2c.protobuf.C2cMessage";
  }
  protected:
  explicit C2cMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSellsFieldNumber = 4,
    kGetSellFieldNumber = 5,
    kSellFieldNumber = 1,
    kOrderFieldNumber = 2,
    kReportFieldNumber = 3,
  };
  // repeated .zjchain.c2c.protobuf.SellInfo sells = 4;
  int sells_size() const;
  private:
  int _internal_sells_size() const;
  public:
  void clear_sells();
  ::zjchain::c2c::protobuf::SellInfo* mutable_sells(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zjchain::c2c::protobuf::SellInfo >*
      mutable_sells();
  private:
  const ::zjchain::c2c::protobuf::SellInfo& _internal_sells(int index) const;
  ::zjchain::c2c::protobuf::SellInfo* _internal_add_sells();
  public:
  const ::zjchain::c2c::protobuf::SellInfo& sells(int index) const;
  ::zjchain::c2c::protobuf::SellInfo* add_sells();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zjchain::c2c::protobuf::SellInfo >&
      sells() const;

  // repeated .zjchain.c2c.protobuf.GetSell get_sell = 5;
  int get_sell_size() const;
  private:
  int _internal_get_sell_size() const;
  public:
  void clear_get_sell();
  ::zjchain::c2c::protobuf::GetSell* mutable_get_sell(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zjchain::c2c::protobuf::GetSell >*
      mutable_get_sell();
  private:
  const ::zjchain::c2c::protobuf::GetSell& _internal_get_sell(int index) const;
  ::zjchain::c2c::protobuf::GetSell* _internal_add_get_sell();
  public:
  const ::zjchain::c2c::protobuf::GetSell& get_sell(int index) const;
  ::zjchain::c2c::protobuf::GetSell* add_get_sell();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zjchain::c2c::protobuf::GetSell >&
      get_sell() const;

  // optional .zjchain.c2c.protobuf.NewSell sell = 1;
  bool has_sell() const;
  private:
  bool _internal_has_sell() const;
  public:
  void clear_sell();
  const ::zjchain::c2c::protobuf::NewSell& sell() const;
  PROTOBUF_NODISCARD ::zjchain::c2c::protobuf::NewSell* release_sell();
  ::zjchain::c2c::protobuf::NewSell* mutable_sell();
  void set_allocated_sell(::zjchain::c2c::protobuf::NewSell* sell);
  private:
  const ::zjchain::c2c::protobuf::NewSell& _internal_sell() const;
  ::zjchain::c2c::protobuf::NewSell* _internal_mutable_sell();
  public:
  void unsafe_arena_set_allocated_sell(
      ::zjchain::c2c::protobuf::NewSell* sell);
  ::zjchain::c2c::protobuf::NewSell* unsafe_arena_release_sell();

  // optional .zjchain.c2c.protobuf.NewOrder order = 2;
  bool has_order() const;
  private:
  bool _internal_has_order() const;
  public:
  void clear_order();
  const ::zjchain::c2c::protobuf::NewOrder& order() const;
  PROTOBUF_NODISCARD ::zjchain::c2c::protobuf::NewOrder* release_order();
  ::zjchain::c2c::protobuf::NewOrder* mutable_order();
  void set_allocated_order(::zjchain::c2c::protobuf::NewOrder* order);
  private:
  const ::zjchain::c2c::protobuf::NewOrder& _internal_order() const;
  ::zjchain::c2c::protobuf::NewOrder* _internal_mutable_order();
  public:
  void unsafe_arena_set_allocated_order(
      ::zjchain::c2c::protobuf::NewOrder* order);
  ::zjchain::c2c::protobuf::NewOrder* unsafe_arena_release_order();

  // optional .zjchain.c2c.protobuf.BuyerReport report = 3;
  bool has_report() const;
  private:
  bool _internal_has_report() const;
  public:
  void clear_report();
  const ::zjchain::c2c::protobuf::BuyerReport& report() const;
  PROTOBUF_NODISCARD ::zjchain::c2c::protobuf::BuyerReport* release_report();
  ::zjchain::c2c::protobuf::BuyerReport* mutable_report();
  void set_allocated_report(::zjchain::c2c::protobuf::BuyerReport* report);
  private:
  const ::zjchain::c2c::protobuf::BuyerReport& _internal_report() const;
  ::zjchain::c2c::protobuf::BuyerReport* _internal_mutable_report();
  public:
  void unsafe_arena_set_allocated_report(
      ::zjchain::c2c::protobuf::BuyerReport* report);
  ::zjchain::c2c::protobuf::BuyerReport* unsafe_arena_release_report();

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.C2cMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zjchain::c2c::protobuf::SellInfo > sells_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zjchain::c2c::protobuf::GetSell > get_sell_;
  ::zjchain::c2c::protobuf::NewSell* sell_;
  ::zjchain::c2c::protobuf::NewOrder* order_;
  ::zjchain::c2c::protobuf::BuyerReport* report_;
  friend struct ::TableStruct_protos_2fc2c_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// OrderInfo

// optional bytes buyer = 1;
inline bool OrderInfo::_internal_has_buyer() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OrderInfo::has_buyer() const {
  return _internal_has_buyer();
}
inline void OrderInfo::clear_buyer() {
  buyer_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OrderInfo::buyer() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.OrderInfo.buyer)
  return _internal_buyer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderInfo::set_buyer(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 buyer_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.OrderInfo.buyer)
}
inline std::string* OrderInfo::mutable_buyer() {
  std::string* _s = _internal_mutable_buyer();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.OrderInfo.buyer)
  return _s;
}
inline const std::string& OrderInfo::_internal_buyer() const {
  return buyer_.Get();
}
inline void OrderInfo::_internal_set_buyer(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  buyer_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderInfo::_internal_mutable_buyer() {
  _has_bits_[0] |= 0x00000001u;
  return buyer_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderInfo::release_buyer() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.OrderInfo.buyer)
  if (!_internal_has_buyer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = buyer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (buyer_.IsDefault()) {
    buyer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OrderInfo::set_allocated_buyer(std::string* buyer) {
  if (buyer != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  buyer_.SetAllocated(buyer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (buyer_.IsDefault()) {
    buyer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.OrderInfo.buyer)
}

// optional .zjchain.c2c.protobuf.Status status = 2;
inline bool OrderInfo::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OrderInfo::has_status() const {
  return _internal_has_status();
}
inline void OrderInfo::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::zjchain::c2c::protobuf::Status OrderInfo::_internal_status() const {
  return static_cast< ::zjchain::c2c::protobuf::Status >(status_);
}
inline ::zjchain::c2c::protobuf::Status OrderInfo::status() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.OrderInfo.status)
  return _internal_status();
}
inline void OrderInfo::_internal_set_status(::zjchain::c2c::protobuf::Status value) {
  assert(::zjchain::c2c::protobuf::Status_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  status_ = value;
}
inline void OrderInfo::set_status(::zjchain::c2c::protobuf::Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.OrderInfo.status)
}

// optional uint64 amount = 3;
inline bool OrderInfo::_internal_has_amount() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OrderInfo::has_amount() const {
  return _internal_has_amount();
}
inline void OrderInfo::clear_amount() {
  amount_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t OrderInfo::_internal_amount() const {
  return amount_;
}
inline uint64_t OrderInfo::amount() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.OrderInfo.amount)
  return _internal_amount();
}
inline void OrderInfo::_internal_set_amount(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  amount_ = value;
}
inline void OrderInfo::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.OrderInfo.amount)
}

// -------------------------------------------------------------------

// SellInfo

// optional bytes protocol_addr = 1;
inline bool SellInfo::_internal_has_protocol_addr() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SellInfo::has_protocol_addr() const {
  return _internal_has_protocol_addr();
}
inline void SellInfo::clear_protocol_addr() {
  protocol_addr_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SellInfo::protocol_addr() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.protocol_addr)
  return _internal_protocol_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SellInfo::set_protocol_addr(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 protocol_addr_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.protocol_addr)
}
inline std::string* SellInfo::mutable_protocol_addr() {
  std::string* _s = _internal_mutable_protocol_addr();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.SellInfo.protocol_addr)
  return _s;
}
inline const std::string& SellInfo::_internal_protocol_addr() const {
  return protocol_addr_.Get();
}
inline void SellInfo::_internal_set_protocol_addr(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  protocol_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* SellInfo::_internal_mutable_protocol_addr() {
  _has_bits_[0] |= 0x00000001u;
  return protocol_addr_.Mutable(GetArenaForAllocation());
}
inline std::string* SellInfo::release_protocol_addr() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.SellInfo.protocol_addr)
  if (!_internal_has_protocol_addr()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = protocol_addr_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (protocol_addr_.IsDefault()) {
    protocol_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SellInfo::set_allocated_protocol_addr(std::string* protocol_addr) {
  if (protocol_addr != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  protocol_addr_.SetAllocated(protocol_addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (protocol_addr_.IsDefault()) {
    protocol_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.SellInfo.protocol_addr)
}

// optional bytes seller = 2;
inline bool SellInfo::_internal_has_seller() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SellInfo::has_seller() const {
  return _internal_has_seller();
}
inline void SellInfo::clear_seller() {
  seller_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SellInfo::seller() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.seller)
  return _internal_seller();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SellInfo::set_seller(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 seller_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.seller)
}
inline std::string* SellInfo::mutable_seller() {
  std::string* _s = _internal_mutable_seller();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.SellInfo.seller)
  return _s;
}
inline const std::string& SellInfo::_internal_seller() const {
  return seller_.Get();
}
inline void SellInfo::_internal_set_seller(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  seller_.Set(value, GetArenaForAllocation());
}
inline std::string* SellInfo::_internal_mutable_seller() {
  _has_bits_[0] |= 0x00000002u;
  return seller_.Mutable(GetArenaForAllocation());
}
inline std::string* SellInfo::release_seller() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.SellInfo.seller)
  if (!_internal_has_seller()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = seller_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (seller_.IsDefault()) {
    seller_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SellInfo::set_allocated_seller(std::string* seller) {
  if (seller != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  seller_.SetAllocated(seller, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (seller_.IsDefault()) {
    seller_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.SellInfo.seller)
}

// optional uint64 pledge_amount = 3;
inline bool SellInfo::_internal_has_pledge_amount() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SellInfo::has_pledge_amount() const {
  return _internal_has_pledge_amount();
}
inline void SellInfo::clear_pledge_amount() {
  pledge_amount_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline uint64_t SellInfo::_internal_pledge_amount() const {
  return pledge_amount_;
}
inline uint64_t SellInfo::pledge_amount() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.pledge_amount)
  return _internal_pledge_amount();
}
inline void SellInfo::_internal_set_pledge_amount(uint64_t value) {
  _has_bits_[0] |= 0x00000010u;
  pledge_amount_ = value;
}
inline void SellInfo::set_pledge_amount(uint64_t value) {
  _internal_set_pledge_amount(value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.pledge_amount)
}

// optional uint64 price = 4;
inline bool SellInfo::_internal_has_price() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SellInfo::has_price() const {
  return _internal_has_price();
}
inline void SellInfo::clear_price() {
  price_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t SellInfo::_internal_price() const {
  return price_;
}
inline uint64_t SellInfo::price() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.price)
  return _internal_price();
}
inline void SellInfo::_internal_set_price(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  price_ = value;
}
inline void SellInfo::set_price(uint64_t value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.price)
}

// optional bytes receivable = 5;
inline bool SellInfo::_internal_has_receivable() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SellInfo::has_receivable() const {
  return _internal_has_receivable();
}
inline void SellInfo::clear_receivable() {
  receivable_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SellInfo::receivable() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.receivable)
  return _internal_receivable();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SellInfo::set_receivable(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 receivable_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.receivable)
}
inline std::string* SellInfo::mutable_receivable() {
  std::string* _s = _internal_mutable_receivable();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.SellInfo.receivable)
  return _s;
}
inline const std::string& SellInfo::_internal_receivable() const {
  return receivable_.Get();
}
inline void SellInfo::_internal_set_receivable(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  receivable_.Set(value, GetArenaForAllocation());
}
inline std::string* SellInfo::_internal_mutable_receivable() {
  _has_bits_[0] |= 0x00000004u;
  return receivable_.Mutable(GetArenaForAllocation());
}
inline std::string* SellInfo::release_receivable() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.SellInfo.receivable)
  if (!_internal_has_receivable()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = receivable_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (receivable_.IsDefault()) {
    receivable_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SellInfo::set_allocated_receivable(std::string* receivable) {
  if (receivable != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  receivable_.SetAllocated(receivable, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (receivable_.IsDefault()) {
    receivable_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.SellInfo.receivable)
}

// optional bool manager_released = 6;
inline bool SellInfo::_internal_has_manager_released() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SellInfo::has_manager_released() const {
  return _internal_has_manager_released();
}
inline void SellInfo::clear_manager_released() {
  manager_released_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool SellInfo::_internal_manager_released() const {
  return manager_released_;
}
inline bool SellInfo::manager_released() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.manager_released)
  return _internal_manager_released();
}
inline void SellInfo::_internal_set_manager_released(bool value) {
  _has_bits_[0] |= 0x00000040u;
  manager_released_ = value;
}
inline void SellInfo::set_manager_released(bool value) {
  _internal_set_manager_released(value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.manager_released)
}

// optional bool seller_released = 7;
inline bool SellInfo::_internal_has_seller_released() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool SellInfo::has_seller_released() const {
  return _internal_has_seller_released();
}
inline void SellInfo::clear_seller_released() {
  seller_released_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool SellInfo::_internal_seller_released() const {
  return seller_released_;
}
inline bool SellInfo::seller_released() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.seller_released)
  return _internal_seller_released();
}
inline void SellInfo::_internal_set_seller_released(bool value) {
  _has_bits_[0] |= 0x00000080u;
  seller_released_ = value;
}
inline void SellInfo::set_seller_released(bool value) {
  _internal_set_seller_released(value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.seller_released)
}

// optional .zjchain.c2c.protobuf.Status status = 8;
inline bool SellInfo::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool SellInfo::has_status() const {
  return _internal_has_status();
}
inline void SellInfo::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::zjchain::c2c::protobuf::Status SellInfo::_internal_status() const {
  return static_cast< ::zjchain::c2c::protobuf::Status >(status_);
}
inline ::zjchain::c2c::protobuf::Status SellInfo::status() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.status)
  return _internal_status();
}
inline void SellInfo::_internal_set_status(::zjchain::c2c::protobuf::Status value) {
  assert(::zjchain::c2c::protobuf::Status_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  status_ = value;
}
inline void SellInfo::set_status(::zjchain::c2c::protobuf::Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.status)
}

// optional .zjchain.c2c.protobuf.OrderInfo order_info = 9;
inline bool SellInfo::_internal_has_order_info() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || order_info_ != nullptr);
  return value;
}
inline bool SellInfo::has_order_info() const {
  return _internal_has_order_info();
}
inline void SellInfo::clear_order_info() {
  if (order_info_ != nullptr) order_info_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::zjchain::c2c::protobuf::OrderInfo& SellInfo::_internal_order_info() const {
  const ::zjchain::c2c::protobuf::OrderInfo* p = order_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::zjchain::c2c::protobuf::OrderInfo&>(
      ::zjchain::c2c::protobuf::_OrderInfo_default_instance_);
}
inline const ::zjchain::c2c::protobuf::OrderInfo& SellInfo::order_info() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.order_info)
  return _internal_order_info();
}
inline void SellInfo::unsafe_arena_set_allocated_order_info(
    ::zjchain::c2c::protobuf::OrderInfo* order_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(order_info_);
  }
  order_info_ = order_info;
  if (order_info) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zjchain.c2c.protobuf.SellInfo.order_info)
}
inline ::zjchain::c2c::protobuf::OrderInfo* SellInfo::release_order_info() {
  _has_bits_[0] &= ~0x00000008u;
  ::zjchain::c2c::protobuf::OrderInfo* temp = order_info_;
  order_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zjchain::c2c::protobuf::OrderInfo* SellInfo::unsafe_arena_release_order_info() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.SellInfo.order_info)
  _has_bits_[0] &= ~0x00000008u;
  ::zjchain::c2c::protobuf::OrderInfo* temp = order_info_;
  order_info_ = nullptr;
  return temp;
}
inline ::zjchain::c2c::protobuf::OrderInfo* SellInfo::_internal_mutable_order_info() {
  _has_bits_[0] |= 0x00000008u;
  if (order_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::zjchain::c2c::protobuf::OrderInfo>(GetArenaForAllocation());
    order_info_ = p;
  }
  return order_info_;
}
inline ::zjchain::c2c::protobuf::OrderInfo* SellInfo::mutable_order_info() {
  ::zjchain::c2c::protobuf::OrderInfo* _msg = _internal_mutable_order_info();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.SellInfo.order_info)
  return _msg;
}
inline void SellInfo::set_allocated_order_info(::zjchain::c2c::protobuf::OrderInfo* order_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete order_info_;
  }
  if (order_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(order_info);
    if (message_arena != submessage_arena) {
      order_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  order_info_ = order_info;
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.SellInfo.order_info)
}

// repeated bytes reports = 10;
inline int SellInfo::_internal_reports_size() const {
  return reports_.size();
}
inline int SellInfo::reports_size() const {
  return _internal_reports_size();
}
inline void SellInfo::clear_reports() {
  reports_.Clear();
}
inline std::string* SellInfo::add_reports() {
  std::string* _s = _internal_add_reports();
  // @@protoc_insertion_point(field_add_mutable:zjchain.c2c.protobuf.SellInfo.reports)
  return _s;
}
inline const std::string& SellInfo::_internal_reports(int index) const {
  return reports_.Get(index);
}
inline const std::string& SellInfo::reports(int index) const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.reports)
  return _internal_reports(index);
}
inline std::string* SellInfo::mutable_reports(int index) {
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.SellInfo.reports)
  return reports_.Mutable(index);
}
inline void SellInfo::set_reports(int index, const std::string& value) {
  reports_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.reports)
}
inline void SellInfo::set_reports(int index, std::string&& value) {
  reports_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.reports)
}
inline void SellInfo::set_reports(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  reports_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.SellInfo.reports)
}
inline void SellInfo::set_reports(int index, const void* value, size_t size) {
  reports_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.SellInfo.reports)
}
inline std::string* SellInfo::_internal_add_reports() {
  return reports_.Add();
}
inline void SellInfo::add_reports(const std::string& value) {
  reports_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zjchain.c2c.protobuf.SellInfo.reports)
}
inline void SellInfo::add_reports(std::string&& value) {
  reports_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zjchain.c2c.protobuf.SellInfo.reports)
}
inline void SellInfo::add_reports(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  reports_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zjchain.c2c.protobuf.SellInfo.reports)
}
inline void SellInfo::add_reports(const void* value, size_t size) {
  reports_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zjchain.c2c.protobuf.SellInfo.reports)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SellInfo::reports() const {
  // @@protoc_insertion_point(field_list:zjchain.c2c.protobuf.SellInfo.reports)
  return reports_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SellInfo::mutable_reports() {
  // @@protoc_insertion_point(field_mutable_list:zjchain.c2c.protobuf.SellInfo.reports)
  return &reports_;
}

// -------------------------------------------------------------------

// NewOrder

// optional bytes seller = 1;
inline bool NewOrder::_internal_has_seller() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NewOrder::has_seller() const {
  return _internal_has_seller();
}
inline void NewOrder::clear_seller() {
  seller_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NewOrder::seller() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewOrder.seller)
  return _internal_seller();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewOrder::set_seller(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 seller_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewOrder.seller)
}
inline std::string* NewOrder::mutable_seller() {
  std::string* _s = _internal_mutable_seller();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.NewOrder.seller)
  return _s;
}
inline const std::string& NewOrder::_internal_seller() const {
  return seller_.Get();
}
inline void NewOrder::_internal_set_seller(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  seller_.Set(value, GetArenaForAllocation());
}
inline std::string* NewOrder::_internal_mutable_seller() {
  _has_bits_[0] |= 0x00000001u;
  return seller_.Mutable(GetArenaForAllocation());
}
inline std::string* NewOrder::release_seller() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.NewOrder.seller)
  if (!_internal_has_seller()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = seller_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (seller_.IsDefault()) {
    seller_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NewOrder::set_allocated_seller(std::string* seller) {
  if (seller != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  seller_.SetAllocated(seller, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (seller_.IsDefault()) {
    seller_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.NewOrder.seller)
}

// optional uint64 amount = 2;
inline bool NewOrder::_internal_has_amount() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NewOrder::has_amount() const {
  return _internal_has_amount();
}
inline void NewOrder::clear_amount() {
  amount_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t NewOrder::_internal_amount() const {
  return amount_;
}
inline uint64_t NewOrder::amount() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewOrder.amount)
  return _internal_amount();
}
inline void NewOrder::_internal_set_amount(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  amount_ = value;
}
inline void NewOrder::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewOrder.amount)
}

// optional bytes buyer = 3;
inline bool NewOrder::_internal_has_buyer() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NewOrder::has_buyer() const {
  return _internal_has_buyer();
}
inline void NewOrder::clear_buyer() {
  buyer_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NewOrder::buyer() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewOrder.buyer)
  return _internal_buyer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewOrder::set_buyer(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 buyer_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewOrder.buyer)
}
inline std::string* NewOrder::mutable_buyer() {
  std::string* _s = _internal_mutable_buyer();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.NewOrder.buyer)
  return _s;
}
inline const std::string& NewOrder::_internal_buyer() const {
  return buyer_.Get();
}
inline void NewOrder::_internal_set_buyer(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  buyer_.Set(value, GetArenaForAllocation());
}
inline std::string* NewOrder::_internal_mutable_buyer() {
  _has_bits_[0] |= 0x00000002u;
  return buyer_.Mutable(GetArenaForAllocation());
}
inline std::string* NewOrder::release_buyer() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.NewOrder.buyer)
  if (!_internal_has_buyer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = buyer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (buyer_.IsDefault()) {
    buyer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NewOrder::set_allocated_buyer(std::string* buyer) {
  if (buyer != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  buyer_.SetAllocated(buyer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (buyer_.IsDefault()) {
    buyer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.NewOrder.buyer)
}

// -------------------------------------------------------------------

// NewSell

// optional bytes protocol_addr = 1;
inline bool NewSell::_internal_has_protocol_addr() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NewSell::has_protocol_addr() const {
  return _internal_has_protocol_addr();
}
inline void NewSell::clear_protocol_addr() {
  protocol_addr_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NewSell::protocol_addr() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewSell.protocol_addr)
  return _internal_protocol_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewSell::set_protocol_addr(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 protocol_addr_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewSell.protocol_addr)
}
inline std::string* NewSell::mutable_protocol_addr() {
  std::string* _s = _internal_mutable_protocol_addr();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.NewSell.protocol_addr)
  return _s;
}
inline const std::string& NewSell::_internal_protocol_addr() const {
  return protocol_addr_.Get();
}
inline void NewSell::_internal_set_protocol_addr(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  protocol_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* NewSell::_internal_mutable_protocol_addr() {
  _has_bits_[0] |= 0x00000001u;
  return protocol_addr_.Mutable(GetArenaForAllocation());
}
inline std::string* NewSell::release_protocol_addr() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.NewSell.protocol_addr)
  if (!_internal_has_protocol_addr()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = protocol_addr_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (protocol_addr_.IsDefault()) {
    protocol_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NewSell::set_allocated_protocol_addr(std::string* protocol_addr) {
  if (protocol_addr != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  protocol_addr_.SetAllocated(protocol_addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (protocol_addr_.IsDefault()) {
    protocol_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.NewSell.protocol_addr)
}

// optional bytes seller = 2;
inline bool NewSell::_internal_has_seller() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NewSell::has_seller() const {
  return _internal_has_seller();
}
inline void NewSell::clear_seller() {
  seller_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NewSell::seller() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewSell.seller)
  return _internal_seller();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewSell::set_seller(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 seller_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewSell.seller)
}
inline std::string* NewSell::mutable_seller() {
  std::string* _s = _internal_mutable_seller();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.NewSell.seller)
  return _s;
}
inline const std::string& NewSell::_internal_seller() const {
  return seller_.Get();
}
inline void NewSell::_internal_set_seller(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  seller_.Set(value, GetArenaForAllocation());
}
inline std::string* NewSell::_internal_mutable_seller() {
  _has_bits_[0] |= 0x00000002u;
  return seller_.Mutable(GetArenaForAllocation());
}
inline std::string* NewSell::release_seller() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.NewSell.seller)
  if (!_internal_has_seller()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = seller_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (seller_.IsDefault()) {
    seller_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NewSell::set_allocated_seller(std::string* seller) {
  if (seller != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  seller_.SetAllocated(seller, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (seller_.IsDefault()) {
    seller_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.NewSell.seller)
}

// optional uint64 amount = 3;
inline bool NewSell::_internal_has_amount() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NewSell::has_amount() const {
  return _internal_has_amount();
}
inline void NewSell::clear_amount() {
  amount_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t NewSell::_internal_amount() const {
  return amount_;
}
inline uint64_t NewSell::amount() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewSell.amount)
  return _internal_amount();
}
inline void NewSell::_internal_set_amount(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  amount_ = value;
}
inline void NewSell::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewSell.amount)
}

// optional uint64 price = 4;
inline bool NewSell::_internal_has_price() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool NewSell::has_price() const {
  return _internal_has_price();
}
inline void NewSell::clear_price() {
  price_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline uint64_t NewSell::_internal_price() const {
  return price_;
}
inline uint64_t NewSell::price() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewSell.price)
  return _internal_price();
}
inline void NewSell::_internal_set_price(uint64_t value) {
  _has_bits_[0] |= 0x00000010u;
  price_ = value;
}
inline void NewSell::set_price(uint64_t value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewSell.price)
}

// optional bytes receivable = 5;
inline bool NewSell::_internal_has_receivable() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NewSell::has_receivable() const {
  return _internal_has_receivable();
}
inline void NewSell::clear_receivable() {
  receivable_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NewSell::receivable() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewSell.receivable)
  return _internal_receivable();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewSell::set_receivable(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 receivable_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewSell.receivable)
}
inline std::string* NewSell::mutable_receivable() {
  std::string* _s = _internal_mutable_receivable();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.NewSell.receivable)
  return _s;
}
inline const std::string& NewSell::_internal_receivable() const {
  return receivable_.Get();
}
inline void NewSell::_internal_set_receivable(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  receivable_.Set(value, GetArenaForAllocation());
}
inline std::string* NewSell::_internal_mutable_receivable() {
  _has_bits_[0] |= 0x00000004u;
  return receivable_.Mutable(GetArenaForAllocation());
}
inline std::string* NewSell::release_receivable() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.NewSell.receivable)
  if (!_internal_has_receivable()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = receivable_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (receivable_.IsDefault()) {
    receivable_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NewSell::set_allocated_receivable(std::string* receivable) {
  if (receivable != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  receivable_.SetAllocated(receivable, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (receivable_.IsDefault()) {
    receivable_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.NewSell.receivable)
}

// -------------------------------------------------------------------

// BuyerReport

// optional bytes seller = 1;
inline bool BuyerReport::_internal_has_seller() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BuyerReport::has_seller() const {
  return _internal_has_seller();
}
inline void BuyerReport::clear_seller() {
  seller_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BuyerReport::seller() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.BuyerReport.seller)
  return _internal_seller();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BuyerReport::set_seller(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 seller_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.BuyerReport.seller)
}
inline std::string* BuyerReport::mutable_seller() {
  std::string* _s = _internal_mutable_seller();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.BuyerReport.seller)
  return _s;
}
inline const std::string& BuyerReport::_internal_seller() const {
  return seller_.Get();
}
inline void BuyerReport::_internal_set_seller(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  seller_.Set(value, GetArenaForAllocation());
}
inline std::string* BuyerReport::_internal_mutable_seller() {
  _has_bits_[0] |= 0x00000001u;
  return seller_.Mutable(GetArenaForAllocation());
}
inline std::string* BuyerReport::release_seller() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.BuyerReport.seller)
  if (!_internal_has_seller()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = seller_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (seller_.IsDefault()) {
    seller_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BuyerReport::set_allocated_seller(std::string* seller) {
  if (seller != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  seller_.SetAllocated(seller, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (seller_.IsDefault()) {
    seller_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.BuyerReport.seller)
}

// optional bytes reports_info = 2;
inline bool BuyerReport::_internal_has_reports_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BuyerReport::has_reports_info() const {
  return _internal_has_reports_info();
}
inline void BuyerReport::clear_reports_info() {
  reports_info_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BuyerReport::reports_info() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.BuyerReport.reports_info)
  return _internal_reports_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BuyerReport::set_reports_info(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 reports_info_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.BuyerReport.reports_info)
}
inline std::string* BuyerReport::mutable_reports_info() {
  std::string* _s = _internal_mutable_reports_info();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.BuyerReport.reports_info)
  return _s;
}
inline const std::string& BuyerReport::_internal_reports_info() const {
  return reports_info_.Get();
}
inline void BuyerReport::_internal_set_reports_info(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  reports_info_.Set(value, GetArenaForAllocation());
}
inline std::string* BuyerReport::_internal_mutable_reports_info() {
  _has_bits_[0] |= 0x00000002u;
  return reports_info_.Mutable(GetArenaForAllocation());
}
inline std::string* BuyerReport::release_reports_info() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.BuyerReport.reports_info)
  if (!_internal_has_reports_info()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = reports_info_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reports_info_.IsDefault()) {
    reports_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BuyerReport::set_allocated_reports_info(std::string* reports_info) {
  if (reports_info != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  reports_info_.SetAllocated(reports_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reports_info_.IsDefault()) {
    reports_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.BuyerReport.reports_info)
}

// -------------------------------------------------------------------

// GetSell

// optional bytes seller = 1;
inline bool GetSell::_internal_has_seller() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetSell::has_seller() const {
  return _internal_has_seller();
}
inline void GetSell::clear_seller() {
  seller_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetSell::seller() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.GetSell.seller)
  return _internal_seller();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSell::set_seller(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 seller_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.GetSell.seller)
}
inline std::string* GetSell::mutable_seller() {
  std::string* _s = _internal_mutable_seller();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.GetSell.seller)
  return _s;
}
inline const std::string& GetSell::_internal_seller() const {
  return seller_.Get();
}
inline void GetSell::_internal_set_seller(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  seller_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSell::_internal_mutable_seller() {
  _has_bits_[0] |= 0x00000001u;
  return seller_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSell::release_seller() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.GetSell.seller)
  if (!_internal_has_seller()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = seller_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (seller_.IsDefault()) {
    seller_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetSell::set_allocated_seller(std::string* seller) {
  if (seller != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  seller_.SetAllocated(seller, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (seller_.IsDefault()) {
    seller_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.GetSell.seller)
}

// -------------------------------------------------------------------

// C2cMessage

// optional .zjchain.c2c.protobuf.NewSell sell = 1;
inline bool C2cMessage::_internal_has_sell() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || sell_ != nullptr);
  return value;
}
inline bool C2cMessage::has_sell() const {
  return _internal_has_sell();
}
inline void C2cMessage::clear_sell() {
  if (sell_ != nullptr) sell_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::zjchain::c2c::protobuf::NewSell& C2cMessage::_internal_sell() const {
  const ::zjchain::c2c::protobuf::NewSell* p = sell_;
  return p != nullptr ? *p : reinterpret_cast<const ::zjchain::c2c::protobuf::NewSell&>(
      ::zjchain::c2c::protobuf::_NewSell_default_instance_);
}
inline const ::zjchain::c2c::protobuf::NewSell& C2cMessage::sell() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.C2cMessage.sell)
  return _internal_sell();
}
inline void C2cMessage::unsafe_arena_set_allocated_sell(
    ::zjchain::c2c::protobuf::NewSell* sell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sell_);
  }
  sell_ = sell;
  if (sell) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zjchain.c2c.protobuf.C2cMessage.sell)
}
inline ::zjchain::c2c::protobuf::NewSell* C2cMessage::release_sell() {
  _has_bits_[0] &= ~0x00000001u;
  ::zjchain::c2c::protobuf::NewSell* temp = sell_;
  sell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zjchain::c2c::protobuf::NewSell* C2cMessage::unsafe_arena_release_sell() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.C2cMessage.sell)
  _has_bits_[0] &= ~0x00000001u;
  ::zjchain::c2c::protobuf::NewSell* temp = sell_;
  sell_ = nullptr;
  return temp;
}
inline ::zjchain::c2c::protobuf::NewSell* C2cMessage::_internal_mutable_sell() {
  _has_bits_[0] |= 0x00000001u;
  if (sell_ == nullptr) {
    auto* p = CreateMaybeMessage<::zjchain::c2c::protobuf::NewSell>(GetArenaForAllocation());
    sell_ = p;
  }
  return sell_;
}
inline ::zjchain::c2c::protobuf::NewSell* C2cMessage::mutable_sell() {
  ::zjchain::c2c::protobuf::NewSell* _msg = _internal_mutable_sell();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.C2cMessage.sell)
  return _msg;
}
inline void C2cMessage::set_allocated_sell(::zjchain::c2c::protobuf::NewSell* sell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sell_;
  }
  if (sell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sell);
    if (message_arena != submessage_arena) {
      sell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sell, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sell_ = sell;
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.C2cMessage.sell)
}

// optional .zjchain.c2c.protobuf.NewOrder order = 2;
inline bool C2cMessage::_internal_has_order() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || order_ != nullptr);
  return value;
}
inline bool C2cMessage::has_order() const {
  return _internal_has_order();
}
inline void C2cMessage::clear_order() {
  if (order_ != nullptr) order_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::zjchain::c2c::protobuf::NewOrder& C2cMessage::_internal_order() const {
  const ::zjchain::c2c::protobuf::NewOrder* p = order_;
  return p != nullptr ? *p : reinterpret_cast<const ::zjchain::c2c::protobuf::NewOrder&>(
      ::zjchain::c2c::protobuf::_NewOrder_default_instance_);
}
inline const ::zjchain::c2c::protobuf::NewOrder& C2cMessage::order() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.C2cMessage.order)
  return _internal_order();
}
inline void C2cMessage::unsafe_arena_set_allocated_order(
    ::zjchain::c2c::protobuf::NewOrder* order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(order_);
  }
  order_ = order;
  if (order) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zjchain.c2c.protobuf.C2cMessage.order)
}
inline ::zjchain::c2c::protobuf::NewOrder* C2cMessage::release_order() {
  _has_bits_[0] &= ~0x00000002u;
  ::zjchain::c2c::protobuf::NewOrder* temp = order_;
  order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zjchain::c2c::protobuf::NewOrder* C2cMessage::unsafe_arena_release_order() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.C2cMessage.order)
  _has_bits_[0] &= ~0x00000002u;
  ::zjchain::c2c::protobuf::NewOrder* temp = order_;
  order_ = nullptr;
  return temp;
}
inline ::zjchain::c2c::protobuf::NewOrder* C2cMessage::_internal_mutable_order() {
  _has_bits_[0] |= 0x00000002u;
  if (order_ == nullptr) {
    auto* p = CreateMaybeMessage<::zjchain::c2c::protobuf::NewOrder>(GetArenaForAllocation());
    order_ = p;
  }
  return order_;
}
inline ::zjchain::c2c::protobuf::NewOrder* C2cMessage::mutable_order() {
  ::zjchain::c2c::protobuf::NewOrder* _msg = _internal_mutable_order();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.C2cMessage.order)
  return _msg;
}
inline void C2cMessage::set_allocated_order(::zjchain::c2c::protobuf::NewOrder* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete order_;
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(order);
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  order_ = order;
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.C2cMessage.order)
}

// optional .zjchain.c2c.protobuf.BuyerReport report = 3;
inline bool C2cMessage::_internal_has_report() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || report_ != nullptr);
  return value;
}
inline bool C2cMessage::has_report() const {
  return _internal_has_report();
}
inline void C2cMessage::clear_report() {
  if (report_ != nullptr) report_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::zjchain::c2c::protobuf::BuyerReport& C2cMessage::_internal_report() const {
  const ::zjchain::c2c::protobuf::BuyerReport* p = report_;
  return p != nullptr ? *p : reinterpret_cast<const ::zjchain::c2c::protobuf::BuyerReport&>(
      ::zjchain::c2c::protobuf::_BuyerReport_default_instance_);
}
inline const ::zjchain::c2c::protobuf::BuyerReport& C2cMessage::report() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.C2cMessage.report)
  return _internal_report();
}
inline void C2cMessage::unsafe_arena_set_allocated_report(
    ::zjchain::c2c::protobuf::BuyerReport* report) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(report_);
  }
  report_ = report;
  if (report) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zjchain.c2c.protobuf.C2cMessage.report)
}
inline ::zjchain::c2c::protobuf::BuyerReport* C2cMessage::release_report() {
  _has_bits_[0] &= ~0x00000004u;
  ::zjchain::c2c::protobuf::BuyerReport* temp = report_;
  report_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zjchain::c2c::protobuf::BuyerReport* C2cMessage::unsafe_arena_release_report() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.C2cMessage.report)
  _has_bits_[0] &= ~0x00000004u;
  ::zjchain::c2c::protobuf::BuyerReport* temp = report_;
  report_ = nullptr;
  return temp;
}
inline ::zjchain::c2c::protobuf::BuyerReport* C2cMessage::_internal_mutable_report() {
  _has_bits_[0] |= 0x00000004u;
  if (report_ == nullptr) {
    auto* p = CreateMaybeMessage<::zjchain::c2c::protobuf::BuyerReport>(GetArenaForAllocation());
    report_ = p;
  }
  return report_;
}
inline ::zjchain::c2c::protobuf::BuyerReport* C2cMessage::mutable_report() {
  ::zjchain::c2c::protobuf::BuyerReport* _msg = _internal_mutable_report();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.C2cMessage.report)
  return _msg;
}
inline void C2cMessage::set_allocated_report(::zjchain::c2c::protobuf::BuyerReport* report) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete report_;
  }
  if (report) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(report);
    if (message_arena != submessage_arena) {
      report = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, report, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  report_ = report;
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.C2cMessage.report)
}

// repeated .zjchain.c2c.protobuf.SellInfo sells = 4;
inline int C2cMessage::_internal_sells_size() const {
  return sells_.size();
}
inline int C2cMessage::sells_size() const {
  return _internal_sells_size();
}
inline void C2cMessage::clear_sells() {
  sells_.Clear();
}
inline ::zjchain::c2c::protobuf::SellInfo* C2cMessage::mutable_sells(int index) {
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.C2cMessage.sells)
  return sells_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zjchain::c2c::protobuf::SellInfo >*
C2cMessage::mutable_sells() {
  // @@protoc_insertion_point(field_mutable_list:zjchain.c2c.protobuf.C2cMessage.sells)
  return &sells_;
}
inline const ::zjchain::c2c::protobuf::SellInfo& C2cMessage::_internal_sells(int index) const {
  return sells_.Get(index);
}
inline const ::zjchain::c2c::protobuf::SellInfo& C2cMessage::sells(int index) const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.C2cMessage.sells)
  return _internal_sells(index);
}
inline ::zjchain::c2c::protobuf::SellInfo* C2cMessage::_internal_add_sells() {
  return sells_.Add();
}
inline ::zjchain::c2c::protobuf::SellInfo* C2cMessage::add_sells() {
  ::zjchain::c2c::protobuf::SellInfo* _add = _internal_add_sells();
  // @@protoc_insertion_point(field_add:zjchain.c2c.protobuf.C2cMessage.sells)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zjchain::c2c::protobuf::SellInfo >&
C2cMessage::sells() const {
  // @@protoc_insertion_point(field_list:zjchain.c2c.protobuf.C2cMessage.sells)
  return sells_;
}

// repeated .zjchain.c2c.protobuf.GetSell get_sell = 5;
inline int C2cMessage::_internal_get_sell_size() const {
  return get_sell_.size();
}
inline int C2cMessage::get_sell_size() const {
  return _internal_get_sell_size();
}
inline void C2cMessage::clear_get_sell() {
  get_sell_.Clear();
}
inline ::zjchain::c2c::protobuf::GetSell* C2cMessage::mutable_get_sell(int index) {
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.C2cMessage.get_sell)
  return get_sell_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zjchain::c2c::protobuf::GetSell >*
C2cMessage::mutable_get_sell() {
  // @@protoc_insertion_point(field_mutable_list:zjchain.c2c.protobuf.C2cMessage.get_sell)
  return &get_sell_;
}
inline const ::zjchain::c2c::protobuf::GetSell& C2cMessage::_internal_get_sell(int index) const {
  return get_sell_.Get(index);
}
inline const ::zjchain::c2c::protobuf::GetSell& C2cMessage::get_sell(int index) const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.C2cMessage.get_sell)
  return _internal_get_sell(index);
}
inline ::zjchain::c2c::protobuf::GetSell* C2cMessage::_internal_add_get_sell() {
  return get_sell_.Add();
}
inline ::zjchain::c2c::protobuf::GetSell* C2cMessage::add_get_sell() {
  ::zjchain::c2c::protobuf::GetSell* _add = _internal_add_get_sell();
  // @@protoc_insertion_point(field_add:zjchain.c2c.protobuf.C2cMessage.get_sell)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zjchain::c2c::protobuf::GetSell >&
C2cMessage::get_sell() const {
  // @@protoc_insertion_point(field_list:zjchain.c2c.protobuf.C2cMessage.get_sell)
  return get_sell_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace c2c
}  // namespace zjchain

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::zjchain::c2c::protobuf::Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zjchain::c2c::protobuf::Status>() {
  return ::zjchain::c2c::protobuf::Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protos_2fc2c_2eproto
