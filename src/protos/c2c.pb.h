// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/c2c.proto

#ifndef PROTOBUF_INCLUDED_protos_2fc2c_2eproto
#define PROTOBUF_INCLUDED_protos_2fc2c_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_protos_2fc2c_2eproto 

namespace protobuf_protos_2fc2c_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_protos_2fc2c_2eproto
namespace zjchain {
namespace c2c {
namespace protobuf {
class BuyerReport;
class BuyerReportDefaultTypeInternal;
extern BuyerReportDefaultTypeInternal _BuyerReport_default_instance_;
class C2cMessage;
class C2cMessageDefaultTypeInternal;
extern C2cMessageDefaultTypeInternal _C2cMessage_default_instance_;
class GetSell;
class GetSellDefaultTypeInternal;
extern GetSellDefaultTypeInternal _GetSell_default_instance_;
class NewOrder;
class NewOrderDefaultTypeInternal;
extern NewOrderDefaultTypeInternal _NewOrder_default_instance_;
class NewSell;
class NewSellDefaultTypeInternal;
extern NewSellDefaultTypeInternal _NewSell_default_instance_;
class OrderInfo;
class OrderInfoDefaultTypeInternal;
extern OrderInfoDefaultTypeInternal _OrderInfo_default_instance_;
class SellInfo;
class SellInfoDefaultTypeInternal;
extern SellInfoDefaultTypeInternal _SellInfo_default_instance_;
}  // namespace protobuf
}  // namespace c2c
}  // namespace zjchain
namespace google {
namespace protobuf {
template<> ::zjchain::c2c::protobuf::BuyerReport* Arena::CreateMaybeMessage<::zjchain::c2c::protobuf::BuyerReport>(Arena*);
template<> ::zjchain::c2c::protobuf::C2cMessage* Arena::CreateMaybeMessage<::zjchain::c2c::protobuf::C2cMessage>(Arena*);
template<> ::zjchain::c2c::protobuf::GetSell* Arena::CreateMaybeMessage<::zjchain::c2c::protobuf::GetSell>(Arena*);
template<> ::zjchain::c2c::protobuf::NewOrder* Arena::CreateMaybeMessage<::zjchain::c2c::protobuf::NewOrder>(Arena*);
template<> ::zjchain::c2c::protobuf::NewSell* Arena::CreateMaybeMessage<::zjchain::c2c::protobuf::NewSell>(Arena*);
template<> ::zjchain::c2c::protobuf::OrderInfo* Arena::CreateMaybeMessage<::zjchain::c2c::protobuf::OrderInfo>(Arena*);
template<> ::zjchain::c2c::protobuf::SellInfo* Arena::CreateMaybeMessage<::zjchain::c2c::protobuf::SellInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace zjchain {
namespace c2c {
namespace protobuf {

enum Status {
  kDefault = 0,
  kConfirmed = 1,
  kReported = 2,
  kSellWaiting = 3,
  kSellValid = 4,
  kSellInvalid = 5,
  kSellReleased = 6,
  kSellExists = 7
};
bool Status_IsValid(int value);
const Status Status_MIN = kDefault;
const Status Status_MAX = kSellExists;
const int Status_ARRAYSIZE = Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_descriptor();
inline const ::std::string& Status_Name(Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_descriptor(), value);
}
inline bool Status_Parse(
    const ::std::string& name, Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
// ===================================================================

class OrderInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.c2c.protobuf.OrderInfo) */ {
 public:
  OrderInfo();
  virtual ~OrderInfo();

  OrderInfo(const OrderInfo& from);

  inline OrderInfo& operator=(const OrderInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OrderInfo(OrderInfo&& from) noexcept
    : OrderInfo() {
    *this = ::std::move(from);
  }

  inline OrderInfo& operator=(OrderInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrderInfo* internal_default_instance() {
    return reinterpret_cast<const OrderInfo*>(
               &_OrderInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(OrderInfo* other);
  friend void swap(OrderInfo& a, OrderInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OrderInfo* New() const final {
    return CreateMaybeMessage<OrderInfo>(NULL);
  }

  OrderInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OrderInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OrderInfo& from);
  void MergeFrom(const OrderInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes buyer = 1;
  bool has_buyer() const;
  void clear_buyer();
  static const int kBuyerFieldNumber = 1;
  const ::std::string& buyer() const;
  void set_buyer(const ::std::string& value);
  #if LANG_CXX11
  void set_buyer(::std::string&& value);
  #endif
  void set_buyer(const char* value);
  void set_buyer(const void* value, size_t size);
  ::std::string* mutable_buyer();
  ::std::string* release_buyer();
  void set_allocated_buyer(::std::string* buyer);

  // optional uint64 amount = 3;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // optional .zjchain.c2c.protobuf.Status status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::zjchain::c2c::protobuf::Status status() const;
  void set_status(::zjchain::c2c::protobuf::Status value);

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.OrderInfo)
 private:
  void set_has_buyer();
  void clear_has_buyer();
  void set_has_status();
  void clear_has_status();
  void set_has_amount();
  void clear_has_amount();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr buyer_;
  ::google::protobuf::uint64 amount_;
  int status_;
  friend struct ::protobuf_protos_2fc2c_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SellInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.c2c.protobuf.SellInfo) */ {
 public:
  SellInfo();
  virtual ~SellInfo();

  SellInfo(const SellInfo& from);

  inline SellInfo& operator=(const SellInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SellInfo(SellInfo&& from) noexcept
    : SellInfo() {
    *this = ::std::move(from);
  }

  inline SellInfo& operator=(SellInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SellInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SellInfo* internal_default_instance() {
    return reinterpret_cast<const SellInfo*>(
               &_SellInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SellInfo* other);
  friend void swap(SellInfo& a, SellInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SellInfo* New() const final {
    return CreateMaybeMessage<SellInfo>(NULL);
  }

  SellInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SellInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SellInfo& from);
  void MergeFrom(const SellInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SellInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes reports = 10;
  int reports_size() const;
  void clear_reports();
  static const int kReportsFieldNumber = 10;
  const ::std::string& reports(int index) const;
  ::std::string* mutable_reports(int index);
  void set_reports(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_reports(int index, ::std::string&& value);
  #endif
  void set_reports(int index, const char* value);
  void set_reports(int index, const void* value, size_t size);
  ::std::string* add_reports();
  void add_reports(const ::std::string& value);
  #if LANG_CXX11
  void add_reports(::std::string&& value);
  #endif
  void add_reports(const char* value);
  void add_reports(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& reports() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_reports();

  // optional bytes protocol_addr = 1;
  bool has_protocol_addr() const;
  void clear_protocol_addr();
  static const int kProtocolAddrFieldNumber = 1;
  const ::std::string& protocol_addr() const;
  void set_protocol_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_protocol_addr(::std::string&& value);
  #endif
  void set_protocol_addr(const char* value);
  void set_protocol_addr(const void* value, size_t size);
  ::std::string* mutable_protocol_addr();
  ::std::string* release_protocol_addr();
  void set_allocated_protocol_addr(::std::string* protocol_addr);

  // optional bytes seller = 2;
  bool has_seller() const;
  void clear_seller();
  static const int kSellerFieldNumber = 2;
  const ::std::string& seller() const;
  void set_seller(const ::std::string& value);
  #if LANG_CXX11
  void set_seller(::std::string&& value);
  #endif
  void set_seller(const char* value);
  void set_seller(const void* value, size_t size);
  ::std::string* mutable_seller();
  ::std::string* release_seller();
  void set_allocated_seller(::std::string* seller);

  // optional bytes receivable = 5;
  bool has_receivable() const;
  void clear_receivable();
  static const int kReceivableFieldNumber = 5;
  const ::std::string& receivable() const;
  void set_receivable(const ::std::string& value);
  #if LANG_CXX11
  void set_receivable(::std::string&& value);
  #endif
  void set_receivable(const char* value);
  void set_receivable(const void* value, size_t size);
  ::std::string* mutable_receivable();
  ::std::string* release_receivable();
  void set_allocated_receivable(::std::string* receivable);

  // optional .zjchain.c2c.protobuf.OrderInfo order_info = 9;
  bool has_order_info() const;
  void clear_order_info();
  static const int kOrderInfoFieldNumber = 9;
  private:
  const ::zjchain::c2c::protobuf::OrderInfo& _internal_order_info() const;
  public:
  const ::zjchain::c2c::protobuf::OrderInfo& order_info() const;
  ::zjchain::c2c::protobuf::OrderInfo* release_order_info();
  ::zjchain::c2c::protobuf::OrderInfo* mutable_order_info();
  void set_allocated_order_info(::zjchain::c2c::protobuf::OrderInfo* order_info);

  // optional uint64 pledge_amount = 3;
  bool has_pledge_amount() const;
  void clear_pledge_amount();
  static const int kPledgeAmountFieldNumber = 3;
  ::google::protobuf::uint64 pledge_amount() const;
  void set_pledge_amount(::google::protobuf::uint64 value);

  // optional uint64 price = 4;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 4;
  ::google::protobuf::uint64 price() const;
  void set_price(::google::protobuf::uint64 value);

  // optional bool manager_released = 6;
  bool has_manager_released() const;
  void clear_manager_released();
  static const int kManagerReleasedFieldNumber = 6;
  bool manager_released() const;
  void set_manager_released(bool value);

  // optional bool seller_released = 7;
  bool has_seller_released() const;
  void clear_seller_released();
  static const int kSellerReleasedFieldNumber = 7;
  bool seller_released() const;
  void set_seller_released(bool value);

  // optional .zjchain.c2c.protobuf.Status status = 8;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 8;
  ::zjchain::c2c::protobuf::Status status() const;
  void set_status(::zjchain::c2c::protobuf::Status value);

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.SellInfo)
 private:
  void set_has_protocol_addr();
  void clear_has_protocol_addr();
  void set_has_seller();
  void clear_has_seller();
  void set_has_pledge_amount();
  void clear_has_pledge_amount();
  void set_has_price();
  void clear_has_price();
  void set_has_receivable();
  void clear_has_receivable();
  void set_has_manager_released();
  void clear_has_manager_released();
  void set_has_seller_released();
  void clear_has_seller_released();
  void set_has_status();
  void clear_has_status();
  void set_has_order_info();
  void clear_has_order_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> reports_;
  ::google::protobuf::internal::ArenaStringPtr protocol_addr_;
  ::google::protobuf::internal::ArenaStringPtr seller_;
  ::google::protobuf::internal::ArenaStringPtr receivable_;
  ::zjchain::c2c::protobuf::OrderInfo* order_info_;
  ::google::protobuf::uint64 pledge_amount_;
  ::google::protobuf::uint64 price_;
  bool manager_released_;
  bool seller_released_;
  int status_;
  friend struct ::protobuf_protos_2fc2c_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewOrder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.c2c.protobuf.NewOrder) */ {
 public:
  NewOrder();
  virtual ~NewOrder();

  NewOrder(const NewOrder& from);

  inline NewOrder& operator=(const NewOrder& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewOrder(NewOrder&& from) noexcept
    : NewOrder() {
    *this = ::std::move(from);
  }

  inline NewOrder& operator=(NewOrder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewOrder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewOrder* internal_default_instance() {
    return reinterpret_cast<const NewOrder*>(
               &_NewOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(NewOrder* other);
  friend void swap(NewOrder& a, NewOrder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewOrder* New() const final {
    return CreateMaybeMessage<NewOrder>(NULL);
  }

  NewOrder* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NewOrder>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NewOrder& from);
  void MergeFrom(const NewOrder& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewOrder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes seller = 1;
  bool has_seller() const;
  void clear_seller();
  static const int kSellerFieldNumber = 1;
  const ::std::string& seller() const;
  void set_seller(const ::std::string& value);
  #if LANG_CXX11
  void set_seller(::std::string&& value);
  #endif
  void set_seller(const char* value);
  void set_seller(const void* value, size_t size);
  ::std::string* mutable_seller();
  ::std::string* release_seller();
  void set_allocated_seller(::std::string* seller);

  // optional bytes buyer = 3;
  bool has_buyer() const;
  void clear_buyer();
  static const int kBuyerFieldNumber = 3;
  const ::std::string& buyer() const;
  void set_buyer(const ::std::string& value);
  #if LANG_CXX11
  void set_buyer(::std::string&& value);
  #endif
  void set_buyer(const char* value);
  void set_buyer(const void* value, size_t size);
  ::std::string* mutable_buyer();
  ::std::string* release_buyer();
  void set_allocated_buyer(::std::string* buyer);

  // optional uint64 amount = 2;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.NewOrder)
 private:
  void set_has_seller();
  void clear_has_seller();
  void set_has_amount();
  void clear_has_amount();
  void set_has_buyer();
  void clear_has_buyer();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr seller_;
  ::google::protobuf::internal::ArenaStringPtr buyer_;
  ::google::protobuf::uint64 amount_;
  friend struct ::protobuf_protos_2fc2c_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewSell : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.c2c.protobuf.NewSell) */ {
 public:
  NewSell();
  virtual ~NewSell();

  NewSell(const NewSell& from);

  inline NewSell& operator=(const NewSell& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewSell(NewSell&& from) noexcept
    : NewSell() {
    *this = ::std::move(from);
  }

  inline NewSell& operator=(NewSell&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewSell& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewSell* internal_default_instance() {
    return reinterpret_cast<const NewSell*>(
               &_NewSell_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(NewSell* other);
  friend void swap(NewSell& a, NewSell& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewSell* New() const final {
    return CreateMaybeMessage<NewSell>(NULL);
  }

  NewSell* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NewSell>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NewSell& from);
  void MergeFrom(const NewSell& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewSell* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes protocol_addr = 1;
  bool has_protocol_addr() const;
  void clear_protocol_addr();
  static const int kProtocolAddrFieldNumber = 1;
  const ::std::string& protocol_addr() const;
  void set_protocol_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_protocol_addr(::std::string&& value);
  #endif
  void set_protocol_addr(const char* value);
  void set_protocol_addr(const void* value, size_t size);
  ::std::string* mutable_protocol_addr();
  ::std::string* release_protocol_addr();
  void set_allocated_protocol_addr(::std::string* protocol_addr);

  // optional bytes seller = 2;
  bool has_seller() const;
  void clear_seller();
  static const int kSellerFieldNumber = 2;
  const ::std::string& seller() const;
  void set_seller(const ::std::string& value);
  #if LANG_CXX11
  void set_seller(::std::string&& value);
  #endif
  void set_seller(const char* value);
  void set_seller(const void* value, size_t size);
  ::std::string* mutable_seller();
  ::std::string* release_seller();
  void set_allocated_seller(::std::string* seller);

  // optional bytes receivable = 5;
  bool has_receivable() const;
  void clear_receivable();
  static const int kReceivableFieldNumber = 5;
  const ::std::string& receivable() const;
  void set_receivable(const ::std::string& value);
  #if LANG_CXX11
  void set_receivable(::std::string&& value);
  #endif
  void set_receivable(const char* value);
  void set_receivable(const void* value, size_t size);
  ::std::string* mutable_receivable();
  ::std::string* release_receivable();
  void set_allocated_receivable(::std::string* receivable);

  // optional uint64 amount = 3;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // optional uint64 price = 4;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 4;
  ::google::protobuf::uint64 price() const;
  void set_price(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.NewSell)
 private:
  void set_has_protocol_addr();
  void clear_has_protocol_addr();
  void set_has_seller();
  void clear_has_seller();
  void set_has_amount();
  void clear_has_amount();
  void set_has_price();
  void clear_has_price();
  void set_has_receivable();
  void clear_has_receivable();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr protocol_addr_;
  ::google::protobuf::internal::ArenaStringPtr seller_;
  ::google::protobuf::internal::ArenaStringPtr receivable_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint64 price_;
  friend struct ::protobuf_protos_2fc2c_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BuyerReport : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.c2c.protobuf.BuyerReport) */ {
 public:
  BuyerReport();
  virtual ~BuyerReport();

  BuyerReport(const BuyerReport& from);

  inline BuyerReport& operator=(const BuyerReport& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BuyerReport(BuyerReport&& from) noexcept
    : BuyerReport() {
    *this = ::std::move(from);
  }

  inline BuyerReport& operator=(BuyerReport&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuyerReport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuyerReport* internal_default_instance() {
    return reinterpret_cast<const BuyerReport*>(
               &_BuyerReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(BuyerReport* other);
  friend void swap(BuyerReport& a, BuyerReport& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BuyerReport* New() const final {
    return CreateMaybeMessage<BuyerReport>(NULL);
  }

  BuyerReport* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BuyerReport>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BuyerReport& from);
  void MergeFrom(const BuyerReport& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuyerReport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes seller = 1;
  bool has_seller() const;
  void clear_seller();
  static const int kSellerFieldNumber = 1;
  const ::std::string& seller() const;
  void set_seller(const ::std::string& value);
  #if LANG_CXX11
  void set_seller(::std::string&& value);
  #endif
  void set_seller(const char* value);
  void set_seller(const void* value, size_t size);
  ::std::string* mutable_seller();
  ::std::string* release_seller();
  void set_allocated_seller(::std::string* seller);

  // optional bytes reports_info = 2;
  bool has_reports_info() const;
  void clear_reports_info();
  static const int kReportsInfoFieldNumber = 2;
  const ::std::string& reports_info() const;
  void set_reports_info(const ::std::string& value);
  #if LANG_CXX11
  void set_reports_info(::std::string&& value);
  #endif
  void set_reports_info(const char* value);
  void set_reports_info(const void* value, size_t size);
  ::std::string* mutable_reports_info();
  ::std::string* release_reports_info();
  void set_allocated_reports_info(::std::string* reports_info);

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.BuyerReport)
 private:
  void set_has_seller();
  void clear_has_seller();
  void set_has_reports_info();
  void clear_has_reports_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr seller_;
  ::google::protobuf::internal::ArenaStringPtr reports_info_;
  friend struct ::protobuf_protos_2fc2c_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetSell : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.c2c.protobuf.GetSell) */ {
 public:
  GetSell();
  virtual ~GetSell();

  GetSell(const GetSell& from);

  inline GetSell& operator=(const GetSell& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetSell(GetSell&& from) noexcept
    : GetSell() {
    *this = ::std::move(from);
  }

  inline GetSell& operator=(GetSell&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSell& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetSell* internal_default_instance() {
    return reinterpret_cast<const GetSell*>(
               &_GetSell_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(GetSell* other);
  friend void swap(GetSell& a, GetSell& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetSell* New() const final {
    return CreateMaybeMessage<GetSell>(NULL);
  }

  GetSell* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetSell>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetSell& from);
  void MergeFrom(const GetSell& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSell* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes seller = 1;
  bool has_seller() const;
  void clear_seller();
  static const int kSellerFieldNumber = 1;
  const ::std::string& seller() const;
  void set_seller(const ::std::string& value);
  #if LANG_CXX11
  void set_seller(::std::string&& value);
  #endif
  void set_seller(const char* value);
  void set_seller(const void* value, size_t size);
  ::std::string* mutable_seller();
  ::std::string* release_seller();
  void set_allocated_seller(::std::string* seller);

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.GetSell)
 private:
  void set_has_seller();
  void clear_has_seller();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr seller_;
  friend struct ::protobuf_protos_2fc2c_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class C2cMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.c2c.protobuf.C2cMessage) */ {
 public:
  C2cMessage();
  virtual ~C2cMessage();

  C2cMessage(const C2cMessage& from);

  inline C2cMessage& operator=(const C2cMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  C2cMessage(C2cMessage&& from) noexcept
    : C2cMessage() {
    *this = ::std::move(from);
  }

  inline C2cMessage& operator=(C2cMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const C2cMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const C2cMessage* internal_default_instance() {
    return reinterpret_cast<const C2cMessage*>(
               &_C2cMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(C2cMessage* other);
  friend void swap(C2cMessage& a, C2cMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline C2cMessage* New() const final {
    return CreateMaybeMessage<C2cMessage>(NULL);
  }

  C2cMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<C2cMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const C2cMessage& from);
  void MergeFrom(const C2cMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C2cMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zjchain.c2c.protobuf.SellInfo sells = 4;
  int sells_size() const;
  void clear_sells();
  static const int kSellsFieldNumber = 4;
  ::zjchain::c2c::protobuf::SellInfo* mutable_sells(int index);
  ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::SellInfo >*
      mutable_sells();
  const ::zjchain::c2c::protobuf::SellInfo& sells(int index) const;
  ::zjchain::c2c::protobuf::SellInfo* add_sells();
  const ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::SellInfo >&
      sells() const;

  // repeated .zjchain.c2c.protobuf.GetSell get_sell = 5;
  int get_sell_size() const;
  void clear_get_sell();
  static const int kGetSellFieldNumber = 5;
  ::zjchain::c2c::protobuf::GetSell* mutable_get_sell(int index);
  ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::GetSell >*
      mutable_get_sell();
  const ::zjchain::c2c::protobuf::GetSell& get_sell(int index) const;
  ::zjchain::c2c::protobuf::GetSell* add_get_sell();
  const ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::GetSell >&
      get_sell() const;

  // optional .zjchain.c2c.protobuf.NewSell sell = 1;
  bool has_sell() const;
  void clear_sell();
  static const int kSellFieldNumber = 1;
  private:
  const ::zjchain::c2c::protobuf::NewSell& _internal_sell() const;
  public:
  const ::zjchain::c2c::protobuf::NewSell& sell() const;
  ::zjchain::c2c::protobuf::NewSell* release_sell();
  ::zjchain::c2c::protobuf::NewSell* mutable_sell();
  void set_allocated_sell(::zjchain::c2c::protobuf::NewSell* sell);

  // optional .zjchain.c2c.protobuf.NewOrder order = 2;
  bool has_order() const;
  void clear_order();
  static const int kOrderFieldNumber = 2;
  private:
  const ::zjchain::c2c::protobuf::NewOrder& _internal_order() const;
  public:
  const ::zjchain::c2c::protobuf::NewOrder& order() const;
  ::zjchain::c2c::protobuf::NewOrder* release_order();
  ::zjchain::c2c::protobuf::NewOrder* mutable_order();
  void set_allocated_order(::zjchain::c2c::protobuf::NewOrder* order);

  // optional .zjchain.c2c.protobuf.BuyerReport report = 3;
  bool has_report() const;
  void clear_report();
  static const int kReportFieldNumber = 3;
  private:
  const ::zjchain::c2c::protobuf::BuyerReport& _internal_report() const;
  public:
  const ::zjchain::c2c::protobuf::BuyerReport& report() const;
  ::zjchain::c2c::protobuf::BuyerReport* release_report();
  ::zjchain::c2c::protobuf::BuyerReport* mutable_report();
  void set_allocated_report(::zjchain::c2c::protobuf::BuyerReport* report);

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.C2cMessage)
 private:
  void set_has_sell();
  void clear_has_sell();
  void set_has_order();
  void clear_has_order();
  void set_has_report();
  void clear_has_report();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::SellInfo > sells_;
  ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::GetSell > get_sell_;
  ::zjchain::c2c::protobuf::NewSell* sell_;
  ::zjchain::c2c::protobuf::NewOrder* order_;
  ::zjchain::c2c::protobuf::BuyerReport* report_;
  friend struct ::protobuf_protos_2fc2c_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// OrderInfo

// optional bytes buyer = 1;
inline bool OrderInfo::has_buyer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderInfo::set_has_buyer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderInfo::clear_has_buyer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderInfo::clear_buyer() {
  buyer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_buyer();
}
inline const ::std::string& OrderInfo::buyer() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.OrderInfo.buyer)
  return buyer_.GetNoArena();
}
inline void OrderInfo::set_buyer(const ::std::string& value) {
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.OrderInfo.buyer)
}
#if LANG_CXX11
inline void OrderInfo::set_buyer(::std::string&& value) {
  set_has_buyer();
  buyer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.OrderInfo.buyer)
}
#endif
inline void OrderInfo::set_buyer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.OrderInfo.buyer)
}
inline void OrderInfo::set_buyer(const void* value, size_t size) {
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.OrderInfo.buyer)
}
inline ::std::string* OrderInfo::mutable_buyer() {
  set_has_buyer();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.OrderInfo.buyer)
  return buyer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OrderInfo::release_buyer() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.OrderInfo.buyer)
  if (!has_buyer()) {
    return NULL;
  }
  clear_has_buyer();
  return buyer_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OrderInfo::set_allocated_buyer(::std::string* buyer) {
  if (buyer != NULL) {
    set_has_buyer();
  } else {
    clear_has_buyer();
  }
  buyer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), buyer);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.OrderInfo.buyer)
}

// optional .zjchain.c2c.protobuf.Status status = 2;
inline bool OrderInfo::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderInfo::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderInfo::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::zjchain::c2c::protobuf::Status OrderInfo::status() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.OrderInfo.status)
  return static_cast< ::zjchain::c2c::protobuf::Status >(status_);
}
inline void OrderInfo::set_status(::zjchain::c2c::protobuf::Status value) {
  assert(::zjchain::c2c::protobuf::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.OrderInfo.status)
}

// optional uint64 amount = 3;
inline bool OrderInfo::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderInfo::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderInfo::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderInfo::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 OrderInfo::amount() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.OrderInfo.amount)
  return amount_;
}
inline void OrderInfo::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.OrderInfo.amount)
}

// -------------------------------------------------------------------

// SellInfo

// optional bytes protocol_addr = 1;
inline bool SellInfo::has_protocol_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SellInfo::set_has_protocol_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SellInfo::clear_has_protocol_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SellInfo::clear_protocol_addr() {
  protocol_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_protocol_addr();
}
inline const ::std::string& SellInfo::protocol_addr() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.protocol_addr)
  return protocol_addr_.GetNoArena();
}
inline void SellInfo::set_protocol_addr(const ::std::string& value) {
  set_has_protocol_addr();
  protocol_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.protocol_addr)
}
#if LANG_CXX11
inline void SellInfo::set_protocol_addr(::std::string&& value) {
  set_has_protocol_addr();
  protocol_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.SellInfo.protocol_addr)
}
#endif
inline void SellInfo::set_protocol_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_protocol_addr();
  protocol_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.SellInfo.protocol_addr)
}
inline void SellInfo::set_protocol_addr(const void* value, size_t size) {
  set_has_protocol_addr();
  protocol_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.SellInfo.protocol_addr)
}
inline ::std::string* SellInfo::mutable_protocol_addr() {
  set_has_protocol_addr();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.SellInfo.protocol_addr)
  return protocol_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SellInfo::release_protocol_addr() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.SellInfo.protocol_addr)
  if (!has_protocol_addr()) {
    return NULL;
  }
  clear_has_protocol_addr();
  return protocol_addr_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SellInfo::set_allocated_protocol_addr(::std::string* protocol_addr) {
  if (protocol_addr != NULL) {
    set_has_protocol_addr();
  } else {
    clear_has_protocol_addr();
  }
  protocol_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol_addr);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.SellInfo.protocol_addr)
}

// optional bytes seller = 2;
inline bool SellInfo::has_seller() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SellInfo::set_has_seller() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SellInfo::clear_has_seller() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SellInfo::clear_seller() {
  seller_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_seller();
}
inline const ::std::string& SellInfo::seller() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.seller)
  return seller_.GetNoArena();
}
inline void SellInfo::set_seller(const ::std::string& value) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.seller)
}
#if LANG_CXX11
inline void SellInfo::set_seller(::std::string&& value) {
  set_has_seller();
  seller_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.SellInfo.seller)
}
#endif
inline void SellInfo::set_seller(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.SellInfo.seller)
}
inline void SellInfo::set_seller(const void* value, size_t size) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.SellInfo.seller)
}
inline ::std::string* SellInfo::mutable_seller() {
  set_has_seller();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.SellInfo.seller)
  return seller_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SellInfo::release_seller() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.SellInfo.seller)
  if (!has_seller()) {
    return NULL;
  }
  clear_has_seller();
  return seller_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SellInfo::set_allocated_seller(::std::string* seller) {
  if (seller != NULL) {
    set_has_seller();
  } else {
    clear_has_seller();
  }
  seller_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), seller);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.SellInfo.seller)
}

// optional uint64 pledge_amount = 3;
inline bool SellInfo::has_pledge_amount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SellInfo::set_has_pledge_amount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SellInfo::clear_has_pledge_amount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SellInfo::clear_pledge_amount() {
  pledge_amount_ = GOOGLE_ULONGLONG(0);
  clear_has_pledge_amount();
}
inline ::google::protobuf::uint64 SellInfo::pledge_amount() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.pledge_amount)
  return pledge_amount_;
}
inline void SellInfo::set_pledge_amount(::google::protobuf::uint64 value) {
  set_has_pledge_amount();
  pledge_amount_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.pledge_amount)
}

// optional uint64 price = 4;
inline bool SellInfo::has_price() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SellInfo::set_has_price() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SellInfo::clear_has_price() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SellInfo::clear_price() {
  price_ = GOOGLE_ULONGLONG(0);
  clear_has_price();
}
inline ::google::protobuf::uint64 SellInfo::price() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.price)
  return price_;
}
inline void SellInfo::set_price(::google::protobuf::uint64 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.price)
}

// optional bytes receivable = 5;
inline bool SellInfo::has_receivable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SellInfo::set_has_receivable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SellInfo::clear_has_receivable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SellInfo::clear_receivable() {
  receivable_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_receivable();
}
inline const ::std::string& SellInfo::receivable() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.receivable)
  return receivable_.GetNoArena();
}
inline void SellInfo::set_receivable(const ::std::string& value) {
  set_has_receivable();
  receivable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.receivable)
}
#if LANG_CXX11
inline void SellInfo::set_receivable(::std::string&& value) {
  set_has_receivable();
  receivable_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.SellInfo.receivable)
}
#endif
inline void SellInfo::set_receivable(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_receivable();
  receivable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.SellInfo.receivable)
}
inline void SellInfo::set_receivable(const void* value, size_t size) {
  set_has_receivable();
  receivable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.SellInfo.receivable)
}
inline ::std::string* SellInfo::mutable_receivable() {
  set_has_receivable();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.SellInfo.receivable)
  return receivable_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SellInfo::release_receivable() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.SellInfo.receivable)
  if (!has_receivable()) {
    return NULL;
  }
  clear_has_receivable();
  return receivable_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SellInfo::set_allocated_receivable(::std::string* receivable) {
  if (receivable != NULL) {
    set_has_receivable();
  } else {
    clear_has_receivable();
  }
  receivable_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), receivable);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.SellInfo.receivable)
}

// optional bool manager_released = 6;
inline bool SellInfo::has_manager_released() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SellInfo::set_has_manager_released() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SellInfo::clear_has_manager_released() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SellInfo::clear_manager_released() {
  manager_released_ = false;
  clear_has_manager_released();
}
inline bool SellInfo::manager_released() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.manager_released)
  return manager_released_;
}
inline void SellInfo::set_manager_released(bool value) {
  set_has_manager_released();
  manager_released_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.manager_released)
}

// optional bool seller_released = 7;
inline bool SellInfo::has_seller_released() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SellInfo::set_has_seller_released() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SellInfo::clear_has_seller_released() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SellInfo::clear_seller_released() {
  seller_released_ = false;
  clear_has_seller_released();
}
inline bool SellInfo::seller_released() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.seller_released)
  return seller_released_;
}
inline void SellInfo::set_seller_released(bool value) {
  set_has_seller_released();
  seller_released_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.seller_released)
}

// optional .zjchain.c2c.protobuf.Status status = 8;
inline bool SellInfo::has_status() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SellInfo::set_has_status() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SellInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SellInfo::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::zjchain::c2c::protobuf::Status SellInfo::status() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.status)
  return static_cast< ::zjchain::c2c::protobuf::Status >(status_);
}
inline void SellInfo::set_status(::zjchain::c2c::protobuf::Status value) {
  assert(::zjchain::c2c::protobuf::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.status)
}

// optional .zjchain.c2c.protobuf.OrderInfo order_info = 9;
inline bool SellInfo::has_order_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SellInfo::set_has_order_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SellInfo::clear_has_order_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SellInfo::clear_order_info() {
  if (order_info_ != NULL) order_info_->Clear();
  clear_has_order_info();
}
inline const ::zjchain::c2c::protobuf::OrderInfo& SellInfo::_internal_order_info() const {
  return *order_info_;
}
inline const ::zjchain::c2c::protobuf::OrderInfo& SellInfo::order_info() const {
  const ::zjchain::c2c::protobuf::OrderInfo* p = order_info_;
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.order_info)
  return p != NULL ? *p : *reinterpret_cast<const ::zjchain::c2c::protobuf::OrderInfo*>(
      &::zjchain::c2c::protobuf::_OrderInfo_default_instance_);
}
inline ::zjchain::c2c::protobuf::OrderInfo* SellInfo::release_order_info() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.SellInfo.order_info)
  clear_has_order_info();
  ::zjchain::c2c::protobuf::OrderInfo* temp = order_info_;
  order_info_ = NULL;
  return temp;
}
inline ::zjchain::c2c::protobuf::OrderInfo* SellInfo::mutable_order_info() {
  set_has_order_info();
  if (order_info_ == NULL) {
    auto* p = CreateMaybeMessage<::zjchain::c2c::protobuf::OrderInfo>(GetArenaNoVirtual());
    order_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.SellInfo.order_info)
  return order_info_;
}
inline void SellInfo::set_allocated_order_info(::zjchain::c2c::protobuf::OrderInfo* order_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete order_info_;
  }
  if (order_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      order_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, order_info, submessage_arena);
    }
    set_has_order_info();
  } else {
    clear_has_order_info();
  }
  order_info_ = order_info;
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.SellInfo.order_info)
}

// repeated bytes reports = 10;
inline int SellInfo::reports_size() const {
  return reports_.size();
}
inline void SellInfo::clear_reports() {
  reports_.Clear();
}
inline const ::std::string& SellInfo::reports(int index) const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.reports)
  return reports_.Get(index);
}
inline ::std::string* SellInfo::mutable_reports(int index) {
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.SellInfo.reports)
  return reports_.Mutable(index);
}
inline void SellInfo::set_reports(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.reports)
  reports_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SellInfo::set_reports(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.reports)
  reports_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SellInfo::set_reports(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  reports_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.SellInfo.reports)
}
inline void SellInfo::set_reports(int index, const void* value, size_t size) {
  reports_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.SellInfo.reports)
}
inline ::std::string* SellInfo::add_reports() {
  // @@protoc_insertion_point(field_add_mutable:zjchain.c2c.protobuf.SellInfo.reports)
  return reports_.Add();
}
inline void SellInfo::add_reports(const ::std::string& value) {
  reports_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zjchain.c2c.protobuf.SellInfo.reports)
}
#if LANG_CXX11
inline void SellInfo::add_reports(::std::string&& value) {
  reports_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zjchain.c2c.protobuf.SellInfo.reports)
}
#endif
inline void SellInfo::add_reports(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  reports_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zjchain.c2c.protobuf.SellInfo.reports)
}
inline void SellInfo::add_reports(const void* value, size_t size) {
  reports_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zjchain.c2c.protobuf.SellInfo.reports)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SellInfo::reports() const {
  // @@protoc_insertion_point(field_list:zjchain.c2c.protobuf.SellInfo.reports)
  return reports_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SellInfo::mutable_reports() {
  // @@protoc_insertion_point(field_mutable_list:zjchain.c2c.protobuf.SellInfo.reports)
  return &reports_;
}

// -------------------------------------------------------------------

// NewOrder

// optional bytes seller = 1;
inline bool NewOrder::has_seller() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewOrder::set_has_seller() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewOrder::clear_has_seller() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewOrder::clear_seller() {
  seller_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_seller();
}
inline const ::std::string& NewOrder::seller() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewOrder.seller)
  return seller_.GetNoArena();
}
inline void NewOrder::set_seller(const ::std::string& value) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewOrder.seller)
}
#if LANG_CXX11
inline void NewOrder::set_seller(::std::string&& value) {
  set_has_seller();
  seller_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.NewOrder.seller)
}
#endif
inline void NewOrder::set_seller(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.NewOrder.seller)
}
inline void NewOrder::set_seller(const void* value, size_t size) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.NewOrder.seller)
}
inline ::std::string* NewOrder::mutable_seller() {
  set_has_seller();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.NewOrder.seller)
  return seller_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewOrder::release_seller() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.NewOrder.seller)
  if (!has_seller()) {
    return NULL;
  }
  clear_has_seller();
  return seller_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewOrder::set_allocated_seller(::std::string* seller) {
  if (seller != NULL) {
    set_has_seller();
  } else {
    clear_has_seller();
  }
  seller_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), seller);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.NewOrder.seller)
}

// optional uint64 amount = 2;
inline bool NewOrder::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewOrder::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewOrder::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewOrder::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 NewOrder::amount() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewOrder.amount)
  return amount_;
}
inline void NewOrder::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewOrder.amount)
}

// optional bytes buyer = 3;
inline bool NewOrder::has_buyer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewOrder::set_has_buyer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewOrder::clear_has_buyer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewOrder::clear_buyer() {
  buyer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_buyer();
}
inline const ::std::string& NewOrder::buyer() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewOrder.buyer)
  return buyer_.GetNoArena();
}
inline void NewOrder::set_buyer(const ::std::string& value) {
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewOrder.buyer)
}
#if LANG_CXX11
inline void NewOrder::set_buyer(::std::string&& value) {
  set_has_buyer();
  buyer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.NewOrder.buyer)
}
#endif
inline void NewOrder::set_buyer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.NewOrder.buyer)
}
inline void NewOrder::set_buyer(const void* value, size_t size) {
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.NewOrder.buyer)
}
inline ::std::string* NewOrder::mutable_buyer() {
  set_has_buyer();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.NewOrder.buyer)
  return buyer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewOrder::release_buyer() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.NewOrder.buyer)
  if (!has_buyer()) {
    return NULL;
  }
  clear_has_buyer();
  return buyer_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewOrder::set_allocated_buyer(::std::string* buyer) {
  if (buyer != NULL) {
    set_has_buyer();
  } else {
    clear_has_buyer();
  }
  buyer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), buyer);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.NewOrder.buyer)
}

// -------------------------------------------------------------------

// NewSell

// optional bytes protocol_addr = 1;
inline bool NewSell::has_protocol_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewSell::set_has_protocol_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewSell::clear_has_protocol_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewSell::clear_protocol_addr() {
  protocol_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_protocol_addr();
}
inline const ::std::string& NewSell::protocol_addr() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewSell.protocol_addr)
  return protocol_addr_.GetNoArena();
}
inline void NewSell::set_protocol_addr(const ::std::string& value) {
  set_has_protocol_addr();
  protocol_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewSell.protocol_addr)
}
#if LANG_CXX11
inline void NewSell::set_protocol_addr(::std::string&& value) {
  set_has_protocol_addr();
  protocol_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.NewSell.protocol_addr)
}
#endif
inline void NewSell::set_protocol_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_protocol_addr();
  protocol_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.NewSell.protocol_addr)
}
inline void NewSell::set_protocol_addr(const void* value, size_t size) {
  set_has_protocol_addr();
  protocol_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.NewSell.protocol_addr)
}
inline ::std::string* NewSell::mutable_protocol_addr() {
  set_has_protocol_addr();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.NewSell.protocol_addr)
  return protocol_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewSell::release_protocol_addr() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.NewSell.protocol_addr)
  if (!has_protocol_addr()) {
    return NULL;
  }
  clear_has_protocol_addr();
  return protocol_addr_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewSell::set_allocated_protocol_addr(::std::string* protocol_addr) {
  if (protocol_addr != NULL) {
    set_has_protocol_addr();
  } else {
    clear_has_protocol_addr();
  }
  protocol_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol_addr);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.NewSell.protocol_addr)
}

// optional bytes seller = 2;
inline bool NewSell::has_seller() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewSell::set_has_seller() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewSell::clear_has_seller() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewSell::clear_seller() {
  seller_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_seller();
}
inline const ::std::string& NewSell::seller() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewSell.seller)
  return seller_.GetNoArena();
}
inline void NewSell::set_seller(const ::std::string& value) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewSell.seller)
}
#if LANG_CXX11
inline void NewSell::set_seller(::std::string&& value) {
  set_has_seller();
  seller_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.NewSell.seller)
}
#endif
inline void NewSell::set_seller(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.NewSell.seller)
}
inline void NewSell::set_seller(const void* value, size_t size) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.NewSell.seller)
}
inline ::std::string* NewSell::mutable_seller() {
  set_has_seller();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.NewSell.seller)
  return seller_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewSell::release_seller() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.NewSell.seller)
  if (!has_seller()) {
    return NULL;
  }
  clear_has_seller();
  return seller_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewSell::set_allocated_seller(::std::string* seller) {
  if (seller != NULL) {
    set_has_seller();
  } else {
    clear_has_seller();
  }
  seller_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), seller);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.NewSell.seller)
}

// optional uint64 amount = 3;
inline bool NewSell::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewSell::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewSell::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewSell::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 NewSell::amount() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewSell.amount)
  return amount_;
}
inline void NewSell::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewSell.amount)
}

// optional uint64 price = 4;
inline bool NewSell::has_price() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NewSell::set_has_price() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NewSell::clear_has_price() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NewSell::clear_price() {
  price_ = GOOGLE_ULONGLONG(0);
  clear_has_price();
}
inline ::google::protobuf::uint64 NewSell::price() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewSell.price)
  return price_;
}
inline void NewSell::set_price(::google::protobuf::uint64 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewSell.price)
}

// optional bytes receivable = 5;
inline bool NewSell::has_receivable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewSell::set_has_receivable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewSell::clear_has_receivable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewSell::clear_receivable() {
  receivable_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_receivable();
}
inline const ::std::string& NewSell::receivable() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewSell.receivable)
  return receivable_.GetNoArena();
}
inline void NewSell::set_receivable(const ::std::string& value) {
  set_has_receivable();
  receivable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewSell.receivable)
}
#if LANG_CXX11
inline void NewSell::set_receivable(::std::string&& value) {
  set_has_receivable();
  receivable_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.NewSell.receivable)
}
#endif
inline void NewSell::set_receivable(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_receivable();
  receivable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.NewSell.receivable)
}
inline void NewSell::set_receivable(const void* value, size_t size) {
  set_has_receivable();
  receivable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.NewSell.receivable)
}
inline ::std::string* NewSell::mutable_receivable() {
  set_has_receivable();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.NewSell.receivable)
  return receivable_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewSell::release_receivable() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.NewSell.receivable)
  if (!has_receivable()) {
    return NULL;
  }
  clear_has_receivable();
  return receivable_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewSell::set_allocated_receivable(::std::string* receivable) {
  if (receivable != NULL) {
    set_has_receivable();
  } else {
    clear_has_receivable();
  }
  receivable_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), receivable);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.NewSell.receivable)
}

// -------------------------------------------------------------------

// BuyerReport

// optional bytes seller = 1;
inline bool BuyerReport::has_seller() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuyerReport::set_has_seller() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuyerReport::clear_has_seller() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuyerReport::clear_seller() {
  seller_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_seller();
}
inline const ::std::string& BuyerReport::seller() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.BuyerReport.seller)
  return seller_.GetNoArena();
}
inline void BuyerReport::set_seller(const ::std::string& value) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.BuyerReport.seller)
}
#if LANG_CXX11
inline void BuyerReport::set_seller(::std::string&& value) {
  set_has_seller();
  seller_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.BuyerReport.seller)
}
#endif
inline void BuyerReport::set_seller(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.BuyerReport.seller)
}
inline void BuyerReport::set_seller(const void* value, size_t size) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.BuyerReport.seller)
}
inline ::std::string* BuyerReport::mutable_seller() {
  set_has_seller();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.BuyerReport.seller)
  return seller_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuyerReport::release_seller() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.BuyerReport.seller)
  if (!has_seller()) {
    return NULL;
  }
  clear_has_seller();
  return seller_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuyerReport::set_allocated_seller(::std::string* seller) {
  if (seller != NULL) {
    set_has_seller();
  } else {
    clear_has_seller();
  }
  seller_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), seller);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.BuyerReport.seller)
}

// optional bytes reports_info = 2;
inline bool BuyerReport::has_reports_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuyerReport::set_has_reports_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuyerReport::clear_has_reports_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuyerReport::clear_reports_info() {
  reports_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reports_info();
}
inline const ::std::string& BuyerReport::reports_info() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.BuyerReport.reports_info)
  return reports_info_.GetNoArena();
}
inline void BuyerReport::set_reports_info(const ::std::string& value) {
  set_has_reports_info();
  reports_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.BuyerReport.reports_info)
}
#if LANG_CXX11
inline void BuyerReport::set_reports_info(::std::string&& value) {
  set_has_reports_info();
  reports_info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.BuyerReport.reports_info)
}
#endif
inline void BuyerReport::set_reports_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reports_info();
  reports_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.BuyerReport.reports_info)
}
inline void BuyerReport::set_reports_info(const void* value, size_t size) {
  set_has_reports_info();
  reports_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.BuyerReport.reports_info)
}
inline ::std::string* BuyerReport::mutable_reports_info() {
  set_has_reports_info();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.BuyerReport.reports_info)
  return reports_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuyerReport::release_reports_info() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.BuyerReport.reports_info)
  if (!has_reports_info()) {
    return NULL;
  }
  clear_has_reports_info();
  return reports_info_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuyerReport::set_allocated_reports_info(::std::string* reports_info) {
  if (reports_info != NULL) {
    set_has_reports_info();
  } else {
    clear_has_reports_info();
  }
  reports_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reports_info);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.BuyerReport.reports_info)
}

// -------------------------------------------------------------------

// GetSell

// optional bytes seller = 1;
inline bool GetSell::has_seller() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSell::set_has_seller() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSell::clear_has_seller() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSell::clear_seller() {
  seller_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_seller();
}
inline const ::std::string& GetSell::seller() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.GetSell.seller)
  return seller_.GetNoArena();
}
inline void GetSell::set_seller(const ::std::string& value) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.GetSell.seller)
}
#if LANG_CXX11
inline void GetSell::set_seller(::std::string&& value) {
  set_has_seller();
  seller_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.GetSell.seller)
}
#endif
inline void GetSell::set_seller(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.GetSell.seller)
}
inline void GetSell::set_seller(const void* value, size_t size) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.GetSell.seller)
}
inline ::std::string* GetSell::mutable_seller() {
  set_has_seller();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.GetSell.seller)
  return seller_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetSell::release_seller() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.GetSell.seller)
  if (!has_seller()) {
    return NULL;
  }
  clear_has_seller();
  return seller_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetSell::set_allocated_seller(::std::string* seller) {
  if (seller != NULL) {
    set_has_seller();
  } else {
    clear_has_seller();
  }
  seller_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), seller);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.GetSell.seller)
}

// -------------------------------------------------------------------

// C2cMessage

// optional .zjchain.c2c.protobuf.NewSell sell = 1;
inline bool C2cMessage::has_sell() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2cMessage::set_has_sell() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2cMessage::clear_has_sell() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2cMessage::clear_sell() {
  if (sell_ != NULL) sell_->Clear();
  clear_has_sell();
}
inline const ::zjchain::c2c::protobuf::NewSell& C2cMessage::_internal_sell() const {
  return *sell_;
}
inline const ::zjchain::c2c::protobuf::NewSell& C2cMessage::sell() const {
  const ::zjchain::c2c::protobuf::NewSell* p = sell_;
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.C2cMessage.sell)
  return p != NULL ? *p : *reinterpret_cast<const ::zjchain::c2c::protobuf::NewSell*>(
      &::zjchain::c2c::protobuf::_NewSell_default_instance_);
}
inline ::zjchain::c2c::protobuf::NewSell* C2cMessage::release_sell() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.C2cMessage.sell)
  clear_has_sell();
  ::zjchain::c2c::protobuf::NewSell* temp = sell_;
  sell_ = NULL;
  return temp;
}
inline ::zjchain::c2c::protobuf::NewSell* C2cMessage::mutable_sell() {
  set_has_sell();
  if (sell_ == NULL) {
    auto* p = CreateMaybeMessage<::zjchain::c2c::protobuf::NewSell>(GetArenaNoVirtual());
    sell_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.C2cMessage.sell)
  return sell_;
}
inline void C2cMessage::set_allocated_sell(::zjchain::c2c::protobuf::NewSell* sell) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sell_;
  }
  if (sell) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sell = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sell, submessage_arena);
    }
    set_has_sell();
  } else {
    clear_has_sell();
  }
  sell_ = sell;
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.C2cMessage.sell)
}

// optional .zjchain.c2c.protobuf.NewOrder order = 2;
inline bool C2cMessage::has_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2cMessage::set_has_order() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2cMessage::clear_has_order() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2cMessage::clear_order() {
  if (order_ != NULL) order_->Clear();
  clear_has_order();
}
inline const ::zjchain::c2c::protobuf::NewOrder& C2cMessage::_internal_order() const {
  return *order_;
}
inline const ::zjchain::c2c::protobuf::NewOrder& C2cMessage::order() const {
  const ::zjchain::c2c::protobuf::NewOrder* p = order_;
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.C2cMessage.order)
  return p != NULL ? *p : *reinterpret_cast<const ::zjchain::c2c::protobuf::NewOrder*>(
      &::zjchain::c2c::protobuf::_NewOrder_default_instance_);
}
inline ::zjchain::c2c::protobuf::NewOrder* C2cMessage::release_order() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.C2cMessage.order)
  clear_has_order();
  ::zjchain::c2c::protobuf::NewOrder* temp = order_;
  order_ = NULL;
  return temp;
}
inline ::zjchain::c2c::protobuf::NewOrder* C2cMessage::mutable_order() {
  set_has_order();
  if (order_ == NULL) {
    auto* p = CreateMaybeMessage<::zjchain::c2c::protobuf::NewOrder>(GetArenaNoVirtual());
    order_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.C2cMessage.order)
  return order_;
}
inline void C2cMessage::set_allocated_order(::zjchain::c2c::protobuf::NewOrder* order) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete order_;
  }
  if (order) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      order = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    set_has_order();
  } else {
    clear_has_order();
  }
  order_ = order;
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.C2cMessage.order)
}

// optional .zjchain.c2c.protobuf.BuyerReport report = 3;
inline bool C2cMessage::has_report() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void C2cMessage::set_has_report() {
  _has_bits_[0] |= 0x00000004u;
}
inline void C2cMessage::clear_has_report() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void C2cMessage::clear_report() {
  if (report_ != NULL) report_->Clear();
  clear_has_report();
}
inline const ::zjchain::c2c::protobuf::BuyerReport& C2cMessage::_internal_report() const {
  return *report_;
}
inline const ::zjchain::c2c::protobuf::BuyerReport& C2cMessage::report() const {
  const ::zjchain::c2c::protobuf::BuyerReport* p = report_;
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.C2cMessage.report)
  return p != NULL ? *p : *reinterpret_cast<const ::zjchain::c2c::protobuf::BuyerReport*>(
      &::zjchain::c2c::protobuf::_BuyerReport_default_instance_);
}
inline ::zjchain::c2c::protobuf::BuyerReport* C2cMessage::release_report() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.C2cMessage.report)
  clear_has_report();
  ::zjchain::c2c::protobuf::BuyerReport* temp = report_;
  report_ = NULL;
  return temp;
}
inline ::zjchain::c2c::protobuf::BuyerReport* C2cMessage::mutable_report() {
  set_has_report();
  if (report_ == NULL) {
    auto* p = CreateMaybeMessage<::zjchain::c2c::protobuf::BuyerReport>(GetArenaNoVirtual());
    report_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.C2cMessage.report)
  return report_;
}
inline void C2cMessage::set_allocated_report(::zjchain::c2c::protobuf::BuyerReport* report) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete report_;
  }
  if (report) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      report = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, report, submessage_arena);
    }
    set_has_report();
  } else {
    clear_has_report();
  }
  report_ = report;
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.C2cMessage.report)
}

// repeated .zjchain.c2c.protobuf.SellInfo sells = 4;
inline int C2cMessage::sells_size() const {
  return sells_.size();
}
inline void C2cMessage::clear_sells() {
  sells_.Clear();
}
inline ::zjchain::c2c::protobuf::SellInfo* C2cMessage::mutable_sells(int index) {
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.C2cMessage.sells)
  return sells_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::SellInfo >*
C2cMessage::mutable_sells() {
  // @@protoc_insertion_point(field_mutable_list:zjchain.c2c.protobuf.C2cMessage.sells)
  return &sells_;
}
inline const ::zjchain::c2c::protobuf::SellInfo& C2cMessage::sells(int index) const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.C2cMessage.sells)
  return sells_.Get(index);
}
inline ::zjchain::c2c::protobuf::SellInfo* C2cMessage::add_sells() {
  // @@protoc_insertion_point(field_add:zjchain.c2c.protobuf.C2cMessage.sells)
  return sells_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::SellInfo >&
C2cMessage::sells() const {
  // @@protoc_insertion_point(field_list:zjchain.c2c.protobuf.C2cMessage.sells)
  return sells_;
}

// repeated .zjchain.c2c.protobuf.GetSell get_sell = 5;
inline int C2cMessage::get_sell_size() const {
  return get_sell_.size();
}
inline void C2cMessage::clear_get_sell() {
  get_sell_.Clear();
}
inline ::zjchain::c2c::protobuf::GetSell* C2cMessage::mutable_get_sell(int index) {
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.C2cMessage.get_sell)
  return get_sell_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::GetSell >*
C2cMessage::mutable_get_sell() {
  // @@protoc_insertion_point(field_mutable_list:zjchain.c2c.protobuf.C2cMessage.get_sell)
  return &get_sell_;
}
inline const ::zjchain::c2c::protobuf::GetSell& C2cMessage::get_sell(int index) const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.C2cMessage.get_sell)
  return get_sell_.Get(index);
}
inline ::zjchain::c2c::protobuf::GetSell* C2cMessage::add_get_sell() {
  // @@protoc_insertion_point(field_add:zjchain.c2c.protobuf.C2cMessage.get_sell)
  return get_sell_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::GetSell >&
C2cMessage::get_sell() const {
  // @@protoc_insertion_point(field_list:zjchain.c2c.protobuf.C2cMessage.get_sell)
  return get_sell_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace c2c
}  // namespace zjchain

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::zjchain::c2c::protobuf::Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zjchain::c2c::protobuf::Status>() {
  return ::zjchain::c2c::protobuf::Status_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_protos_2fc2c_2eproto
