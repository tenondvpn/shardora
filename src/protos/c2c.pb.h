// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/c2c.proto

#ifndef PROTOBUF_INCLUDED_protos_2fc2c_2eproto
#define PROTOBUF_INCLUDED_protos_2fc2c_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_protos_2fc2c_2eproto 

namespace protobuf_protos_2fc2c_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_protos_2fc2c_2eproto
namespace zjchain {
namespace c2c {
namespace protobuf {
class BuyerReport;
class BuyerReportDefaultTypeInternal;
extern BuyerReportDefaultTypeInternal _BuyerReport_default_instance_;
class C2cMessage;
class C2cMessageDefaultTypeInternal;
extern C2cMessageDefaultTypeInternal _C2cMessage_default_instance_;
class NewOrder;
class NewOrderDefaultTypeInternal;
extern NewOrderDefaultTypeInternal _NewOrder_default_instance_;
class NewSell;
class NewSellDefaultTypeInternal;
extern NewSellDefaultTypeInternal _NewSell_default_instance_;
class OrderInfo;
class OrderInfoDefaultTypeInternal;
extern OrderInfoDefaultTypeInternal _OrderInfo_default_instance_;
class SellInfo;
class SellInfoDefaultTypeInternal;
extern SellInfoDefaultTypeInternal _SellInfo_default_instance_;
}  // namespace protobuf
}  // namespace c2c
}  // namespace zjchain
namespace google {
namespace protobuf {
template<> ::zjchain::c2c::protobuf::BuyerReport* Arena::CreateMaybeMessage<::zjchain::c2c::protobuf::BuyerReport>(Arena*);
template<> ::zjchain::c2c::protobuf::C2cMessage* Arena::CreateMaybeMessage<::zjchain::c2c::protobuf::C2cMessage>(Arena*);
template<> ::zjchain::c2c::protobuf::NewOrder* Arena::CreateMaybeMessage<::zjchain::c2c::protobuf::NewOrder>(Arena*);
template<> ::zjchain::c2c::protobuf::NewSell* Arena::CreateMaybeMessage<::zjchain::c2c::protobuf::NewSell>(Arena*);
template<> ::zjchain::c2c::protobuf::OrderInfo* Arena::CreateMaybeMessage<::zjchain::c2c::protobuf::OrderInfo>(Arena*);
template<> ::zjchain::c2c::protobuf::SellInfo* Arena::CreateMaybeMessage<::zjchain::c2c::protobuf::SellInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace zjchain {
namespace c2c {
namespace protobuf {

enum OrderStatus {
  kDefault = 0,
  kConfirmed = 1,
  kReported = 2
};
bool OrderStatus_IsValid(int value);
const OrderStatus OrderStatus_MIN = kDefault;
const OrderStatus OrderStatus_MAX = kReported;
const int OrderStatus_ARRAYSIZE = OrderStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderStatus_descriptor();
inline const ::std::string& OrderStatus_Name(OrderStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderStatus_descriptor(), value);
}
inline bool OrderStatus_Parse(
    const ::std::string& name, OrderStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderStatus>(
    OrderStatus_descriptor(), name, value);
}
// ===================================================================

class SellInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.c2c.protobuf.SellInfo) */ {
 public:
  SellInfo();
  virtual ~SellInfo();

  SellInfo(const SellInfo& from);

  inline SellInfo& operator=(const SellInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SellInfo(SellInfo&& from) noexcept
    : SellInfo() {
    *this = ::std::move(from);
  }

  inline SellInfo& operator=(SellInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SellInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SellInfo* internal_default_instance() {
    return reinterpret_cast<const SellInfo*>(
               &_SellInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SellInfo* other);
  friend void swap(SellInfo& a, SellInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SellInfo* New() const final {
    return CreateMaybeMessage<SellInfo>(NULL);
  }

  SellInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SellInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SellInfo& from);
  void MergeFrom(const SellInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SellInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes protocol_addr = 2;
  bool has_protocol_addr() const;
  void clear_protocol_addr();
  static const int kProtocolAddrFieldNumber = 2;
  const ::std::string& protocol_addr() const;
  void set_protocol_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_protocol_addr(::std::string&& value);
  #endif
  void set_protocol_addr(const char* value);
  void set_protocol_addr(const void* value, size_t size);
  ::std::string* mutable_protocol_addr();
  ::std::string* release_protocol_addr();
  void set_allocated_protocol_addr(::std::string* protocol_addr);

  // optional bytes seller = 3;
  bool has_seller() const;
  void clear_seller();
  static const int kSellerFieldNumber = 3;
  const ::std::string& seller() const;
  void set_seller(const ::std::string& value);
  #if LANG_CXX11
  void set_seller(::std::string&& value);
  #endif
  void set_seller(const char* value);
  void set_seller(const void* value, size_t size);
  ::std::string* mutable_seller();
  ::std::string* release_seller();
  void set_allocated_seller(::std::string* seller);

  // optional bytes receivable = 6;
  bool has_receivable() const;
  void clear_receivable();
  static const int kReceivableFieldNumber = 6;
  const ::std::string& receivable() const;
  void set_receivable(const ::std::string& value);
  #if LANG_CXX11
  void set_receivable(::std::string&& value);
  #endif
  void set_receivable(const char* value);
  void set_receivable(const void* value, size_t size);
  ::std::string* mutable_receivable();
  ::std::string* release_receivable();
  void set_allocated_receivable(::std::string* receivable);

  // optional uint64 sell_id = 1;
  bool has_sell_id() const;
  void clear_sell_id();
  static const int kSellIdFieldNumber = 1;
  ::google::protobuf::uint64 sell_id() const;
  void set_sell_id(::google::protobuf::uint64 value);

  // optional uint64 pledge_amount = 4;
  bool has_pledge_amount() const;
  void clear_pledge_amount();
  static const int kPledgeAmountFieldNumber = 4;
  ::google::protobuf::uint64 pledge_amount() const;
  void set_pledge_amount(::google::protobuf::uint64 value);

  // optional uint64 price = 5;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 5;
  ::google::protobuf::uint64 price() const;
  void set_price(::google::protobuf::uint64 value);

  // optional bool manager_released = 7;
  bool has_manager_released() const;
  void clear_manager_released();
  static const int kManagerReleasedFieldNumber = 7;
  bool manager_released() const;
  void set_manager_released(bool value);

  // optional bool seller_released = 8;
  bool has_seller_released() const;
  void clear_seller_released();
  static const int kSellerReleasedFieldNumber = 8;
  bool seller_released() const;
  void set_seller_released(bool value);

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.SellInfo)
 private:
  void set_has_sell_id();
  void clear_has_sell_id();
  void set_has_protocol_addr();
  void clear_has_protocol_addr();
  void set_has_seller();
  void clear_has_seller();
  void set_has_pledge_amount();
  void clear_has_pledge_amount();
  void set_has_price();
  void clear_has_price();
  void set_has_receivable();
  void clear_has_receivable();
  void set_has_manager_released();
  void clear_has_manager_released();
  void set_has_seller_released();
  void clear_has_seller_released();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr protocol_addr_;
  ::google::protobuf::internal::ArenaStringPtr seller_;
  ::google::protobuf::internal::ArenaStringPtr receivable_;
  ::google::protobuf::uint64 sell_id_;
  ::google::protobuf::uint64 pledge_amount_;
  ::google::protobuf::uint64 price_;
  bool manager_released_;
  bool seller_released_;
  friend struct ::protobuf_protos_2fc2c_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OrderInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.c2c.protobuf.OrderInfo) */ {
 public:
  OrderInfo();
  virtual ~OrderInfo();

  OrderInfo(const OrderInfo& from);

  inline OrderInfo& operator=(const OrderInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OrderInfo(OrderInfo&& from) noexcept
    : OrderInfo() {
    *this = ::std::move(from);
  }

  inline OrderInfo& operator=(OrderInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrderInfo* internal_default_instance() {
    return reinterpret_cast<const OrderInfo*>(
               &_OrderInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(OrderInfo* other);
  friend void swap(OrderInfo& a, OrderInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OrderInfo* New() const final {
    return CreateMaybeMessage<OrderInfo>(NULL);
  }

  OrderInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OrderInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OrderInfo& from);
  void MergeFrom(const OrderInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes buyer = 2;
  bool has_buyer() const;
  void clear_buyer();
  static const int kBuyerFieldNumber = 2;
  const ::std::string& buyer() const;
  void set_buyer(const ::std::string& value);
  #if LANG_CXX11
  void set_buyer(::std::string&& value);
  #endif
  void set_buyer(const char* value);
  void set_buyer(const void* value, size_t size);
  ::std::string* mutable_buyer();
  ::std::string* release_buyer();
  void set_allocated_buyer(::std::string* buyer);

  // optional bytes reports_info = 6;
  bool has_reports_info() const;
  void clear_reports_info();
  static const int kReportsInfoFieldNumber = 6;
  const ::std::string& reports_info() const;
  void set_reports_info(const ::std::string& value);
  #if LANG_CXX11
  void set_reports_info(::std::string&& value);
  #endif
  void set_reports_info(const char* value);
  void set_reports_info(const void* value, size_t size);
  ::std::string* mutable_reports_info();
  ::std::string* release_reports_info();
  void set_allocated_reports_info(::std::string* reports_info);

  // optional .zjchain.c2c.protobuf.SellInfo sell = 1;
  bool has_sell() const;
  void clear_sell();
  static const int kSellFieldNumber = 1;
  private:
  const ::zjchain::c2c::protobuf::SellInfo& _internal_sell() const;
  public:
  const ::zjchain::c2c::protobuf::SellInfo& sell() const;
  ::zjchain::c2c::protobuf::SellInfo* release_sell();
  ::zjchain::c2c::protobuf::SellInfo* mutable_sell();
  void set_allocated_sell(::zjchain::c2c::protobuf::SellInfo* sell);

  // optional uint64 order_id = 3;
  bool has_order_id() const;
  void clear_order_id();
  static const int kOrderIdFieldNumber = 3;
  ::google::protobuf::uint64 order_id() const;
  void set_order_id(::google::protobuf::uint64 value);

  // optional uint64 amount = 5;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 5;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // optional .zjchain.c2c.protobuf.OrderStatus status = 4;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  ::zjchain::c2c::protobuf::OrderStatus status() const;
  void set_status(::zjchain::c2c::protobuf::OrderStatus value);

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.OrderInfo)
 private:
  void set_has_sell();
  void clear_has_sell();
  void set_has_buyer();
  void clear_has_buyer();
  void set_has_order_id();
  void clear_has_order_id();
  void set_has_status();
  void clear_has_status();
  void set_has_amount();
  void clear_has_amount();
  void set_has_reports_info();
  void clear_has_reports_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr buyer_;
  ::google::protobuf::internal::ArenaStringPtr reports_info_;
  ::zjchain::c2c::protobuf::SellInfo* sell_;
  ::google::protobuf::uint64 order_id_;
  ::google::protobuf::uint64 amount_;
  int status_;
  friend struct ::protobuf_protos_2fc2c_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewOrder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.c2c.protobuf.NewOrder) */ {
 public:
  NewOrder();
  virtual ~NewOrder();

  NewOrder(const NewOrder& from);

  inline NewOrder& operator=(const NewOrder& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewOrder(NewOrder&& from) noexcept
    : NewOrder() {
    *this = ::std::move(from);
  }

  inline NewOrder& operator=(NewOrder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewOrder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewOrder* internal_default_instance() {
    return reinterpret_cast<const NewOrder*>(
               &_NewOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(NewOrder* other);
  friend void swap(NewOrder& a, NewOrder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewOrder* New() const final {
    return CreateMaybeMessage<NewOrder>(NULL);
  }

  NewOrder* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NewOrder>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NewOrder& from);
  void MergeFrom(const NewOrder& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewOrder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes buyer = 3;
  bool has_buyer() const;
  void clear_buyer();
  static const int kBuyerFieldNumber = 3;
  const ::std::string& buyer() const;
  void set_buyer(const ::std::string& value);
  #if LANG_CXX11
  void set_buyer(::std::string&& value);
  #endif
  void set_buyer(const char* value);
  void set_buyer(const void* value, size_t size);
  ::std::string* mutable_buyer();
  ::std::string* release_buyer();
  void set_allocated_buyer(::std::string* buyer);

  // optional uint64 sell_id = 1;
  bool has_sell_id() const;
  void clear_sell_id();
  static const int kSellIdFieldNumber = 1;
  ::google::protobuf::uint64 sell_id() const;
  void set_sell_id(::google::protobuf::uint64 value);

  // optional uint64 amount = 2;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.NewOrder)
 private:
  void set_has_sell_id();
  void clear_has_sell_id();
  void set_has_amount();
  void clear_has_amount();
  void set_has_buyer();
  void clear_has_buyer();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr buyer_;
  ::google::protobuf::uint64 sell_id_;
  ::google::protobuf::uint64 amount_;
  friend struct ::protobuf_protos_2fc2c_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewSell : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.c2c.protobuf.NewSell) */ {
 public:
  NewSell();
  virtual ~NewSell();

  NewSell(const NewSell& from);

  inline NewSell& operator=(const NewSell& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewSell(NewSell&& from) noexcept
    : NewSell() {
    *this = ::std::move(from);
  }

  inline NewSell& operator=(NewSell&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewSell& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewSell* internal_default_instance() {
    return reinterpret_cast<const NewSell*>(
               &_NewSell_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(NewSell* other);
  friend void swap(NewSell& a, NewSell& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewSell* New() const final {
    return CreateMaybeMessage<NewSell>(NULL);
  }

  NewSell* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NewSell>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NewSell& from);
  void MergeFrom(const NewSell& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewSell* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes protocol_addr = 1;
  bool has_protocol_addr() const;
  void clear_protocol_addr();
  static const int kProtocolAddrFieldNumber = 1;
  const ::std::string& protocol_addr() const;
  void set_protocol_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_protocol_addr(::std::string&& value);
  #endif
  void set_protocol_addr(const char* value);
  void set_protocol_addr(const void* value, size_t size);
  ::std::string* mutable_protocol_addr();
  ::std::string* release_protocol_addr();
  void set_allocated_protocol_addr(::std::string* protocol_addr);

  // optional bytes seller = 2;
  bool has_seller() const;
  void clear_seller();
  static const int kSellerFieldNumber = 2;
  const ::std::string& seller() const;
  void set_seller(const ::std::string& value);
  #if LANG_CXX11
  void set_seller(::std::string&& value);
  #endif
  void set_seller(const char* value);
  void set_seller(const void* value, size_t size);
  ::std::string* mutable_seller();
  ::std::string* release_seller();
  void set_allocated_seller(::std::string* seller);

  // optional bytes receivable = 5;
  bool has_receivable() const;
  void clear_receivable();
  static const int kReceivableFieldNumber = 5;
  const ::std::string& receivable() const;
  void set_receivable(const ::std::string& value);
  #if LANG_CXX11
  void set_receivable(::std::string&& value);
  #endif
  void set_receivable(const char* value);
  void set_receivable(const void* value, size_t size);
  ::std::string* mutable_receivable();
  ::std::string* release_receivable();
  void set_allocated_receivable(::std::string* receivable);

  // optional uint64 amount = 3;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // optional uint64 price = 4;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 4;
  ::google::protobuf::uint64 price() const;
  void set_price(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.NewSell)
 private:
  void set_has_protocol_addr();
  void clear_has_protocol_addr();
  void set_has_seller();
  void clear_has_seller();
  void set_has_amount();
  void clear_has_amount();
  void set_has_price();
  void clear_has_price();
  void set_has_receivable();
  void clear_has_receivable();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr protocol_addr_;
  ::google::protobuf::internal::ArenaStringPtr seller_;
  ::google::protobuf::internal::ArenaStringPtr receivable_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint64 price_;
  friend struct ::protobuf_protos_2fc2c_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BuyerReport : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.c2c.protobuf.BuyerReport) */ {
 public:
  BuyerReport();
  virtual ~BuyerReport();

  BuyerReport(const BuyerReport& from);

  inline BuyerReport& operator=(const BuyerReport& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BuyerReport(BuyerReport&& from) noexcept
    : BuyerReport() {
    *this = ::std::move(from);
  }

  inline BuyerReport& operator=(BuyerReport&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuyerReport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuyerReport* internal_default_instance() {
    return reinterpret_cast<const BuyerReport*>(
               &_BuyerReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(BuyerReport* other);
  friend void swap(BuyerReport& a, BuyerReport& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BuyerReport* New() const final {
    return CreateMaybeMessage<BuyerReport>(NULL);
  }

  BuyerReport* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BuyerReport>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BuyerReport& from);
  void MergeFrom(const BuyerReport& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuyerReport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes buyer = 2;
  bool has_buyer() const;
  void clear_buyer();
  static const int kBuyerFieldNumber = 2;
  const ::std::string& buyer() const;
  void set_buyer(const ::std::string& value);
  #if LANG_CXX11
  void set_buyer(::std::string&& value);
  #endif
  void set_buyer(const char* value);
  void set_buyer(const void* value, size_t size);
  ::std::string* mutable_buyer();
  ::std::string* release_buyer();
  void set_allocated_buyer(::std::string* buyer);

  // optional bytes reports_info = 3;
  bool has_reports_info() const;
  void clear_reports_info();
  static const int kReportsInfoFieldNumber = 3;
  const ::std::string& reports_info() const;
  void set_reports_info(const ::std::string& value);
  #if LANG_CXX11
  void set_reports_info(::std::string&& value);
  #endif
  void set_reports_info(const char* value);
  void set_reports_info(const void* value, size_t size);
  ::std::string* mutable_reports_info();
  ::std::string* release_reports_info();
  void set_allocated_reports_info(::std::string* reports_info);

  // optional uint64 order_id = 1;
  bool has_order_id() const;
  void clear_order_id();
  static const int kOrderIdFieldNumber = 1;
  ::google::protobuf::uint64 order_id() const;
  void set_order_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.BuyerReport)
 private:
  void set_has_order_id();
  void clear_has_order_id();
  void set_has_buyer();
  void clear_has_buyer();
  void set_has_reports_info();
  void clear_has_reports_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr buyer_;
  ::google::protobuf::internal::ArenaStringPtr reports_info_;
  ::google::protobuf::uint64 order_id_;
  friend struct ::protobuf_protos_2fc2c_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class C2cMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zjchain.c2c.protobuf.C2cMessage) */ {
 public:
  C2cMessage();
  virtual ~C2cMessage();

  C2cMessage(const C2cMessage& from);

  inline C2cMessage& operator=(const C2cMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  C2cMessage(C2cMessage&& from) noexcept
    : C2cMessage() {
    *this = ::std::move(from);
  }

  inline C2cMessage& operator=(C2cMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const C2cMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const C2cMessage* internal_default_instance() {
    return reinterpret_cast<const C2cMessage*>(
               &_C2cMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(C2cMessage* other);
  friend void swap(C2cMessage& a, C2cMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline C2cMessage* New() const final {
    return CreateMaybeMessage<C2cMessage>(NULL);
  }

  C2cMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<C2cMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const C2cMessage& from);
  void MergeFrom(const C2cMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C2cMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zjchain.c2c.protobuf.SellInfo sells = 4;
  int sells_size() const;
  void clear_sells();
  static const int kSellsFieldNumber = 4;
  ::zjchain::c2c::protobuf::SellInfo* mutable_sells(int index);
  ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::SellInfo >*
      mutable_sells();
  const ::zjchain::c2c::protobuf::SellInfo& sells(int index) const;
  ::zjchain::c2c::protobuf::SellInfo* add_sells();
  const ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::SellInfo >&
      sells() const;

  // repeated .zjchain.c2c.protobuf.OrderInfo orders = 5;
  int orders_size() const;
  void clear_orders();
  static const int kOrdersFieldNumber = 5;
  ::zjchain::c2c::protobuf::OrderInfo* mutable_orders(int index);
  ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::OrderInfo >*
      mutable_orders();
  const ::zjchain::c2c::protobuf::OrderInfo& orders(int index) const;
  ::zjchain::c2c::protobuf::OrderInfo* add_orders();
  const ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::OrderInfo >&
      orders() const;

  // optional .zjchain.c2c.protobuf.NewSell sell = 1;
  bool has_sell() const;
  void clear_sell();
  static const int kSellFieldNumber = 1;
  private:
  const ::zjchain::c2c::protobuf::NewSell& _internal_sell() const;
  public:
  const ::zjchain::c2c::protobuf::NewSell& sell() const;
  ::zjchain::c2c::protobuf::NewSell* release_sell();
  ::zjchain::c2c::protobuf::NewSell* mutable_sell();
  void set_allocated_sell(::zjchain::c2c::protobuf::NewSell* sell);

  // optional .zjchain.c2c.protobuf.NewOrder order = 2;
  bool has_order() const;
  void clear_order();
  static const int kOrderFieldNumber = 2;
  private:
  const ::zjchain::c2c::protobuf::NewOrder& _internal_order() const;
  public:
  const ::zjchain::c2c::protobuf::NewOrder& order() const;
  ::zjchain::c2c::protobuf::NewOrder* release_order();
  ::zjchain::c2c::protobuf::NewOrder* mutable_order();
  void set_allocated_order(::zjchain::c2c::protobuf::NewOrder* order);

  // optional .zjchain.c2c.protobuf.BuyerReport report = 3;
  bool has_report() const;
  void clear_report();
  static const int kReportFieldNumber = 3;
  private:
  const ::zjchain::c2c::protobuf::BuyerReport& _internal_report() const;
  public:
  const ::zjchain::c2c::protobuf::BuyerReport& report() const;
  ::zjchain::c2c::protobuf::BuyerReport* release_report();
  ::zjchain::c2c::protobuf::BuyerReport* mutable_report();
  void set_allocated_report(::zjchain::c2c::protobuf::BuyerReport* report);

  // @@protoc_insertion_point(class_scope:zjchain.c2c.protobuf.C2cMessage)
 private:
  void set_has_sell();
  void clear_has_sell();
  void set_has_order();
  void clear_has_order();
  void set_has_report();
  void clear_has_report();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::SellInfo > sells_;
  ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::OrderInfo > orders_;
  ::zjchain::c2c::protobuf::NewSell* sell_;
  ::zjchain::c2c::protobuf::NewOrder* order_;
  ::zjchain::c2c::protobuf::BuyerReport* report_;
  friend struct ::protobuf_protos_2fc2c_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SellInfo

// optional uint64 sell_id = 1;
inline bool SellInfo::has_sell_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SellInfo::set_has_sell_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SellInfo::clear_has_sell_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SellInfo::clear_sell_id() {
  sell_id_ = GOOGLE_ULONGLONG(0);
  clear_has_sell_id();
}
inline ::google::protobuf::uint64 SellInfo::sell_id() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.sell_id)
  return sell_id_;
}
inline void SellInfo::set_sell_id(::google::protobuf::uint64 value) {
  set_has_sell_id();
  sell_id_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.sell_id)
}

// optional bytes protocol_addr = 2;
inline bool SellInfo::has_protocol_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SellInfo::set_has_protocol_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SellInfo::clear_has_protocol_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SellInfo::clear_protocol_addr() {
  protocol_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_protocol_addr();
}
inline const ::std::string& SellInfo::protocol_addr() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.protocol_addr)
  return protocol_addr_.GetNoArena();
}
inline void SellInfo::set_protocol_addr(const ::std::string& value) {
  set_has_protocol_addr();
  protocol_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.protocol_addr)
}
#if LANG_CXX11
inline void SellInfo::set_protocol_addr(::std::string&& value) {
  set_has_protocol_addr();
  protocol_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.SellInfo.protocol_addr)
}
#endif
inline void SellInfo::set_protocol_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_protocol_addr();
  protocol_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.SellInfo.protocol_addr)
}
inline void SellInfo::set_protocol_addr(const void* value, size_t size) {
  set_has_protocol_addr();
  protocol_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.SellInfo.protocol_addr)
}
inline ::std::string* SellInfo::mutable_protocol_addr() {
  set_has_protocol_addr();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.SellInfo.protocol_addr)
  return protocol_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SellInfo::release_protocol_addr() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.SellInfo.protocol_addr)
  if (!has_protocol_addr()) {
    return NULL;
  }
  clear_has_protocol_addr();
  return protocol_addr_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SellInfo::set_allocated_protocol_addr(::std::string* protocol_addr) {
  if (protocol_addr != NULL) {
    set_has_protocol_addr();
  } else {
    clear_has_protocol_addr();
  }
  protocol_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol_addr);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.SellInfo.protocol_addr)
}

// optional bytes seller = 3;
inline bool SellInfo::has_seller() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SellInfo::set_has_seller() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SellInfo::clear_has_seller() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SellInfo::clear_seller() {
  seller_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_seller();
}
inline const ::std::string& SellInfo::seller() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.seller)
  return seller_.GetNoArena();
}
inline void SellInfo::set_seller(const ::std::string& value) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.seller)
}
#if LANG_CXX11
inline void SellInfo::set_seller(::std::string&& value) {
  set_has_seller();
  seller_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.SellInfo.seller)
}
#endif
inline void SellInfo::set_seller(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.SellInfo.seller)
}
inline void SellInfo::set_seller(const void* value, size_t size) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.SellInfo.seller)
}
inline ::std::string* SellInfo::mutable_seller() {
  set_has_seller();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.SellInfo.seller)
  return seller_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SellInfo::release_seller() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.SellInfo.seller)
  if (!has_seller()) {
    return NULL;
  }
  clear_has_seller();
  return seller_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SellInfo::set_allocated_seller(::std::string* seller) {
  if (seller != NULL) {
    set_has_seller();
  } else {
    clear_has_seller();
  }
  seller_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), seller);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.SellInfo.seller)
}

// optional uint64 pledge_amount = 4;
inline bool SellInfo::has_pledge_amount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SellInfo::set_has_pledge_amount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SellInfo::clear_has_pledge_amount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SellInfo::clear_pledge_amount() {
  pledge_amount_ = GOOGLE_ULONGLONG(0);
  clear_has_pledge_amount();
}
inline ::google::protobuf::uint64 SellInfo::pledge_amount() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.pledge_amount)
  return pledge_amount_;
}
inline void SellInfo::set_pledge_amount(::google::protobuf::uint64 value) {
  set_has_pledge_amount();
  pledge_amount_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.pledge_amount)
}

// optional uint64 price = 5;
inline bool SellInfo::has_price() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SellInfo::set_has_price() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SellInfo::clear_has_price() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SellInfo::clear_price() {
  price_ = GOOGLE_ULONGLONG(0);
  clear_has_price();
}
inline ::google::protobuf::uint64 SellInfo::price() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.price)
  return price_;
}
inline void SellInfo::set_price(::google::protobuf::uint64 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.price)
}

// optional bytes receivable = 6;
inline bool SellInfo::has_receivable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SellInfo::set_has_receivable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SellInfo::clear_has_receivable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SellInfo::clear_receivable() {
  receivable_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_receivable();
}
inline const ::std::string& SellInfo::receivable() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.receivable)
  return receivable_.GetNoArena();
}
inline void SellInfo::set_receivable(const ::std::string& value) {
  set_has_receivable();
  receivable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.receivable)
}
#if LANG_CXX11
inline void SellInfo::set_receivable(::std::string&& value) {
  set_has_receivable();
  receivable_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.SellInfo.receivable)
}
#endif
inline void SellInfo::set_receivable(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_receivable();
  receivable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.SellInfo.receivable)
}
inline void SellInfo::set_receivable(const void* value, size_t size) {
  set_has_receivable();
  receivable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.SellInfo.receivable)
}
inline ::std::string* SellInfo::mutable_receivable() {
  set_has_receivable();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.SellInfo.receivable)
  return receivable_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SellInfo::release_receivable() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.SellInfo.receivable)
  if (!has_receivable()) {
    return NULL;
  }
  clear_has_receivable();
  return receivable_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SellInfo::set_allocated_receivable(::std::string* receivable) {
  if (receivable != NULL) {
    set_has_receivable();
  } else {
    clear_has_receivable();
  }
  receivable_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), receivable);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.SellInfo.receivable)
}

// optional bool manager_released = 7;
inline bool SellInfo::has_manager_released() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SellInfo::set_has_manager_released() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SellInfo::clear_has_manager_released() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SellInfo::clear_manager_released() {
  manager_released_ = false;
  clear_has_manager_released();
}
inline bool SellInfo::manager_released() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.manager_released)
  return manager_released_;
}
inline void SellInfo::set_manager_released(bool value) {
  set_has_manager_released();
  manager_released_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.manager_released)
}

// optional bool seller_released = 8;
inline bool SellInfo::has_seller_released() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SellInfo::set_has_seller_released() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SellInfo::clear_has_seller_released() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SellInfo::clear_seller_released() {
  seller_released_ = false;
  clear_has_seller_released();
}
inline bool SellInfo::seller_released() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.SellInfo.seller_released)
  return seller_released_;
}
inline void SellInfo::set_seller_released(bool value) {
  set_has_seller_released();
  seller_released_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.SellInfo.seller_released)
}

// -------------------------------------------------------------------

// OrderInfo

// optional .zjchain.c2c.protobuf.SellInfo sell = 1;
inline bool OrderInfo::has_sell() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderInfo::set_has_sell() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderInfo::clear_has_sell() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderInfo::clear_sell() {
  if (sell_ != NULL) sell_->Clear();
  clear_has_sell();
}
inline const ::zjchain::c2c::protobuf::SellInfo& OrderInfo::_internal_sell() const {
  return *sell_;
}
inline const ::zjchain::c2c::protobuf::SellInfo& OrderInfo::sell() const {
  const ::zjchain::c2c::protobuf::SellInfo* p = sell_;
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.OrderInfo.sell)
  return p != NULL ? *p : *reinterpret_cast<const ::zjchain::c2c::protobuf::SellInfo*>(
      &::zjchain::c2c::protobuf::_SellInfo_default_instance_);
}
inline ::zjchain::c2c::protobuf::SellInfo* OrderInfo::release_sell() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.OrderInfo.sell)
  clear_has_sell();
  ::zjchain::c2c::protobuf::SellInfo* temp = sell_;
  sell_ = NULL;
  return temp;
}
inline ::zjchain::c2c::protobuf::SellInfo* OrderInfo::mutable_sell() {
  set_has_sell();
  if (sell_ == NULL) {
    auto* p = CreateMaybeMessage<::zjchain::c2c::protobuf::SellInfo>(GetArenaNoVirtual());
    sell_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.OrderInfo.sell)
  return sell_;
}
inline void OrderInfo::set_allocated_sell(::zjchain::c2c::protobuf::SellInfo* sell) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sell_;
  }
  if (sell) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sell = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sell, submessage_arena);
    }
    set_has_sell();
  } else {
    clear_has_sell();
  }
  sell_ = sell;
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.OrderInfo.sell)
}

// optional bytes buyer = 2;
inline bool OrderInfo::has_buyer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderInfo::set_has_buyer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderInfo::clear_has_buyer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderInfo::clear_buyer() {
  buyer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_buyer();
}
inline const ::std::string& OrderInfo::buyer() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.OrderInfo.buyer)
  return buyer_.GetNoArena();
}
inline void OrderInfo::set_buyer(const ::std::string& value) {
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.OrderInfo.buyer)
}
#if LANG_CXX11
inline void OrderInfo::set_buyer(::std::string&& value) {
  set_has_buyer();
  buyer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.OrderInfo.buyer)
}
#endif
inline void OrderInfo::set_buyer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.OrderInfo.buyer)
}
inline void OrderInfo::set_buyer(const void* value, size_t size) {
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.OrderInfo.buyer)
}
inline ::std::string* OrderInfo::mutable_buyer() {
  set_has_buyer();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.OrderInfo.buyer)
  return buyer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OrderInfo::release_buyer() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.OrderInfo.buyer)
  if (!has_buyer()) {
    return NULL;
  }
  clear_has_buyer();
  return buyer_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OrderInfo::set_allocated_buyer(::std::string* buyer) {
  if (buyer != NULL) {
    set_has_buyer();
  } else {
    clear_has_buyer();
  }
  buyer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), buyer);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.OrderInfo.buyer)
}

// optional uint64 order_id = 3;
inline bool OrderInfo::has_order_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderInfo::set_has_order_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderInfo::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderInfo::clear_order_id() {
  order_id_ = GOOGLE_ULONGLONG(0);
  clear_has_order_id();
}
inline ::google::protobuf::uint64 OrderInfo::order_id() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.OrderInfo.order_id)
  return order_id_;
}
inline void OrderInfo::set_order_id(::google::protobuf::uint64 value) {
  set_has_order_id();
  order_id_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.OrderInfo.order_id)
}

// optional .zjchain.c2c.protobuf.OrderStatus status = 4;
inline bool OrderInfo::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderInfo::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderInfo::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::zjchain::c2c::protobuf::OrderStatus OrderInfo::status() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.OrderInfo.status)
  return static_cast< ::zjchain::c2c::protobuf::OrderStatus >(status_);
}
inline void OrderInfo::set_status(::zjchain::c2c::protobuf::OrderStatus value) {
  assert(::zjchain::c2c::protobuf::OrderStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.OrderInfo.status)
}

// optional uint64 amount = 5;
inline bool OrderInfo::has_amount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderInfo::set_has_amount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderInfo::clear_has_amount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderInfo::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 OrderInfo::amount() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.OrderInfo.amount)
  return amount_;
}
inline void OrderInfo::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.OrderInfo.amount)
}

// optional bytes reports_info = 6;
inline bool OrderInfo::has_reports_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderInfo::set_has_reports_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderInfo::clear_has_reports_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderInfo::clear_reports_info() {
  reports_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reports_info();
}
inline const ::std::string& OrderInfo::reports_info() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.OrderInfo.reports_info)
  return reports_info_.GetNoArena();
}
inline void OrderInfo::set_reports_info(const ::std::string& value) {
  set_has_reports_info();
  reports_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.OrderInfo.reports_info)
}
#if LANG_CXX11
inline void OrderInfo::set_reports_info(::std::string&& value) {
  set_has_reports_info();
  reports_info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.OrderInfo.reports_info)
}
#endif
inline void OrderInfo::set_reports_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reports_info();
  reports_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.OrderInfo.reports_info)
}
inline void OrderInfo::set_reports_info(const void* value, size_t size) {
  set_has_reports_info();
  reports_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.OrderInfo.reports_info)
}
inline ::std::string* OrderInfo::mutable_reports_info() {
  set_has_reports_info();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.OrderInfo.reports_info)
  return reports_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OrderInfo::release_reports_info() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.OrderInfo.reports_info)
  if (!has_reports_info()) {
    return NULL;
  }
  clear_has_reports_info();
  return reports_info_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OrderInfo::set_allocated_reports_info(::std::string* reports_info) {
  if (reports_info != NULL) {
    set_has_reports_info();
  } else {
    clear_has_reports_info();
  }
  reports_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reports_info);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.OrderInfo.reports_info)
}

// -------------------------------------------------------------------

// NewOrder

// optional uint64 sell_id = 1;
inline bool NewOrder::has_sell_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewOrder::set_has_sell_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewOrder::clear_has_sell_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewOrder::clear_sell_id() {
  sell_id_ = GOOGLE_ULONGLONG(0);
  clear_has_sell_id();
}
inline ::google::protobuf::uint64 NewOrder::sell_id() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewOrder.sell_id)
  return sell_id_;
}
inline void NewOrder::set_sell_id(::google::protobuf::uint64 value) {
  set_has_sell_id();
  sell_id_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewOrder.sell_id)
}

// optional uint64 amount = 2;
inline bool NewOrder::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewOrder::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewOrder::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewOrder::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 NewOrder::amount() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewOrder.amount)
  return amount_;
}
inline void NewOrder::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewOrder.amount)
}

// optional bytes buyer = 3;
inline bool NewOrder::has_buyer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewOrder::set_has_buyer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewOrder::clear_has_buyer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewOrder::clear_buyer() {
  buyer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_buyer();
}
inline const ::std::string& NewOrder::buyer() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewOrder.buyer)
  return buyer_.GetNoArena();
}
inline void NewOrder::set_buyer(const ::std::string& value) {
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewOrder.buyer)
}
#if LANG_CXX11
inline void NewOrder::set_buyer(::std::string&& value) {
  set_has_buyer();
  buyer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.NewOrder.buyer)
}
#endif
inline void NewOrder::set_buyer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.NewOrder.buyer)
}
inline void NewOrder::set_buyer(const void* value, size_t size) {
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.NewOrder.buyer)
}
inline ::std::string* NewOrder::mutable_buyer() {
  set_has_buyer();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.NewOrder.buyer)
  return buyer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewOrder::release_buyer() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.NewOrder.buyer)
  if (!has_buyer()) {
    return NULL;
  }
  clear_has_buyer();
  return buyer_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewOrder::set_allocated_buyer(::std::string* buyer) {
  if (buyer != NULL) {
    set_has_buyer();
  } else {
    clear_has_buyer();
  }
  buyer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), buyer);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.NewOrder.buyer)
}

// -------------------------------------------------------------------

// NewSell

// optional bytes protocol_addr = 1;
inline bool NewSell::has_protocol_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewSell::set_has_protocol_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewSell::clear_has_protocol_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewSell::clear_protocol_addr() {
  protocol_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_protocol_addr();
}
inline const ::std::string& NewSell::protocol_addr() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewSell.protocol_addr)
  return protocol_addr_.GetNoArena();
}
inline void NewSell::set_protocol_addr(const ::std::string& value) {
  set_has_protocol_addr();
  protocol_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewSell.protocol_addr)
}
#if LANG_CXX11
inline void NewSell::set_protocol_addr(::std::string&& value) {
  set_has_protocol_addr();
  protocol_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.NewSell.protocol_addr)
}
#endif
inline void NewSell::set_protocol_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_protocol_addr();
  protocol_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.NewSell.protocol_addr)
}
inline void NewSell::set_protocol_addr(const void* value, size_t size) {
  set_has_protocol_addr();
  protocol_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.NewSell.protocol_addr)
}
inline ::std::string* NewSell::mutable_protocol_addr() {
  set_has_protocol_addr();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.NewSell.protocol_addr)
  return protocol_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewSell::release_protocol_addr() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.NewSell.protocol_addr)
  if (!has_protocol_addr()) {
    return NULL;
  }
  clear_has_protocol_addr();
  return protocol_addr_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewSell::set_allocated_protocol_addr(::std::string* protocol_addr) {
  if (protocol_addr != NULL) {
    set_has_protocol_addr();
  } else {
    clear_has_protocol_addr();
  }
  protocol_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol_addr);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.NewSell.protocol_addr)
}

// optional bytes seller = 2;
inline bool NewSell::has_seller() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewSell::set_has_seller() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewSell::clear_has_seller() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewSell::clear_seller() {
  seller_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_seller();
}
inline const ::std::string& NewSell::seller() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewSell.seller)
  return seller_.GetNoArena();
}
inline void NewSell::set_seller(const ::std::string& value) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewSell.seller)
}
#if LANG_CXX11
inline void NewSell::set_seller(::std::string&& value) {
  set_has_seller();
  seller_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.NewSell.seller)
}
#endif
inline void NewSell::set_seller(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.NewSell.seller)
}
inline void NewSell::set_seller(const void* value, size_t size) {
  set_has_seller();
  seller_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.NewSell.seller)
}
inline ::std::string* NewSell::mutable_seller() {
  set_has_seller();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.NewSell.seller)
  return seller_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewSell::release_seller() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.NewSell.seller)
  if (!has_seller()) {
    return NULL;
  }
  clear_has_seller();
  return seller_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewSell::set_allocated_seller(::std::string* seller) {
  if (seller != NULL) {
    set_has_seller();
  } else {
    clear_has_seller();
  }
  seller_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), seller);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.NewSell.seller)
}

// optional uint64 amount = 3;
inline bool NewSell::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewSell::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewSell::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewSell::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 NewSell::amount() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewSell.amount)
  return amount_;
}
inline void NewSell::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewSell.amount)
}

// optional uint64 price = 4;
inline bool NewSell::has_price() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NewSell::set_has_price() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NewSell::clear_has_price() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NewSell::clear_price() {
  price_ = GOOGLE_ULONGLONG(0);
  clear_has_price();
}
inline ::google::protobuf::uint64 NewSell::price() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewSell.price)
  return price_;
}
inline void NewSell::set_price(::google::protobuf::uint64 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewSell.price)
}

// optional bytes receivable = 5;
inline bool NewSell::has_receivable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewSell::set_has_receivable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewSell::clear_has_receivable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewSell::clear_receivable() {
  receivable_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_receivable();
}
inline const ::std::string& NewSell::receivable() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.NewSell.receivable)
  return receivable_.GetNoArena();
}
inline void NewSell::set_receivable(const ::std::string& value) {
  set_has_receivable();
  receivable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.NewSell.receivable)
}
#if LANG_CXX11
inline void NewSell::set_receivable(::std::string&& value) {
  set_has_receivable();
  receivable_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.NewSell.receivable)
}
#endif
inline void NewSell::set_receivable(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_receivable();
  receivable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.NewSell.receivable)
}
inline void NewSell::set_receivable(const void* value, size_t size) {
  set_has_receivable();
  receivable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.NewSell.receivable)
}
inline ::std::string* NewSell::mutable_receivable() {
  set_has_receivable();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.NewSell.receivable)
  return receivable_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewSell::release_receivable() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.NewSell.receivable)
  if (!has_receivable()) {
    return NULL;
  }
  clear_has_receivable();
  return receivable_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewSell::set_allocated_receivable(::std::string* receivable) {
  if (receivable != NULL) {
    set_has_receivable();
  } else {
    clear_has_receivable();
  }
  receivable_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), receivable);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.NewSell.receivable)
}

// -------------------------------------------------------------------

// BuyerReport

// optional uint64 order_id = 1;
inline bool BuyerReport::has_order_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuyerReport::set_has_order_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuyerReport::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuyerReport::clear_order_id() {
  order_id_ = GOOGLE_ULONGLONG(0);
  clear_has_order_id();
}
inline ::google::protobuf::uint64 BuyerReport::order_id() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.BuyerReport.order_id)
  return order_id_;
}
inline void BuyerReport::set_order_id(::google::protobuf::uint64 value) {
  set_has_order_id();
  order_id_ = value;
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.BuyerReport.order_id)
}

// optional bytes buyer = 2;
inline bool BuyerReport::has_buyer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuyerReport::set_has_buyer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuyerReport::clear_has_buyer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuyerReport::clear_buyer() {
  buyer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_buyer();
}
inline const ::std::string& BuyerReport::buyer() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.BuyerReport.buyer)
  return buyer_.GetNoArena();
}
inline void BuyerReport::set_buyer(const ::std::string& value) {
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.BuyerReport.buyer)
}
#if LANG_CXX11
inline void BuyerReport::set_buyer(::std::string&& value) {
  set_has_buyer();
  buyer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.BuyerReport.buyer)
}
#endif
inline void BuyerReport::set_buyer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.BuyerReport.buyer)
}
inline void BuyerReport::set_buyer(const void* value, size_t size) {
  set_has_buyer();
  buyer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.BuyerReport.buyer)
}
inline ::std::string* BuyerReport::mutable_buyer() {
  set_has_buyer();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.BuyerReport.buyer)
  return buyer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuyerReport::release_buyer() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.BuyerReport.buyer)
  if (!has_buyer()) {
    return NULL;
  }
  clear_has_buyer();
  return buyer_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuyerReport::set_allocated_buyer(::std::string* buyer) {
  if (buyer != NULL) {
    set_has_buyer();
  } else {
    clear_has_buyer();
  }
  buyer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), buyer);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.BuyerReport.buyer)
}

// optional bytes reports_info = 3;
inline bool BuyerReport::has_reports_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuyerReport::set_has_reports_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuyerReport::clear_has_reports_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuyerReport::clear_reports_info() {
  reports_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reports_info();
}
inline const ::std::string& BuyerReport::reports_info() const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.BuyerReport.reports_info)
  return reports_info_.GetNoArena();
}
inline void BuyerReport::set_reports_info(const ::std::string& value) {
  set_has_reports_info();
  reports_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zjchain.c2c.protobuf.BuyerReport.reports_info)
}
#if LANG_CXX11
inline void BuyerReport::set_reports_info(::std::string&& value) {
  set_has_reports_info();
  reports_info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zjchain.c2c.protobuf.BuyerReport.reports_info)
}
#endif
inline void BuyerReport::set_reports_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reports_info();
  reports_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zjchain.c2c.protobuf.BuyerReport.reports_info)
}
inline void BuyerReport::set_reports_info(const void* value, size_t size) {
  set_has_reports_info();
  reports_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zjchain.c2c.protobuf.BuyerReport.reports_info)
}
inline ::std::string* BuyerReport::mutable_reports_info() {
  set_has_reports_info();
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.BuyerReport.reports_info)
  return reports_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BuyerReport::release_reports_info() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.BuyerReport.reports_info)
  if (!has_reports_info()) {
    return NULL;
  }
  clear_has_reports_info();
  return reports_info_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BuyerReport::set_allocated_reports_info(::std::string* reports_info) {
  if (reports_info != NULL) {
    set_has_reports_info();
  } else {
    clear_has_reports_info();
  }
  reports_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reports_info);
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.BuyerReport.reports_info)
}

// -------------------------------------------------------------------

// C2cMessage

// optional .zjchain.c2c.protobuf.NewSell sell = 1;
inline bool C2cMessage::has_sell() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2cMessage::set_has_sell() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2cMessage::clear_has_sell() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2cMessage::clear_sell() {
  if (sell_ != NULL) sell_->Clear();
  clear_has_sell();
}
inline const ::zjchain::c2c::protobuf::NewSell& C2cMessage::_internal_sell() const {
  return *sell_;
}
inline const ::zjchain::c2c::protobuf::NewSell& C2cMessage::sell() const {
  const ::zjchain::c2c::protobuf::NewSell* p = sell_;
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.C2cMessage.sell)
  return p != NULL ? *p : *reinterpret_cast<const ::zjchain::c2c::protobuf::NewSell*>(
      &::zjchain::c2c::protobuf::_NewSell_default_instance_);
}
inline ::zjchain::c2c::protobuf::NewSell* C2cMessage::release_sell() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.C2cMessage.sell)
  clear_has_sell();
  ::zjchain::c2c::protobuf::NewSell* temp = sell_;
  sell_ = NULL;
  return temp;
}
inline ::zjchain::c2c::protobuf::NewSell* C2cMessage::mutable_sell() {
  set_has_sell();
  if (sell_ == NULL) {
    auto* p = CreateMaybeMessage<::zjchain::c2c::protobuf::NewSell>(GetArenaNoVirtual());
    sell_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.C2cMessage.sell)
  return sell_;
}
inline void C2cMessage::set_allocated_sell(::zjchain::c2c::protobuf::NewSell* sell) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sell_;
  }
  if (sell) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sell = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sell, submessage_arena);
    }
    set_has_sell();
  } else {
    clear_has_sell();
  }
  sell_ = sell;
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.C2cMessage.sell)
}

// optional .zjchain.c2c.protobuf.NewOrder order = 2;
inline bool C2cMessage::has_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2cMessage::set_has_order() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2cMessage::clear_has_order() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2cMessage::clear_order() {
  if (order_ != NULL) order_->Clear();
  clear_has_order();
}
inline const ::zjchain::c2c::protobuf::NewOrder& C2cMessage::_internal_order() const {
  return *order_;
}
inline const ::zjchain::c2c::protobuf::NewOrder& C2cMessage::order() const {
  const ::zjchain::c2c::protobuf::NewOrder* p = order_;
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.C2cMessage.order)
  return p != NULL ? *p : *reinterpret_cast<const ::zjchain::c2c::protobuf::NewOrder*>(
      &::zjchain::c2c::protobuf::_NewOrder_default_instance_);
}
inline ::zjchain::c2c::protobuf::NewOrder* C2cMessage::release_order() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.C2cMessage.order)
  clear_has_order();
  ::zjchain::c2c::protobuf::NewOrder* temp = order_;
  order_ = NULL;
  return temp;
}
inline ::zjchain::c2c::protobuf::NewOrder* C2cMessage::mutable_order() {
  set_has_order();
  if (order_ == NULL) {
    auto* p = CreateMaybeMessage<::zjchain::c2c::protobuf::NewOrder>(GetArenaNoVirtual());
    order_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.C2cMessage.order)
  return order_;
}
inline void C2cMessage::set_allocated_order(::zjchain::c2c::protobuf::NewOrder* order) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete order_;
  }
  if (order) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      order = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    set_has_order();
  } else {
    clear_has_order();
  }
  order_ = order;
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.C2cMessage.order)
}

// optional .zjchain.c2c.protobuf.BuyerReport report = 3;
inline bool C2cMessage::has_report() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void C2cMessage::set_has_report() {
  _has_bits_[0] |= 0x00000004u;
}
inline void C2cMessage::clear_has_report() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void C2cMessage::clear_report() {
  if (report_ != NULL) report_->Clear();
  clear_has_report();
}
inline const ::zjchain::c2c::protobuf::BuyerReport& C2cMessage::_internal_report() const {
  return *report_;
}
inline const ::zjchain::c2c::protobuf::BuyerReport& C2cMessage::report() const {
  const ::zjchain::c2c::protobuf::BuyerReport* p = report_;
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.C2cMessage.report)
  return p != NULL ? *p : *reinterpret_cast<const ::zjchain::c2c::protobuf::BuyerReport*>(
      &::zjchain::c2c::protobuf::_BuyerReport_default_instance_);
}
inline ::zjchain::c2c::protobuf::BuyerReport* C2cMessage::release_report() {
  // @@protoc_insertion_point(field_release:zjchain.c2c.protobuf.C2cMessage.report)
  clear_has_report();
  ::zjchain::c2c::protobuf::BuyerReport* temp = report_;
  report_ = NULL;
  return temp;
}
inline ::zjchain::c2c::protobuf::BuyerReport* C2cMessage::mutable_report() {
  set_has_report();
  if (report_ == NULL) {
    auto* p = CreateMaybeMessage<::zjchain::c2c::protobuf::BuyerReport>(GetArenaNoVirtual());
    report_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.C2cMessage.report)
  return report_;
}
inline void C2cMessage::set_allocated_report(::zjchain::c2c::protobuf::BuyerReport* report) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete report_;
  }
  if (report) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      report = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, report, submessage_arena);
    }
    set_has_report();
  } else {
    clear_has_report();
  }
  report_ = report;
  // @@protoc_insertion_point(field_set_allocated:zjchain.c2c.protobuf.C2cMessage.report)
}

// repeated .zjchain.c2c.protobuf.SellInfo sells = 4;
inline int C2cMessage::sells_size() const {
  return sells_.size();
}
inline void C2cMessage::clear_sells() {
  sells_.Clear();
}
inline ::zjchain::c2c::protobuf::SellInfo* C2cMessage::mutable_sells(int index) {
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.C2cMessage.sells)
  return sells_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::SellInfo >*
C2cMessage::mutable_sells() {
  // @@protoc_insertion_point(field_mutable_list:zjchain.c2c.protobuf.C2cMessage.sells)
  return &sells_;
}
inline const ::zjchain::c2c::protobuf::SellInfo& C2cMessage::sells(int index) const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.C2cMessage.sells)
  return sells_.Get(index);
}
inline ::zjchain::c2c::protobuf::SellInfo* C2cMessage::add_sells() {
  // @@protoc_insertion_point(field_add:zjchain.c2c.protobuf.C2cMessage.sells)
  return sells_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::SellInfo >&
C2cMessage::sells() const {
  // @@protoc_insertion_point(field_list:zjchain.c2c.protobuf.C2cMessage.sells)
  return sells_;
}

// repeated .zjchain.c2c.protobuf.OrderInfo orders = 5;
inline int C2cMessage::orders_size() const {
  return orders_.size();
}
inline void C2cMessage::clear_orders() {
  orders_.Clear();
}
inline ::zjchain::c2c::protobuf::OrderInfo* C2cMessage::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:zjchain.c2c.protobuf.C2cMessage.orders)
  return orders_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::OrderInfo >*
C2cMessage::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:zjchain.c2c.protobuf.C2cMessage.orders)
  return &orders_;
}
inline const ::zjchain::c2c::protobuf::OrderInfo& C2cMessage::orders(int index) const {
  // @@protoc_insertion_point(field_get:zjchain.c2c.protobuf.C2cMessage.orders)
  return orders_.Get(index);
}
inline ::zjchain::c2c::protobuf::OrderInfo* C2cMessage::add_orders() {
  // @@protoc_insertion_point(field_add:zjchain.c2c.protobuf.C2cMessage.orders)
  return orders_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zjchain::c2c::protobuf::OrderInfo >&
C2cMessage::orders() const {
  // @@protoc_insertion_point(field_list:zjchain.c2c.protobuf.C2cMessage.orders)
  return orders_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace c2c
}  // namespace zjchain

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::zjchain::c2c::protobuf::OrderStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zjchain::c2c::protobuf::OrderStatus>() {
  return ::zjchain::c2c::protobuf::OrderStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_protos_2fc2c_2eproto
