// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/dht.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "protos/dht.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace zjchain {
namespace dht {
namespace protobuf {

namespace {

const ::google::protobuf::Descriptor* BootstrapRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BootstrapRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* BootstrapResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BootstrapResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* NodeInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NodeInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* RefreshNeighborsRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RefreshNeighborsRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* RefreshNeighborsResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RefreshNeighborsResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* HeartbeatRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HeartbeatRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* HeartbeatResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HeartbeatResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* ConnectReqeust_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ConnectReqeust_reflection_ = NULL;
const ::google::protobuf::Descriptor* TimerRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TimerRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* DhtMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DhtMessage_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_protos_2fdht_2eproto() {
  protobuf_AddDesc_protos_2fdht_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "protos/dht.proto");
  GOOGLE_CHECK(file != NULL);
  BootstrapRequest_descriptor_ = file->message_type(0);
  static const int BootstrapRequest_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BootstrapRequest, pubkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BootstrapRequest, public_ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BootstrapRequest, public_port_),
  };
  BootstrapRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BootstrapRequest_descriptor_,
      BootstrapRequest::default_instance_,
      BootstrapRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BootstrapRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BootstrapRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BootstrapRequest));
  BootstrapResponse_descriptor_ = file->message_type(1);
  static const int BootstrapResponse_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BootstrapResponse, pubkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BootstrapResponse, public_ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BootstrapResponse, public_port_),
  };
  BootstrapResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BootstrapResponse_descriptor_,
      BootstrapResponse::default_instance_,
      BootstrapResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BootstrapResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BootstrapResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BootstrapResponse));
  NodeInfo_descriptor_ = file->message_type(2);
  static const int NodeInfo_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NodeInfo, public_ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NodeInfo, public_port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NodeInfo, pubkey_),
  };
  NodeInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NodeInfo_descriptor_,
      NodeInfo::default_instance_,
      NodeInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NodeInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NodeInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NodeInfo));
  RefreshNeighborsRequest_descriptor_ = file->message_type(3);
  static const int RefreshNeighborsRequest_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RefreshNeighborsRequest, count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RefreshNeighborsRequest, bloomfilter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RefreshNeighborsRequest, pubkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RefreshNeighborsRequest, public_ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RefreshNeighborsRequest, public_port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RefreshNeighborsRequest, ids_),
  };
  RefreshNeighborsRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RefreshNeighborsRequest_descriptor_,
      RefreshNeighborsRequest::default_instance_,
      RefreshNeighborsRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RefreshNeighborsRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RefreshNeighborsRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RefreshNeighborsRequest));
  RefreshNeighborsResponse_descriptor_ = file->message_type(4);
  static const int RefreshNeighborsResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RefreshNeighborsResponse, nodes_),
  };
  RefreshNeighborsResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RefreshNeighborsResponse_descriptor_,
      RefreshNeighborsResponse::default_instance_,
      RefreshNeighborsResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RefreshNeighborsResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RefreshNeighborsResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RefreshNeighborsResponse));
  HeartbeatRequest_descriptor_ = file->message_type(5);
  static const int HeartbeatRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatRequest, dht_key_hash_),
  };
  HeartbeatRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HeartbeatRequest_descriptor_,
      HeartbeatRequest::default_instance_,
      HeartbeatRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HeartbeatRequest));
  HeartbeatResponse_descriptor_ = file->message_type(6);
  static const int HeartbeatResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatResponse, dht_key_hash_),
  };
  HeartbeatResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HeartbeatResponse_descriptor_,
      HeartbeatResponse::default_instance_,
      HeartbeatResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HeartbeatResponse));
  ConnectReqeust_descriptor_ = file->message_type(7);
  static const int ConnectReqeust_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectReqeust, pubkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectReqeust, is_response_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectReqeust, public_ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectReqeust, public_port_),
  };
  ConnectReqeust_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ConnectReqeust_descriptor_,
      ConnectReqeust::default_instance_,
      ConnectReqeust_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectReqeust, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectReqeust, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ConnectReqeust));
  TimerRequest_descriptor_ = file->message_type(8);
  static const int TimerRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimerRequest, tm_milli_),
  };
  TimerRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TimerRequest_descriptor_,
      TimerRequest::default_instance_,
      TimerRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimerRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimerRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TimerRequest));
  DhtMessage_descriptor_ = file->message_type(9);
  static const int DhtMessage_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DhtMessage, bootstrap_req_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DhtMessage, bootstrap_res_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DhtMessage, refresh_neighbors_req_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DhtMessage, refresh_neighbors_res_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DhtMessage, connect_req_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DhtMessage, heartbeat_req_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DhtMessage, heartbeat_res_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DhtMessage, timer_),
  };
  DhtMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DhtMessage_descriptor_,
      DhtMessage::default_instance_,
      DhtMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DhtMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DhtMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DhtMessage));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_protos_2fdht_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BootstrapRequest_descriptor_, &BootstrapRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BootstrapResponse_descriptor_, &BootstrapResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NodeInfo_descriptor_, &NodeInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RefreshNeighborsRequest_descriptor_, &RefreshNeighborsRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RefreshNeighborsResponse_descriptor_, &RefreshNeighborsResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HeartbeatRequest_descriptor_, &HeartbeatRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HeartbeatResponse_descriptor_, &HeartbeatResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ConnectReqeust_descriptor_, &ConnectReqeust::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TimerRequest_descriptor_, &TimerRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DhtMessage_descriptor_, &DhtMessage::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_protos_2fdht_2eproto() {
  delete BootstrapRequest::default_instance_;
  delete BootstrapRequest_reflection_;
  delete BootstrapResponse::default_instance_;
  delete BootstrapResponse_reflection_;
  delete NodeInfo::default_instance_;
  delete NodeInfo_reflection_;
  delete RefreshNeighborsRequest::default_instance_;
  delete RefreshNeighborsRequest_reflection_;
  delete RefreshNeighborsResponse::default_instance_;
  delete RefreshNeighborsResponse_reflection_;
  delete HeartbeatRequest::default_instance_;
  delete HeartbeatRequest_reflection_;
  delete HeartbeatResponse::default_instance_;
  delete HeartbeatResponse_reflection_;
  delete ConnectReqeust::default_instance_;
  delete ConnectReqeust_reflection_;
  delete TimerRequest::default_instance_;
  delete TimerRequest_reflection_;
  delete DhtMessage::default_instance_;
  delete DhtMessage_reflection_;
}

void protobuf_AddDesc_protos_2fdht_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\020protos/dht.proto\022\024zjchain.dht.protobuf"
    "\"J\n\020BootstrapRequest\022\016\n\006pubkey\030\001 \001(\014\022\021\n\t"
    "public_ip\030\002 \001(\t\022\023\n\013public_port\030\003 \001(\005\"K\n\021"
    "BootstrapResponse\022\016\n\006pubkey\030\001 \001(\014\022\021\n\tpub"
    "lic_ip\030\002 \001(\t\022\023\n\013public_port\030\003 \001(\005\"B\n\010Nod"
    "eInfo\022\021\n\tpublic_ip\030\001 \001(\014\022\023\n\013public_port\030"
    "\002 \001(\005\022\016\n\006pubkey\030\003 \001(\014\"\202\001\n\027RefreshNeighbo"
    "rsRequest\022\r\n\005count\030\001 \001(\r\022\023\n\013bloomfilter\030"
    "\002 \003(\004\022\016\n\006pubkey\030\003 \001(\014\022\021\n\tpublic_ip\030\004 \001(\t"
    "\022\023\n\013public_port\030\005 \001(\005\022\013\n\003ids\030\006 \003(\014\"I\n\030Re"
    "freshNeighborsResponse\022-\n\005nodes\030\001 \003(\0132\036."
    "zjchain.dht.protobuf.NodeInfo\"(\n\020Heartbe"
    "atRequest\022\024\n\014dht_key_hash\030\001 \001(\004\")\n\021Heart"
    "beatResponse\022\024\n\014dht_key_hash\030\001 \001(\004\"]\n\016Co"
    "nnectReqeust\022\016\n\006pubkey\030\001 \001(\014\022\023\n\013is_respo"
    "nse\030\002 \001(\010\022\021\n\tpublic_ip\030\003 \001(\t\022\023\n\013public_p"
    "ort\030\004 \001(\005\" \n\014TimerRequest\022\020\n\010tm_milli\030\001 "
    "\001(\004\"\225\004\n\nDhtMessage\022=\n\rbootstrap_req\030\001 \001("
    "\0132&.zjchain.dht.protobuf.BootstrapReques"
    "t\022>\n\rbootstrap_res\030\002 \001(\0132\'.zjchain.dht.p"
    "rotobuf.BootstrapResponse\022L\n\025refresh_nei"
    "ghbors_req\030\003 \001(\0132-.zjchain.dht.protobuf."
    "RefreshNeighborsRequest\022M\n\025refresh_neigh"
    "bors_res\030\004 \001(\0132..zjchain.dht.protobuf.Re"
    "freshNeighborsResponse\0229\n\013connect_req\030\005 "
    "\001(\0132$.zjchain.dht.protobuf.ConnectReqeus"
    "t\022=\n\rheartbeat_req\030\006 \001(\0132&.zjchain.dht.p"
    "rotobuf.HeartbeatRequest\022>\n\rheartbeat_re"
    "s\030\007 \001(\0132\'.zjchain.dht.protobuf.Heartbeat"
    "Response\0221\n\005timer\030\010 \001(\0132\".zjchain.dht.pr"
    "otobuf.TimerRequest", 1219);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "protos/dht.proto", &protobuf_RegisterTypes);
  BootstrapRequest::default_instance_ = new BootstrapRequest();
  BootstrapResponse::default_instance_ = new BootstrapResponse();
  NodeInfo::default_instance_ = new NodeInfo();
  RefreshNeighborsRequest::default_instance_ = new RefreshNeighborsRequest();
  RefreshNeighborsResponse::default_instance_ = new RefreshNeighborsResponse();
  HeartbeatRequest::default_instance_ = new HeartbeatRequest();
  HeartbeatResponse::default_instance_ = new HeartbeatResponse();
  ConnectReqeust::default_instance_ = new ConnectReqeust();
  TimerRequest::default_instance_ = new TimerRequest();
  DhtMessage::default_instance_ = new DhtMessage();
  BootstrapRequest::default_instance_->InitAsDefaultInstance();
  BootstrapResponse::default_instance_->InitAsDefaultInstance();
  NodeInfo::default_instance_->InitAsDefaultInstance();
  RefreshNeighborsRequest::default_instance_->InitAsDefaultInstance();
  RefreshNeighborsResponse::default_instance_->InitAsDefaultInstance();
  HeartbeatRequest::default_instance_->InitAsDefaultInstance();
  HeartbeatResponse::default_instance_->InitAsDefaultInstance();
  ConnectReqeust::default_instance_->InitAsDefaultInstance();
  TimerRequest::default_instance_->InitAsDefaultInstance();
  DhtMessage::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_protos_2fdht_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_protos_2fdht_2eproto {
  StaticDescriptorInitializer_protos_2fdht_2eproto() {
    protobuf_AddDesc_protos_2fdht_2eproto();
  }
} static_descriptor_initializer_protos_2fdht_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int BootstrapRequest::kPubkeyFieldNumber;
const int BootstrapRequest::kPublicIpFieldNumber;
const int BootstrapRequest::kPublicPortFieldNumber;
#endif  // !_MSC_VER

BootstrapRequest::BootstrapRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BootstrapRequest::InitAsDefaultInstance() {
}

BootstrapRequest::BootstrapRequest(const BootstrapRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BootstrapRequest::SharedCtor() {
  _cached_size_ = 0;
  pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  public_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  public_port_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BootstrapRequest::~BootstrapRequest() {
  SharedDtor();
}

void BootstrapRequest::SharedDtor() {
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    delete pubkey_;
  }
  if (public_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete public_ip_;
  }
  if (this != default_instance_) {
  }
}

void BootstrapRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BootstrapRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BootstrapRequest_descriptor_;
}

const BootstrapRequest& BootstrapRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protos_2fdht_2eproto();
  return *default_instance_;
}

BootstrapRequest* BootstrapRequest::default_instance_ = NULL;

BootstrapRequest* BootstrapRequest::New() const {
  return new BootstrapRequest;
}

void BootstrapRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_pubkey()) {
      if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
        pubkey_->clear();
      }
    }
    if (has_public_ip()) {
      if (public_ip_ != &::google::protobuf::internal::kEmptyString) {
        public_ip_->clear();
      }
    }
    public_port_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BootstrapRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes pubkey = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_pubkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_public_ip;
        break;
      }

      // optional string public_ip = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_public_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_public_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->public_ip().data(), this->public_ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_public_port;
        break;
      }

      // optional int32 public_port = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_public_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &public_port_)));
          set_has_public_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BootstrapRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes pubkey = 1;
  if (has_pubkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->pubkey(), output);
  }

  // optional string public_ip = 2;
  if (has_public_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->public_ip().data(), this->public_ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->public_ip(), output);
  }

  // optional int32 public_port = 3;
  if (has_public_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->public_port(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BootstrapRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes pubkey = 1;
  if (has_pubkey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->pubkey(), target);
  }

  // optional string public_ip = 2;
  if (has_public_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->public_ip().data(), this->public_ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->public_ip(), target);
  }

  // optional int32 public_port = 3;
  if (has_public_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->public_port(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BootstrapRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes pubkey = 1;
    if (has_pubkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->pubkey());
    }

    // optional string public_ip = 2;
    if (has_public_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->public_ip());
    }

    // optional int32 public_port = 3;
    if (has_public_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->public_port());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BootstrapRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BootstrapRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BootstrapRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BootstrapRequest::MergeFrom(const BootstrapRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pubkey()) {
      set_pubkey(from.pubkey());
    }
    if (from.has_public_ip()) {
      set_public_ip(from.public_ip());
    }
    if (from.has_public_port()) {
      set_public_port(from.public_port());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BootstrapRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BootstrapRequest::CopyFrom(const BootstrapRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BootstrapRequest::IsInitialized() const {

  return true;
}

void BootstrapRequest::Swap(BootstrapRequest* other) {
  if (other != this) {
    std::swap(pubkey_, other->pubkey_);
    std::swap(public_ip_, other->public_ip_);
    std::swap(public_port_, other->public_port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BootstrapRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BootstrapRequest_descriptor_;
  metadata.reflection = BootstrapRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BootstrapResponse::kPubkeyFieldNumber;
const int BootstrapResponse::kPublicIpFieldNumber;
const int BootstrapResponse::kPublicPortFieldNumber;
#endif  // !_MSC_VER

BootstrapResponse::BootstrapResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BootstrapResponse::InitAsDefaultInstance() {
}

BootstrapResponse::BootstrapResponse(const BootstrapResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BootstrapResponse::SharedCtor() {
  _cached_size_ = 0;
  pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  public_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  public_port_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BootstrapResponse::~BootstrapResponse() {
  SharedDtor();
}

void BootstrapResponse::SharedDtor() {
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    delete pubkey_;
  }
  if (public_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete public_ip_;
  }
  if (this != default_instance_) {
  }
}

void BootstrapResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BootstrapResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BootstrapResponse_descriptor_;
}

const BootstrapResponse& BootstrapResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protos_2fdht_2eproto();
  return *default_instance_;
}

BootstrapResponse* BootstrapResponse::default_instance_ = NULL;

BootstrapResponse* BootstrapResponse::New() const {
  return new BootstrapResponse;
}

void BootstrapResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_pubkey()) {
      if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
        pubkey_->clear();
      }
    }
    if (has_public_ip()) {
      if (public_ip_ != &::google::protobuf::internal::kEmptyString) {
        public_ip_->clear();
      }
    }
    public_port_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BootstrapResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes pubkey = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_pubkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_public_ip;
        break;
      }

      // optional string public_ip = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_public_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_public_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->public_ip().data(), this->public_ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_public_port;
        break;
      }

      // optional int32 public_port = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_public_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &public_port_)));
          set_has_public_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BootstrapResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes pubkey = 1;
  if (has_pubkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->pubkey(), output);
  }

  // optional string public_ip = 2;
  if (has_public_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->public_ip().data(), this->public_ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->public_ip(), output);
  }

  // optional int32 public_port = 3;
  if (has_public_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->public_port(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BootstrapResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes pubkey = 1;
  if (has_pubkey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->pubkey(), target);
  }

  // optional string public_ip = 2;
  if (has_public_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->public_ip().data(), this->public_ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->public_ip(), target);
  }

  // optional int32 public_port = 3;
  if (has_public_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->public_port(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BootstrapResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes pubkey = 1;
    if (has_pubkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->pubkey());
    }

    // optional string public_ip = 2;
    if (has_public_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->public_ip());
    }

    // optional int32 public_port = 3;
    if (has_public_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->public_port());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BootstrapResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BootstrapResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BootstrapResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BootstrapResponse::MergeFrom(const BootstrapResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pubkey()) {
      set_pubkey(from.pubkey());
    }
    if (from.has_public_ip()) {
      set_public_ip(from.public_ip());
    }
    if (from.has_public_port()) {
      set_public_port(from.public_port());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BootstrapResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BootstrapResponse::CopyFrom(const BootstrapResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BootstrapResponse::IsInitialized() const {

  return true;
}

void BootstrapResponse::Swap(BootstrapResponse* other) {
  if (other != this) {
    std::swap(pubkey_, other->pubkey_);
    std::swap(public_ip_, other->public_ip_);
    std::swap(public_port_, other->public_port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BootstrapResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BootstrapResponse_descriptor_;
  metadata.reflection = BootstrapResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NodeInfo::kPublicIpFieldNumber;
const int NodeInfo::kPublicPortFieldNumber;
const int NodeInfo::kPubkeyFieldNumber;
#endif  // !_MSC_VER

NodeInfo::NodeInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NodeInfo::InitAsDefaultInstance() {
}

NodeInfo::NodeInfo(const NodeInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NodeInfo::SharedCtor() {
  _cached_size_ = 0;
  public_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  public_port_ = 0;
  pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NodeInfo::~NodeInfo() {
  SharedDtor();
}

void NodeInfo::SharedDtor() {
  if (public_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete public_ip_;
  }
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    delete pubkey_;
  }
  if (this != default_instance_) {
  }
}

void NodeInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NodeInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NodeInfo_descriptor_;
}

const NodeInfo& NodeInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protos_2fdht_2eproto();
  return *default_instance_;
}

NodeInfo* NodeInfo::default_instance_ = NULL;

NodeInfo* NodeInfo::New() const {
  return new NodeInfo;
}

void NodeInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_public_ip()) {
      if (public_ip_ != &::google::protobuf::internal::kEmptyString) {
        public_ip_->clear();
      }
    }
    public_port_ = 0;
    if (has_pubkey()) {
      if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
        pubkey_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NodeInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes public_ip = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_public_ip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_public_port;
        break;
      }

      // optional int32 public_port = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_public_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &public_port_)));
          set_has_public_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_pubkey;
        break;
      }

      // optional bytes pubkey = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pubkey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_pubkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NodeInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes public_ip = 1;
  if (has_public_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->public_ip(), output);
  }

  // optional int32 public_port = 2;
  if (has_public_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->public_port(), output);
  }

  // optional bytes pubkey = 3;
  if (has_pubkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->pubkey(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NodeInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes public_ip = 1;
  if (has_public_ip()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->public_ip(), target);
  }

  // optional int32 public_port = 2;
  if (has_public_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->public_port(), target);
  }

  // optional bytes pubkey = 3;
  if (has_pubkey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->pubkey(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NodeInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes public_ip = 1;
    if (has_public_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->public_ip());
    }

    // optional int32 public_port = 2;
    if (has_public_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->public_port());
    }

    // optional bytes pubkey = 3;
    if (has_pubkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->pubkey());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NodeInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NodeInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NodeInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NodeInfo::MergeFrom(const NodeInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_public_ip()) {
      set_public_ip(from.public_ip());
    }
    if (from.has_public_port()) {
      set_public_port(from.public_port());
    }
    if (from.has_pubkey()) {
      set_pubkey(from.pubkey());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NodeInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NodeInfo::CopyFrom(const NodeInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeInfo::IsInitialized() const {

  return true;
}

void NodeInfo::Swap(NodeInfo* other) {
  if (other != this) {
    std::swap(public_ip_, other->public_ip_);
    std::swap(public_port_, other->public_port_);
    std::swap(pubkey_, other->pubkey_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NodeInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NodeInfo_descriptor_;
  metadata.reflection = NodeInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RefreshNeighborsRequest::kCountFieldNumber;
const int RefreshNeighborsRequest::kBloomfilterFieldNumber;
const int RefreshNeighborsRequest::kPubkeyFieldNumber;
const int RefreshNeighborsRequest::kPublicIpFieldNumber;
const int RefreshNeighborsRequest::kPublicPortFieldNumber;
const int RefreshNeighborsRequest::kIdsFieldNumber;
#endif  // !_MSC_VER

RefreshNeighborsRequest::RefreshNeighborsRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RefreshNeighborsRequest::InitAsDefaultInstance() {
}

RefreshNeighborsRequest::RefreshNeighborsRequest(const RefreshNeighborsRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RefreshNeighborsRequest::SharedCtor() {
  _cached_size_ = 0;
  count_ = 0u;
  pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  public_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  public_port_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RefreshNeighborsRequest::~RefreshNeighborsRequest() {
  SharedDtor();
}

void RefreshNeighborsRequest::SharedDtor() {
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    delete pubkey_;
  }
  if (public_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete public_ip_;
  }
  if (this != default_instance_) {
  }
}

void RefreshNeighborsRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RefreshNeighborsRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RefreshNeighborsRequest_descriptor_;
}

const RefreshNeighborsRequest& RefreshNeighborsRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protos_2fdht_2eproto();
  return *default_instance_;
}

RefreshNeighborsRequest* RefreshNeighborsRequest::default_instance_ = NULL;

RefreshNeighborsRequest* RefreshNeighborsRequest::New() const {
  return new RefreshNeighborsRequest;
}

void RefreshNeighborsRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    count_ = 0u;
    if (has_pubkey()) {
      if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
        pubkey_->clear();
      }
    }
    if (has_public_ip()) {
      if (public_ip_ != &::google::protobuf::internal::kEmptyString) {
        public_ip_->clear();
      }
    }
    public_port_ = 0;
  }
  bloomfilter_.Clear();
  ids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RefreshNeighborsRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 count = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_bloomfilter;
        break;
      }

      // repeated uint64 bloomfilter = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bloomfilter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 16, input, this->mutable_bloomfilter())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_bloomfilter())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_bloomfilter;
        if (input->ExpectTag(26)) goto parse_pubkey;
        break;
      }

      // optional bytes pubkey = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pubkey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_pubkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_public_ip;
        break;
      }

      // optional string public_ip = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_public_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_public_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->public_ip().data(), this->public_ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_public_port;
        break;
      }

      // optional int32 public_port = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_public_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &public_port_)));
          set_has_public_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_ids;
        break;
      }

      // repeated bytes ids = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_ids()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_ids;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RefreshNeighborsRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 count = 1;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->count(), output);
  }

  // repeated uint64 bloomfilter = 2;
  for (int i = 0; i < this->bloomfilter_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      2, this->bloomfilter(i), output);
  }

  // optional bytes pubkey = 3;
  if (has_pubkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->pubkey(), output);
  }

  // optional string public_ip = 4;
  if (has_public_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->public_ip().data(), this->public_ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->public_ip(), output);
  }

  // optional int32 public_port = 5;
  if (has_public_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->public_port(), output);
  }

  // repeated bytes ids = 6;
  for (int i = 0; i < this->ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->ids(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RefreshNeighborsRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 count = 1;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->count(), target);
  }

  // repeated uint64 bloomfilter = 2;
  for (int i = 0; i < this->bloomfilter_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64ToArray(2, this->bloomfilter(i), target);
  }

  // optional bytes pubkey = 3;
  if (has_pubkey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->pubkey(), target);
  }

  // optional string public_ip = 4;
  if (has_public_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->public_ip().data(), this->public_ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->public_ip(), target);
  }

  // optional int32 public_port = 5;
  if (has_public_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->public_port(), target);
  }

  // repeated bytes ids = 6;
  for (int i = 0; i < this->ids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(6, this->ids(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RefreshNeighborsRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 count = 1;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

    // optional bytes pubkey = 3;
    if (has_pubkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->pubkey());
    }

    // optional string public_ip = 4;
    if (has_public_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->public_ip());
    }

    // optional int32 public_port = 5;
    if (has_public_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->public_port());
    }

  }
  // repeated uint64 bloomfilter = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->bloomfilter_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->bloomfilter(i));
    }
    total_size += 1 * this->bloomfilter_size() + data_size;
  }

  // repeated bytes ids = 6;
  total_size += 1 * this->ids_size();
  for (int i = 0; i < this->ids_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->ids(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RefreshNeighborsRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RefreshNeighborsRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RefreshNeighborsRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RefreshNeighborsRequest::MergeFrom(const RefreshNeighborsRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  bloomfilter_.MergeFrom(from.bloomfilter_);
  ids_.MergeFrom(from.ids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_count()) {
      set_count(from.count());
    }
    if (from.has_pubkey()) {
      set_pubkey(from.pubkey());
    }
    if (from.has_public_ip()) {
      set_public_ip(from.public_ip());
    }
    if (from.has_public_port()) {
      set_public_port(from.public_port());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RefreshNeighborsRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RefreshNeighborsRequest::CopyFrom(const RefreshNeighborsRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RefreshNeighborsRequest::IsInitialized() const {

  return true;
}

void RefreshNeighborsRequest::Swap(RefreshNeighborsRequest* other) {
  if (other != this) {
    std::swap(count_, other->count_);
    bloomfilter_.Swap(&other->bloomfilter_);
    std::swap(pubkey_, other->pubkey_);
    std::swap(public_ip_, other->public_ip_);
    std::swap(public_port_, other->public_port_);
    ids_.Swap(&other->ids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RefreshNeighborsRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RefreshNeighborsRequest_descriptor_;
  metadata.reflection = RefreshNeighborsRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RefreshNeighborsResponse::kNodesFieldNumber;
#endif  // !_MSC_VER

RefreshNeighborsResponse::RefreshNeighborsResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RefreshNeighborsResponse::InitAsDefaultInstance() {
}

RefreshNeighborsResponse::RefreshNeighborsResponse(const RefreshNeighborsResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RefreshNeighborsResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RefreshNeighborsResponse::~RefreshNeighborsResponse() {
  SharedDtor();
}

void RefreshNeighborsResponse::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RefreshNeighborsResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RefreshNeighborsResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RefreshNeighborsResponse_descriptor_;
}

const RefreshNeighborsResponse& RefreshNeighborsResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protos_2fdht_2eproto();
  return *default_instance_;
}

RefreshNeighborsResponse* RefreshNeighborsResponse::default_instance_ = NULL;

RefreshNeighborsResponse* RefreshNeighborsResponse::New() const {
  return new RefreshNeighborsResponse;
}

void RefreshNeighborsResponse::Clear() {
  nodes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RefreshNeighborsResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .zjchain.dht.protobuf.NodeInfo nodes = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nodes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_nodes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_nodes;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RefreshNeighborsResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .zjchain.dht.protobuf.NodeInfo nodes = 1;
  for (int i = 0; i < this->nodes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->nodes(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RefreshNeighborsResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .zjchain.dht.protobuf.NodeInfo nodes = 1;
  for (int i = 0; i < this->nodes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->nodes(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RefreshNeighborsResponse::ByteSize() const {
  int total_size = 0;

  // repeated .zjchain.dht.protobuf.NodeInfo nodes = 1;
  total_size += 1 * this->nodes_size();
  for (int i = 0; i < this->nodes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->nodes(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RefreshNeighborsResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RefreshNeighborsResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RefreshNeighborsResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RefreshNeighborsResponse::MergeFrom(const RefreshNeighborsResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  nodes_.MergeFrom(from.nodes_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RefreshNeighborsResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RefreshNeighborsResponse::CopyFrom(const RefreshNeighborsResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RefreshNeighborsResponse::IsInitialized() const {

  return true;
}

void RefreshNeighborsResponse::Swap(RefreshNeighborsResponse* other) {
  if (other != this) {
    nodes_.Swap(&other->nodes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RefreshNeighborsResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RefreshNeighborsResponse_descriptor_;
  metadata.reflection = RefreshNeighborsResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HeartbeatRequest::kDhtKeyHashFieldNumber;
#endif  // !_MSC_VER

HeartbeatRequest::HeartbeatRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void HeartbeatRequest::InitAsDefaultInstance() {
}

HeartbeatRequest::HeartbeatRequest(const HeartbeatRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void HeartbeatRequest::SharedCtor() {
  _cached_size_ = 0;
  dht_key_hash_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HeartbeatRequest::~HeartbeatRequest() {
  SharedDtor();
}

void HeartbeatRequest::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HeartbeatRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HeartbeatRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HeartbeatRequest_descriptor_;
}

const HeartbeatRequest& HeartbeatRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protos_2fdht_2eproto();
  return *default_instance_;
}

HeartbeatRequest* HeartbeatRequest::default_instance_ = NULL;

HeartbeatRequest* HeartbeatRequest::New() const {
  return new HeartbeatRequest;
}

void HeartbeatRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    dht_key_hash_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HeartbeatRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dht_key_hash = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dht_key_hash_)));
          set_has_dht_key_hash();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HeartbeatRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 dht_key_hash = 1;
  if (has_dht_key_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->dht_key_hash(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* HeartbeatRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint64 dht_key_hash = 1;
  if (has_dht_key_hash()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->dht_key_hash(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int HeartbeatRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 dht_key_hash = 1;
    if (has_dht_key_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->dht_key_hash());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HeartbeatRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HeartbeatRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HeartbeatRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HeartbeatRequest::MergeFrom(const HeartbeatRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dht_key_hash()) {
      set_dht_key_hash(from.dht_key_hash());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HeartbeatRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HeartbeatRequest::CopyFrom(const HeartbeatRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartbeatRequest::IsInitialized() const {

  return true;
}

void HeartbeatRequest::Swap(HeartbeatRequest* other) {
  if (other != this) {
    std::swap(dht_key_hash_, other->dht_key_hash_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HeartbeatRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HeartbeatRequest_descriptor_;
  metadata.reflection = HeartbeatRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HeartbeatResponse::kDhtKeyHashFieldNumber;
#endif  // !_MSC_VER

HeartbeatResponse::HeartbeatResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void HeartbeatResponse::InitAsDefaultInstance() {
}

HeartbeatResponse::HeartbeatResponse(const HeartbeatResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void HeartbeatResponse::SharedCtor() {
  _cached_size_ = 0;
  dht_key_hash_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HeartbeatResponse::~HeartbeatResponse() {
  SharedDtor();
}

void HeartbeatResponse::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HeartbeatResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HeartbeatResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HeartbeatResponse_descriptor_;
}

const HeartbeatResponse& HeartbeatResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protos_2fdht_2eproto();
  return *default_instance_;
}

HeartbeatResponse* HeartbeatResponse::default_instance_ = NULL;

HeartbeatResponse* HeartbeatResponse::New() const {
  return new HeartbeatResponse;
}

void HeartbeatResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    dht_key_hash_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HeartbeatResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dht_key_hash = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dht_key_hash_)));
          set_has_dht_key_hash();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HeartbeatResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 dht_key_hash = 1;
  if (has_dht_key_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->dht_key_hash(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* HeartbeatResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint64 dht_key_hash = 1;
  if (has_dht_key_hash()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->dht_key_hash(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int HeartbeatResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 dht_key_hash = 1;
    if (has_dht_key_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->dht_key_hash());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HeartbeatResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HeartbeatResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HeartbeatResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HeartbeatResponse::MergeFrom(const HeartbeatResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dht_key_hash()) {
      set_dht_key_hash(from.dht_key_hash());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HeartbeatResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HeartbeatResponse::CopyFrom(const HeartbeatResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartbeatResponse::IsInitialized() const {

  return true;
}

void HeartbeatResponse::Swap(HeartbeatResponse* other) {
  if (other != this) {
    std::swap(dht_key_hash_, other->dht_key_hash_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HeartbeatResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HeartbeatResponse_descriptor_;
  metadata.reflection = HeartbeatResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ConnectReqeust::kPubkeyFieldNumber;
const int ConnectReqeust::kIsResponseFieldNumber;
const int ConnectReqeust::kPublicIpFieldNumber;
const int ConnectReqeust::kPublicPortFieldNumber;
#endif  // !_MSC_VER

ConnectReqeust::ConnectReqeust()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ConnectReqeust::InitAsDefaultInstance() {
}

ConnectReqeust::ConnectReqeust(const ConnectReqeust& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ConnectReqeust::SharedCtor() {
  _cached_size_ = 0;
  pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  is_response_ = false;
  public_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  public_port_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConnectReqeust::~ConnectReqeust() {
  SharedDtor();
}

void ConnectReqeust::SharedDtor() {
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    delete pubkey_;
  }
  if (public_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete public_ip_;
  }
  if (this != default_instance_) {
  }
}

void ConnectReqeust::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ConnectReqeust::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ConnectReqeust_descriptor_;
}

const ConnectReqeust& ConnectReqeust::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protos_2fdht_2eproto();
  return *default_instance_;
}

ConnectReqeust* ConnectReqeust::default_instance_ = NULL;

ConnectReqeust* ConnectReqeust::New() const {
  return new ConnectReqeust;
}

void ConnectReqeust::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_pubkey()) {
      if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
        pubkey_->clear();
      }
    }
    is_response_ = false;
    if (has_public_ip()) {
      if (public_ip_ != &::google::protobuf::internal::kEmptyString) {
        public_ip_->clear();
      }
    }
    public_port_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ConnectReqeust::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes pubkey = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_pubkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_is_response;
        break;
      }

      // optional bool is_response = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_response:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_response_)));
          set_has_is_response();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_public_ip;
        break;
      }

      // optional string public_ip = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_public_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_public_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->public_ip().data(), this->public_ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_public_port;
        break;
      }

      // optional int32 public_port = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_public_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &public_port_)));
          set_has_public_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ConnectReqeust::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes pubkey = 1;
  if (has_pubkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->pubkey(), output);
  }

  // optional bool is_response = 2;
  if (has_is_response()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->is_response(), output);
  }

  // optional string public_ip = 3;
  if (has_public_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->public_ip().data(), this->public_ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->public_ip(), output);
  }

  // optional int32 public_port = 4;
  if (has_public_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->public_port(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ConnectReqeust::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes pubkey = 1;
  if (has_pubkey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->pubkey(), target);
  }

  // optional bool is_response = 2;
  if (has_is_response()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->is_response(), target);
  }

  // optional string public_ip = 3;
  if (has_public_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->public_ip().data(), this->public_ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->public_ip(), target);
  }

  // optional int32 public_port = 4;
  if (has_public_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->public_port(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ConnectReqeust::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes pubkey = 1;
    if (has_pubkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->pubkey());
    }

    // optional bool is_response = 2;
    if (has_is_response()) {
      total_size += 1 + 1;
    }

    // optional string public_ip = 3;
    if (has_public_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->public_ip());
    }

    // optional int32 public_port = 4;
    if (has_public_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->public_port());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConnectReqeust::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ConnectReqeust* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ConnectReqeust*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ConnectReqeust::MergeFrom(const ConnectReqeust& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pubkey()) {
      set_pubkey(from.pubkey());
    }
    if (from.has_is_response()) {
      set_is_response(from.is_response());
    }
    if (from.has_public_ip()) {
      set_public_ip(from.public_ip());
    }
    if (from.has_public_port()) {
      set_public_port(from.public_port());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ConnectReqeust::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConnectReqeust::CopyFrom(const ConnectReqeust& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectReqeust::IsInitialized() const {

  return true;
}

void ConnectReqeust::Swap(ConnectReqeust* other) {
  if (other != this) {
    std::swap(pubkey_, other->pubkey_);
    std::swap(is_response_, other->is_response_);
    std::swap(public_ip_, other->public_ip_);
    std::swap(public_port_, other->public_port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ConnectReqeust::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ConnectReqeust_descriptor_;
  metadata.reflection = ConnectReqeust_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TimerRequest::kTmMilliFieldNumber;
#endif  // !_MSC_VER

TimerRequest::TimerRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TimerRequest::InitAsDefaultInstance() {
}

TimerRequest::TimerRequest(const TimerRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TimerRequest::SharedCtor() {
  _cached_size_ = 0;
  tm_milli_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TimerRequest::~TimerRequest() {
  SharedDtor();
}

void TimerRequest::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TimerRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TimerRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TimerRequest_descriptor_;
}

const TimerRequest& TimerRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protos_2fdht_2eproto();
  return *default_instance_;
}

TimerRequest* TimerRequest::default_instance_ = NULL;

TimerRequest* TimerRequest::New() const {
  return new TimerRequest;
}

void TimerRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    tm_milli_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TimerRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 tm_milli = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &tm_milli_)));
          set_has_tm_milli();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TimerRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 tm_milli = 1;
  if (has_tm_milli()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->tm_milli(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TimerRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint64 tm_milli = 1;
  if (has_tm_milli()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->tm_milli(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TimerRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 tm_milli = 1;
    if (has_tm_milli()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->tm_milli());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TimerRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TimerRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TimerRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TimerRequest::MergeFrom(const TimerRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tm_milli()) {
      set_tm_milli(from.tm_milli());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TimerRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TimerRequest::CopyFrom(const TimerRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimerRequest::IsInitialized() const {

  return true;
}

void TimerRequest::Swap(TimerRequest* other) {
  if (other != this) {
    std::swap(tm_milli_, other->tm_milli_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TimerRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TimerRequest_descriptor_;
  metadata.reflection = TimerRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DhtMessage::kBootstrapReqFieldNumber;
const int DhtMessage::kBootstrapResFieldNumber;
const int DhtMessage::kRefreshNeighborsReqFieldNumber;
const int DhtMessage::kRefreshNeighborsResFieldNumber;
const int DhtMessage::kConnectReqFieldNumber;
const int DhtMessage::kHeartbeatReqFieldNumber;
const int DhtMessage::kHeartbeatResFieldNumber;
const int DhtMessage::kTimerFieldNumber;
#endif  // !_MSC_VER

DhtMessage::DhtMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DhtMessage::InitAsDefaultInstance() {
  bootstrap_req_ = const_cast< ::zjchain::dht::protobuf::BootstrapRequest*>(&::zjchain::dht::protobuf::BootstrapRequest::default_instance());
  bootstrap_res_ = const_cast< ::zjchain::dht::protobuf::BootstrapResponse*>(&::zjchain::dht::protobuf::BootstrapResponse::default_instance());
  refresh_neighbors_req_ = const_cast< ::zjchain::dht::protobuf::RefreshNeighborsRequest*>(&::zjchain::dht::protobuf::RefreshNeighborsRequest::default_instance());
  refresh_neighbors_res_ = const_cast< ::zjchain::dht::protobuf::RefreshNeighborsResponse*>(&::zjchain::dht::protobuf::RefreshNeighborsResponse::default_instance());
  connect_req_ = const_cast< ::zjchain::dht::protobuf::ConnectReqeust*>(&::zjchain::dht::protobuf::ConnectReqeust::default_instance());
  heartbeat_req_ = const_cast< ::zjchain::dht::protobuf::HeartbeatRequest*>(&::zjchain::dht::protobuf::HeartbeatRequest::default_instance());
  heartbeat_res_ = const_cast< ::zjchain::dht::protobuf::HeartbeatResponse*>(&::zjchain::dht::protobuf::HeartbeatResponse::default_instance());
  timer_ = const_cast< ::zjchain::dht::protobuf::TimerRequest*>(&::zjchain::dht::protobuf::TimerRequest::default_instance());
}

DhtMessage::DhtMessage(const DhtMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DhtMessage::SharedCtor() {
  _cached_size_ = 0;
  bootstrap_req_ = NULL;
  bootstrap_res_ = NULL;
  refresh_neighbors_req_ = NULL;
  refresh_neighbors_res_ = NULL;
  connect_req_ = NULL;
  heartbeat_req_ = NULL;
  heartbeat_res_ = NULL;
  timer_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DhtMessage::~DhtMessage() {
  SharedDtor();
}

void DhtMessage::SharedDtor() {
  if (this != default_instance_) {
    delete bootstrap_req_;
    delete bootstrap_res_;
    delete refresh_neighbors_req_;
    delete refresh_neighbors_res_;
    delete connect_req_;
    delete heartbeat_req_;
    delete heartbeat_res_;
    delete timer_;
  }
}

void DhtMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DhtMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DhtMessage_descriptor_;
}

const DhtMessage& DhtMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protos_2fdht_2eproto();
  return *default_instance_;
}

DhtMessage* DhtMessage::default_instance_ = NULL;

DhtMessage* DhtMessage::New() const {
  return new DhtMessage;
}

void DhtMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_bootstrap_req()) {
      if (bootstrap_req_ != NULL) bootstrap_req_->::zjchain::dht::protobuf::BootstrapRequest::Clear();
    }
    if (has_bootstrap_res()) {
      if (bootstrap_res_ != NULL) bootstrap_res_->::zjchain::dht::protobuf::BootstrapResponse::Clear();
    }
    if (has_refresh_neighbors_req()) {
      if (refresh_neighbors_req_ != NULL) refresh_neighbors_req_->::zjchain::dht::protobuf::RefreshNeighborsRequest::Clear();
    }
    if (has_refresh_neighbors_res()) {
      if (refresh_neighbors_res_ != NULL) refresh_neighbors_res_->::zjchain::dht::protobuf::RefreshNeighborsResponse::Clear();
    }
    if (has_connect_req()) {
      if (connect_req_ != NULL) connect_req_->::zjchain::dht::protobuf::ConnectReqeust::Clear();
    }
    if (has_heartbeat_req()) {
      if (heartbeat_req_ != NULL) heartbeat_req_->::zjchain::dht::protobuf::HeartbeatRequest::Clear();
    }
    if (has_heartbeat_res()) {
      if (heartbeat_res_ != NULL) heartbeat_res_->::zjchain::dht::protobuf::HeartbeatResponse::Clear();
    }
    if (has_timer()) {
      if (timer_ != NULL) timer_->::zjchain::dht::protobuf::TimerRequest::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DhtMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .zjchain.dht.protobuf.BootstrapRequest bootstrap_req = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bootstrap_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_bootstrap_res;
        break;
      }

      // optional .zjchain.dht.protobuf.BootstrapResponse bootstrap_res = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bootstrap_res:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bootstrap_res()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_refresh_neighbors_req;
        break;
      }

      // optional .zjchain.dht.protobuf.RefreshNeighborsRequest refresh_neighbors_req = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_refresh_neighbors_req:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_refresh_neighbors_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_refresh_neighbors_res;
        break;
      }

      // optional .zjchain.dht.protobuf.RefreshNeighborsResponse refresh_neighbors_res = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_refresh_neighbors_res:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_refresh_neighbors_res()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_connect_req;
        break;
      }

      // optional .zjchain.dht.protobuf.ConnectReqeust connect_req = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_connect_req:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_connect_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_heartbeat_req;
        break;
      }

      // optional .zjchain.dht.protobuf.HeartbeatRequest heartbeat_req = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_heartbeat_req:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_heartbeat_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_heartbeat_res;
        break;
      }

      // optional .zjchain.dht.protobuf.HeartbeatResponse heartbeat_res = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_heartbeat_res:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_heartbeat_res()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_timer;
        break;
      }

      // optional .zjchain.dht.protobuf.TimerRequest timer = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_timer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DhtMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .zjchain.dht.protobuf.BootstrapRequest bootstrap_req = 1;
  if (has_bootstrap_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->bootstrap_req(), output);
  }

  // optional .zjchain.dht.protobuf.BootstrapResponse bootstrap_res = 2;
  if (has_bootstrap_res()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->bootstrap_res(), output);
  }

  // optional .zjchain.dht.protobuf.RefreshNeighborsRequest refresh_neighbors_req = 3;
  if (has_refresh_neighbors_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->refresh_neighbors_req(), output);
  }

  // optional .zjchain.dht.protobuf.RefreshNeighborsResponse refresh_neighbors_res = 4;
  if (has_refresh_neighbors_res()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->refresh_neighbors_res(), output);
  }

  // optional .zjchain.dht.protobuf.ConnectReqeust connect_req = 5;
  if (has_connect_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->connect_req(), output);
  }

  // optional .zjchain.dht.protobuf.HeartbeatRequest heartbeat_req = 6;
  if (has_heartbeat_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->heartbeat_req(), output);
  }

  // optional .zjchain.dht.protobuf.HeartbeatResponse heartbeat_res = 7;
  if (has_heartbeat_res()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->heartbeat_res(), output);
  }

  // optional .zjchain.dht.protobuf.TimerRequest timer = 8;
  if (has_timer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->timer(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DhtMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .zjchain.dht.protobuf.BootstrapRequest bootstrap_req = 1;
  if (has_bootstrap_req()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->bootstrap_req(), target);
  }

  // optional .zjchain.dht.protobuf.BootstrapResponse bootstrap_res = 2;
  if (has_bootstrap_res()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->bootstrap_res(), target);
  }

  // optional .zjchain.dht.protobuf.RefreshNeighborsRequest refresh_neighbors_req = 3;
  if (has_refresh_neighbors_req()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->refresh_neighbors_req(), target);
  }

  // optional .zjchain.dht.protobuf.RefreshNeighborsResponse refresh_neighbors_res = 4;
  if (has_refresh_neighbors_res()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->refresh_neighbors_res(), target);
  }

  // optional .zjchain.dht.protobuf.ConnectReqeust connect_req = 5;
  if (has_connect_req()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->connect_req(), target);
  }

  // optional .zjchain.dht.protobuf.HeartbeatRequest heartbeat_req = 6;
  if (has_heartbeat_req()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->heartbeat_req(), target);
  }

  // optional .zjchain.dht.protobuf.HeartbeatResponse heartbeat_res = 7;
  if (has_heartbeat_res()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->heartbeat_res(), target);
  }

  // optional .zjchain.dht.protobuf.TimerRequest timer = 8;
  if (has_timer()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->timer(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DhtMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .zjchain.dht.protobuf.BootstrapRequest bootstrap_req = 1;
    if (has_bootstrap_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->bootstrap_req());
    }

    // optional .zjchain.dht.protobuf.BootstrapResponse bootstrap_res = 2;
    if (has_bootstrap_res()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->bootstrap_res());
    }

    // optional .zjchain.dht.protobuf.RefreshNeighborsRequest refresh_neighbors_req = 3;
    if (has_refresh_neighbors_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->refresh_neighbors_req());
    }

    // optional .zjchain.dht.protobuf.RefreshNeighborsResponse refresh_neighbors_res = 4;
    if (has_refresh_neighbors_res()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->refresh_neighbors_res());
    }

    // optional .zjchain.dht.protobuf.ConnectReqeust connect_req = 5;
    if (has_connect_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->connect_req());
    }

    // optional .zjchain.dht.protobuf.HeartbeatRequest heartbeat_req = 6;
    if (has_heartbeat_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->heartbeat_req());
    }

    // optional .zjchain.dht.protobuf.HeartbeatResponse heartbeat_res = 7;
    if (has_heartbeat_res()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->heartbeat_res());
    }

    // optional .zjchain.dht.protobuf.TimerRequest timer = 8;
    if (has_timer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->timer());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DhtMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DhtMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DhtMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DhtMessage::MergeFrom(const DhtMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_bootstrap_req()) {
      mutable_bootstrap_req()->::zjchain::dht::protobuf::BootstrapRequest::MergeFrom(from.bootstrap_req());
    }
    if (from.has_bootstrap_res()) {
      mutable_bootstrap_res()->::zjchain::dht::protobuf::BootstrapResponse::MergeFrom(from.bootstrap_res());
    }
    if (from.has_refresh_neighbors_req()) {
      mutable_refresh_neighbors_req()->::zjchain::dht::protobuf::RefreshNeighborsRequest::MergeFrom(from.refresh_neighbors_req());
    }
    if (from.has_refresh_neighbors_res()) {
      mutable_refresh_neighbors_res()->::zjchain::dht::protobuf::RefreshNeighborsResponse::MergeFrom(from.refresh_neighbors_res());
    }
    if (from.has_connect_req()) {
      mutable_connect_req()->::zjchain::dht::protobuf::ConnectReqeust::MergeFrom(from.connect_req());
    }
    if (from.has_heartbeat_req()) {
      mutable_heartbeat_req()->::zjchain::dht::protobuf::HeartbeatRequest::MergeFrom(from.heartbeat_req());
    }
    if (from.has_heartbeat_res()) {
      mutable_heartbeat_res()->::zjchain::dht::protobuf::HeartbeatResponse::MergeFrom(from.heartbeat_res());
    }
    if (from.has_timer()) {
      mutable_timer()->::zjchain::dht::protobuf::TimerRequest::MergeFrom(from.timer());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DhtMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DhtMessage::CopyFrom(const DhtMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DhtMessage::IsInitialized() const {

  return true;
}

void DhtMessage::Swap(DhtMessage* other) {
  if (other != this) {
    std::swap(bootstrap_req_, other->bootstrap_req_);
    std::swap(bootstrap_res_, other->bootstrap_res_);
    std::swap(refresh_neighbors_req_, other->refresh_neighbors_req_);
    std::swap(refresh_neighbors_res_, other->refresh_neighbors_res_);
    std::swap(connect_req_, other->connect_req_);
    std::swap(heartbeat_req_, other->heartbeat_req_);
    std::swap(heartbeat_res_, other->heartbeat_res_);
    std::swap(timer_, other->timer_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DhtMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DhtMessage_descriptor_;
  metadata.reflection = DhtMessage_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace dht
}  // namespace zjchain

// @@protoc_insertion_point(global_scope)
